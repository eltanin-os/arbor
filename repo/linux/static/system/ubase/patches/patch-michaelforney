diff -Naur ubase-20190312/LICENSE ubase/LICENSE
--- ubase-20190312/LICENSE	2022-06-21 05:00:29.000000000 -0300
+++ ubase/LICENSE	2022-11-07 16:04:18.782495385 -0300
@@ -32,3 +32,4 @@
 © 2014 Roberto E. Vargas Caballero <k0ga@shike2.com>
 © 2014 Jan Tatje <jan@jnt.io>
 © 2015 Risto Salminen <ripejcp@gmail.com>
+© 2019 Mattias Andrée <maandree@kth.se>
diff -Naur ubase-20190312/Makefile ubase/Makefile
--- ubase-20190312/Makefile	2022-06-21 05:00:29.000000000 -0300
+++ ubase/Makefile	2022-11-09 12:38:14.110418703 -0300
@@ -61,7 +61,6 @@
 	lsmod             \
 	lsusb             \
 	mesg              \
-	mknod             \
 	mkswap            \
 	mount             \
 	mountpoint        \
@@ -76,6 +75,7 @@
 	respawn           \
 	rmmod             \
 	stat              \
+	stty              \
 	su                \
 	swaplabel         \
 	swapoff           \
@@ -86,6 +86,7 @@
 	umount            \
 	unshare           \
 	uptime            \
+	vmstat            \
 	vtallow           \
 	watch             \
 	who
@@ -102,7 +103,6 @@
 	id.1                \
 	login.1             \
 	mesg.1              \
-	mknod.1             \
 	mountpoint.1        \
 	pagesize.1          \
 	passwd.1            \
diff -Naur ubase-20190312/TODO ubase/TODO
--- ubase-20190312/TODO	2022-06-21 05:00:29.000000000 -0300
+++ ubase/TODO	2022-11-07 16:04:18.782495385 -0300
@@ -23,11 +23,12 @@
 rmgroup
 rmuser
 setcap
+stty manpage
 tabs
 taskset
 top
 tput
-vmstat
+vmstat [-sdDpS]
 
 Misc
 ====
diff -Naur ubase-20190312/dd.c ubase/dd.c
--- ubase-20190312/dd.c	2022-06-21 05:00:29.000000000 -0300
+++ ubase/dd.c	2022-11-09 12:34:56.160408927 -0300
@@ -126,14 +126,16 @@
 	}
 
 	if (lseek(*ifd, ddc->skip, SEEK_CUR) < 0) {
-		char buffer[ddc->bs];
+		char *buffer = emalloc(ddc->bs);
 		for (uint64_t i = 0; i < ddc->skip; i += ddc->bs) {
-			if (read(*ifd, &buffer, ddc->bs) < 0) {
+			if (read(*ifd, buffer, ddc->bs) < 0) {
 				errno = EINVAL;
 				close(*ifd);
+				free(buffer);
 				return -1;
 			}
 		}
+		free(buffer);
 	}
 	lseek(*ofd, ddc->seek, SEEK_CUR);
 	posix_fadvise(*ifd, ddc->skip, 0, POSIX_FADV_SEQUENTIAL);
diff -Naur ubase-20190312/df.c ubase/df.c
--- ubase-20190312/df.c	2022-06-21 05:00:29.000000000 -0300
+++ ubase/df.c	2022-11-07 16:04:18.792495386 -0300
@@ -65,8 +65,8 @@
 
 	bs = s.f_frsize / blksize;
 	total = s.f_blocks * bs;
-	avail = s.f_bfree * bs;
-	used = total - avail;
+	avail = s.f_bavail * bs;
+	used = total - s.f_bfree * bs;
 
 	if (used + avail) {
 		capacity = (used * 100) / (used + avail);
diff -Naur ubase-20190312/hwclock.c ubase/hwclock.c
--- ubase-20190312/hwclock.c	2022-06-21 05:00:29.000000000 -0300
+++ ubase/hwclock.c	2022-11-07 16:04:18.792495386 -0300
@@ -115,7 +115,7 @@
 int
 main(int argc, char *argv[])
 {
-	char *dev = "/dev/rtc";
+	char *dev = "/dev/rtc0";
 	int rflag = 0;
 	int sflag = 0;
 	int wflag = 0;
diff -Naur ubase-20190312/libutil/passwd.c ubase/libutil/passwd.c
--- ubase-20190312/libutil/passwd.c	2022-06-21 05:00:29.000000000 -0300
+++ ubase/libutil/passwd.c	2022-11-07 16:04:18.792495386 -0300
@@ -23,19 +23,7 @@
 	struct spwd *spw;
 
 	p = pw->pw_passwd;
-	if (p[0] == '!' || p[0] == '*') {
-		weprintf("denied\n");
-		return -1;
-	}
-
-	if (pw->pw_passwd[0] == '\0') {
-		if (pass[0] == '\0')
-			return 1;
-		weprintf("incorrect password\n");
-		return 0;
-	}
-
-	if (pw->pw_passwd[0] == 'x' && pw->pw_passwd[1] == '\0') {
+	if (p[0] == 'x' && p[1] == '\0') {
 		errno = 0;
 		spw = getspnam(pw->pw_name);
 		if (!spw) {
@@ -46,10 +34,16 @@
 			return -1;
 		}
 		p = spw->sp_pwdp;
-		if (p[0] == '!' || p[0] == '*') {
-			weprintf("denied\n");
-			return -1;
-		}
+	}
+	if (p[0] == '!' || p[0] == '*') {
+		weprintf("denied\n");
+		return -1;
+	}
+	if (p[0] == '\0') {
+		if (pass[0] == '\0')
+			return 1;
+		weprintf("incorrect password\n");
+		return 0;
 	}
 
 	cryptpass = crypt(pass, p);
diff -Naur ubase-20190312/libutil/tty.c ubase/libutil/tty.c
--- ubase-20190312/libutil/tty.c	2022-06-21 05:00:29.000000000 -0300
+++ ubase/libutil/tty.c	2022-11-07 16:04:18.802495386 -0300
@@ -1,6 +1,9 @@
 /* See LICENSE file for copyright and license details. */
-#include <sys/types.h>
 #include <sys/stat.h>
+#include <sys/types.h>
+#ifndef major
+#include <sys/sysmacros.h>
+#endif
 
 #include <fcntl.h>
 #include <dirent.h>
diff -Naur ubase-20190312/mknod.1 ubase/mknod.1
--- ubase-20190312/mknod.1	2022-06-21 05:00:29.000000000 -0300
+++ ubase/mknod.1	1969-12-31 21:00:00.000000000 -0300
@@ -1,37 +0,0 @@
-.Dd February 2, 2015
-.Dt MKNOD 1
-.Os ubase
-.Sh NAME
-.Nm mknod
-.Nd create a special device file
-.Sh SYNOPSIS
-.Nm
-.Op Fl m Ar mode
-.Ar name
-.Ar type
-.Ar major
-.Ar minor
-.Sh DESCRIPTION
-.Nm
-creates a special device file named
-.Ar name
-with major number
-.Ar major ,
-and minor number
-.Ar minor .
-.Ar type
-specifies what kind of special file will be created and must be one of:
-.Bl -tag -width Ds
-.It Ar u | c
-A character device.
-.It Ar b
-A block device.
-.El
-.Sh OPTIONS
-.Bl -tag -width Ds
-.It Fl m
-Set the mode of the new file based on the octal value of
-.Ar mode .
-.El
-.Sh SEE ALSO
-.Xr mknod 2
diff -Naur ubase-20190312/mknod.c ubase/mknod.c
--- ubase-20190312/mknod.c	2022-06-21 05:00:29.000000000 -0300
+++ ubase/mknod.c	1969-12-31 21:00:00.000000000 -0300
@@ -1,45 +0,0 @@
-/* See LICENSE file for copyright and license details. */
-#include <sys/stat.h>
-#include <sys/types.h>
-
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-
-#include "util.h"
-
-static void
-usage(void)
-{
-	eprintf("usage: %s [-m mode] name type major minor\n", argv0);
-}
-
-int
-main(int argc, char *argv[])
-{
-	mode_t type, mode = 0644;
-	dev_t dev;
-
-	ARGBEGIN {
-	case 'm':
-		mode = estrtol(EARGF(usage()), 8);
-		break;
-	default:
-		usage();
-	} ARGEND;
-
-	if (argc != 4)
-		usage();
-
-	if (strlen(argv[1]) != 1 || !strchr("ucb", argv[1][0]))
-		eprintf("mknod: '%s': invalid type\n", argv[1]);
-	type = (argv[1][0] == 'b') ? S_IFBLK : S_IFCHR;
-
-	dev = makedev(estrtol(argv[2], 0), estrtol(argv[3], 0));
-
-	if (mknod(argv[0], type|mode, dev) == -1)
-		eprintf("mknod: '%s':", argv[0]);
-	return 0;
-}
diff -Naur ubase-20190312/mkswap.c ubase/mkswap.c
--- ubase-20190312/mkswap.c	2022-06-21 05:00:29.000000000 -0300
+++ ubase/mkswap.c	2022-11-07 16:04:18.802495386 -0300
@@ -72,7 +72,7 @@
 	hdr = (struct swap_hdr *)buf;
 	hdr->version = 1;
 	hdr->last_page = pages - 1;
-	strncpy(buf + pagesize - 10, "SWAPSPACE2", 10);
+	memcpy(buf + pagesize - 10, "SWAPSPACE2", 10);
 
 	printf("Setting up swapspace version 1, size = %luKiB\n",
 	       (pages - 1) * pagesize / 1024);
diff -Naur ubase-20190312/mount.c ubase/mount.c
--- ubase-20190312/mount.c	2022-06-21 05:00:29.000000000 -0300
+++ ubase/mount.c	2022-11-07 16:04:18.802495386 -0300
@@ -15,8 +15,6 @@
 #include "text.h"
 #include "util.h"
 
-#define FSOPTS_MAXLEN 512
-
 struct {
 	const char *opt;
 	const char *notopt;
@@ -36,11 +34,12 @@
 	{ "mand",       "nomand",       MS_MANDLOCK    },
 	{ "relatime",   "norelatime",   MS_RELATIME    },
 	{ "bind",       NULL,           MS_BIND        },
+	{ "move",       NULL,           MS_MOVE        },
 	{ NULL,         NULL,           0              }
 };
 
 static unsigned long argflags = 0;
-static char fsopts[FSOPTS_MAXLEN] = "";
+static char *argopts = NULL;
 
 static char *
 findtype(const char *types, const char *t)
@@ -124,9 +123,9 @@
 		if (argflags & MS_REC)
 			eargv[i++] = "-R";
 
-		if (fsopts[0]) {
+		if (argopts) {
 			eargv[i++] = "-o";
-			eargv[i++] = fsopts;
+			eargv[i++] = argopts;
 		}
 		eargv[i++] = fsname;
 		eargv[i++] = dir;
@@ -191,7 +190,7 @@
 int
 main(int argc, char *argv[])
 {
-	char *types = NULL, data[FSOPTS_MAXLEN] = "", *resolvpath = NULL;
+	char *types = NULL, data[512] = "", *resolvpath = NULL;
 	char *files[] = { "/proc/mounts", "/etc/fstab", NULL };
 	const char *source, *target;
 	struct mntent *me = NULL;
@@ -213,8 +212,8 @@
 		aflag = 1;
 		break;
 	case 'o':
-		estrlcat(fsopts, EARGF(usage()), sizeof(fsopts));
-		parseopts(fsopts, &flags, data, sizeof(data));
+		argopts = EARGF(usage());
+		parseopts(argopts, &flags, data, sizeof(data));
 		break;
 	case 't':
 		types = EARGF(usage());
@@ -264,9 +263,10 @@
 					target = me->mnt_dir;
 					source = me->mnt_fsname;
 				}
-				if (!fsopts[0])
-					estrlcat(fsopts, me->mnt_opts, sizeof(fsopts));
-					parseopts(fsopts, &flags, data, sizeof(data));
+				if (!argopts) {
+					argopts = me->mnt_opts;
+					parseopts(argopts, &flags, data, sizeof(data));
+				}
 				if (!types)
 					types = me->mnt_type;
 				goto mountsingle;
@@ -299,13 +299,8 @@
 		if (hasmntopt(me, MNTOPT_NOAUTO) || mounted(me->mnt_dir))
 			continue;
 		flags = 0;
-		fsopts[0] = '\0';
-		if (strlcat(fsopts, me->mnt_opts, sizeof(fsopts)) >= sizeof(fsopts)) {
-			weprintf("%s: option string too long\n", me->mnt_dir);
-			status = 1;
-			continue;
-		}
-		parseopts(fsopts, &flags, data, sizeof(data));
+		argopts = me->mnt_opts;
+		parseopts(argopts, &flags, data, sizeof(data));
 		/* if -t types specified:
 		 * if non-match, skip
 		 * if match and prefixed with "no", skip */
diff -Naur ubase-20190312/mountpoint.c ubase/mountpoint.c
--- ubase-20190312/mountpoint.c	2022-06-21 05:00:29.000000000 -0300
+++ ubase/mountpoint.c	2022-11-07 16:04:18.802495386 -0300
@@ -1,6 +1,9 @@
 /* See LICENSE file for copyright and license details. */
 #include <sys/stat.h>
 #include <sys/types.h>
+#ifndef major
+#include <sys/sysmacros.h>
+#endif
 
 #include <mntent.h>
 #include <stdio.h>
diff -Naur ubase-20190312/passwd.c ubase/passwd.c
--- ubase-20190312/passwd.c	2022-06-21 05:00:29.000000000 -0300
+++ ubase/passwd.c	2022-11-07 16:04:18.802495386 -0300
@@ -160,7 +160,7 @@
 main(int argc, char *argv[])
 {
 	char *cryptpass1 = NULL, *cryptpass2 = NULL, *cryptpass3 = NULL;
-	char *inpass, *p, *prevhash = NULL, salt[sizeof(PW_CIPHER) + 16] = PW_CIPHER;
+	char *inpass, *p, *prevhash, salt[sizeof(PW_CIPHER) + 16] = PW_CIPHER;
 	struct passwd *pw;
 	struct spwd *spw = NULL;
 	FILE *fp = NULL;
@@ -196,52 +196,42 @@
 			else
 				eprintf("who are you?\n");
 		}
+		prevhash = spw->sp_pwdp;
+	} else {
+		prevhash = pw->pw_passwd;
 	}
 
 	/* Flush pending input */
 	ioctl(0, TCFLSH, (void *)0);
 
-	if (getuid() == 0) {
-		goto newpass;
-	} else {
-		if (pw->pw_passwd[0] == '!' ||
-		    pw->pw_passwd[0] == '*')
+	if (getuid() != 0 && prevhash[0] != '\0') {
+		if (prevhash[0] == '!' || prevhash[0] == '*')
 			eprintf("denied\n");
-		if (pw->pw_passwd[0] == '\0') {
-			goto newpass;
-		}
-		if (pw->pw_passwd[0] == 'x' &&
-		    pw->pw_passwd[1] == '\0')
-			prevhash = spw->sp_pwdp;
-		else
-			prevhash = pw->pw_passwd;
+		printf("Changing password for %s\n", pw->pw_name);
+		inpass = getpass("Old password: ");
+		if (!inpass)
+			eprintf("getpass:");
+		if (inpass[0] == '\0')
+			eprintf("no password supplied\n");
+		p = crypt(inpass, prevhash);
+		if (!p)
+			eprintf("crypt:");
+		cryptpass1 = estrdup(p);
+		if (strcmp(cryptpass1, prevhash) != 0)
+			eprintf("incorrect password\n");
 	}
 
-	printf("Changing password for %s\n", pw->pw_name);
-	inpass = getpass("Old password: ");
-	if (!inpass)
-		eprintf("getpass:");
-	if (inpass[0] == '\0')
-		eprintf("no password supplied\n");
-	p = crypt(inpass, prevhash);
-	if (!p)
-		eprintf("crypt:");
-	cryptpass1 = estrdup(p);
-	if (strcmp(cryptpass1, prevhash) != 0)
-		eprintf("incorrect password\n");
-
-newpass:
 	inpass = getpass("Enter new password: ");
 	if (!inpass)
 		eprintf("getpass:");
 	if (inpass[0] == '\0')
 		eprintf("no password supplied\n");
 
-	if(prevhash) {
+	if (cryptpass1) {
 		p = crypt(inpass, prevhash);
 		if (!p)
 			eprintf("crypt:");
-		if (cryptpass1 && strcmp(cryptpass1, p) == 0)
+		if (strcmp(cryptpass1, p) == 0)
 			eprintf("password left unchanged\n");
 	}
 	gensalt(salt + strlen(salt));
diff -Naur ubase-20190312/stat.c ubase/stat.c
--- ubase-20190312/stat.c	2022-06-21 05:00:29.000000000 -0300
+++ ubase/stat.c	2022-11-07 16:04:18.812495387 -0300
@@ -1,6 +1,9 @@
 /* See LICENSE file for copyright and license details. */
 #include <sys/stat.h>
 #include <sys/types.h>
+#ifndef major
+#include <sys/sysmacros.h>
+#endif
 
 #include <inttypes.h>
 #include <stdio.h>
diff -Naur ubase-20190312/stty.c ubase/stty.c
--- ubase-20190312/stty.c	1969-12-31 21:00:00.000000000 -0300
+++ ubase/stty.c	2022-11-07 16:04:18.812495387 -0300
@@ -0,0 +1,830 @@
+/* See LICENSE file for copyright and license details. */
+#include <sys/ioctl.h>
+#include <sys/ttydefaults.h>
+
+#include <ctype.h>
+#include <errno.h>
+#include <limits.h>
+#include <stdarg.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <termios.h>
+#include <unistd.h>
+
+#include "util.h"
+
+/*
+ * Petty POSIX violations:
+ * 
+ * -  XBD 12.2 is not honoured precisely. This is for
+ *    convenience and compatibility with other implementations.
+ */
+
+#define CC_MAX 255
+
+static int output_size_requested = 0;
+static int output_speed_requested = 0;
+static int drain_requested = 1;
+
+static void sane(int, struct termios *);
+static void setwinsize(long, long);
+static void ispeed(char *, struct termios *);
+static void ospeed(char *, struct termios *);
+
+static void
+raw(int unset, struct termios *m)
+{
+	if (!unset) {
+		m->c_iflag = 0;
+#ifdef XCASE
+		m->c_lflag &= ~XCASE;
+#endif
+		m->c_cc[VMIN] = 1;
+		m->c_cc[VTIME] = 0;
+	} else {
+		m->c_iflag |= BRKINT | IGNPAR | ISTRIP | ICRNL | IXON;
+	}
+}
+
+static void
+evenp(int unset, struct termios *m)
+{
+	m->c_oflag &= ~CSIZE;
+	m->c_oflag &= ~(unset ? PARENB : PARODD);
+	m->c_oflag |= unset ? CS8 : (CS7 | PARENB);
+}
+
+
+static void
+dec(int unset, struct termios *m)
+{
+	m->c_cc[VINTR] = CINTR;
+	m->c_cc[VKILL] = CKILL;
+	m->c_cc[VERASE] = CERASE;
+	(void) unset;
+}
+
+static void
+ek(int unset, struct termios *m)
+{
+	m->c_cc[VKILL] = CKILL;
+	m->c_cc[VERASE] = CERASE;
+	(void) unset;
+}
+
+static void
+nl(int unset, struct termios *m)
+{
+	if (unset) {
+		m->c_iflag &= ~(INLCR | IGNCR);
+		m->c_oflag &= ~(OCRNL | ONLRET);
+	}
+}
+
+static void
+oddp(int unset, struct termios *m)
+{
+	m->c_oflag &= ~CSIZE;
+	m->c_oflag &= ~(unset ? PARENB : 0);
+	m->c_oflag |= unset ? CS8 : (CS7 | PARODD | PARENB);
+}
+
+static void drain(int unset, struct termios *m)  { drain_requested = !unset; (void) m; }
+static void cooked(int unset, struct termios *m) { raw(!unset, m); }
+static void pass8(int unset, struct termios *m)  { m->c_cflag &= ~CSIZE, m->c_cflag |= unset ? CS7 : CS8; }
+static void size(int unset, struct termios *m)   { output_size_requested = 1; (void) m; (void) unset; }
+static void speed(int unset, struct termios *m)  { output_speed_requested = 1; (void) m; (void) unset; }
+static void tabs(int unset, struct termios *m)   { m->c_oflag &= ~TABDLY, m->c_oflag |= unset ? TAB3 : TAB0; }
+static void cols(char *arg, struct termios *m)   { setwinsize(-1, estrtonum(arg, 0, USHRT_MAX)); (void) m; }
+static void min(char *arg, struct termios *m)    { m->c_cc[VMIN] = estrtonum(arg, 0, CC_MAX); }
+static void rows(char *arg, struct termios *m)   { setwinsize(estrtonum(arg, 0, USHRT_MAX), -1); (void) m; }
+static void stime(char *arg, struct termios *m)  { m->c_cc[VTIME] = estrtonum(arg, 0, CC_MAX); }
+
+enum type { CTRL, IN, OUT, LOCAL, COMB, SPEC };
+enum {
+	BOOL = 1,
+	DUP = 2,
+	SANE = 4,
+	INSANE = 8,
+	CBREAK = 16,
+	DECCTLQ = 32,
+	LCASE = 64,
+	PASS8 = 128,
+	LITOUT = 256,
+	CRT = 1024,
+	DEC = 2048,
+	NL = 4096,
+	COOKED = 8192,
+	DEF = 16384
+};
+
+struct mode {
+	const char *op;
+	enum type type;
+	tcflag_t set;
+	tcflag_t clear;
+	void (*fun)(int, struct termios *);
+	int flags;
+};
+
+struct key {
+	const char *op;
+	size_t index;
+	cc_t sanevalue;
+};
+
+struct intvalued {
+	const char *op;
+	void (*fun)(char *, struct termios *);
+};
+
+struct speed {
+	const char *str;
+	speed_t speed;
+};
+
+struct line {
+	const char *str;
+	unsigned char value;
+};
+
+static const struct mode modes[] = {
+	{"clocal",   CTRL,  CLOCAL,  0,       0,      BOOL},
+#ifdef CMSPAR
+	{"cmspar",   CTRL,  CMSPAR,  0,       0,      BOOL},
+#endif
+	{"cread",    CTRL,  CREAD,   0,       0,      BOOL | SANE},
+	{"crtscts",  CTRL,  CRTSCTS, 0,       0,      BOOL},
+	{"cs5",      CTRL,  CS5,     CSIZE,   0,      0},
+	{"cs6",      CTRL,  CS6,     CSIZE,   0,      0},
+	{"cs7",      CTRL,  CS7,     CSIZE,   0,      0},
+	{"cs8",      CTRL,  CS8,     CSIZE,   0,      DEF},
+	{"cstopb",   CTRL,  CSTOPB,  0,       0,      BOOL},
+	{"hup",      CTRL,  HUPCL,   0,       0,      BOOL | DUP},
+	{"hupcl",    CTRL,  HUPCL,   0,       0,      BOOL | DEF},
+	{"parenb",   CTRL,  PARENB,  0,       0,      BOOL | PASS8 | LITOUT},
+	{"parodd",   CTRL,  PARODD,  0,       0,      BOOL},
+
+	{"brkint",   IN,    BRKINT,  0,       0,      BOOL | SANE},
+	{"icrnl",    IN,    ICRNL,   0,       0,      BOOL | SANE | NL},
+	{"ignbrk",   IN,    IGNBRK,  0,       0,      BOOL | INSANE},
+	{"igncr",    IN,    IGNCR,   0,       0,      BOOL | INSANE},
+	{"ignpar",   IN,    IGNPAR,  0,       0,      BOOL},
+	{"imaxbel",  IN,    IMAXBEL, 0,       0,      BOOL | SANE},
+	{"inlcr",    IN,    INLCR,   0,       0,      BOOL | INSANE},
+	{"inpck",    IN,    INPCK,   0,       0,      BOOL},
+	{"istrip",   IN,    ISTRIP,  0,       0,      BOOL | PASS8 | LITOUT},
+	{"iuclc",    IN,    IUCLC,   0,       0,      BOOL | INSANE | LCASE},
+	{"iutf8",    IN,    IUTF8,   0,       0,      BOOL | SANE},
+	{"ixany",    IN,    IXANY,   0,       0,      BOOL | INSANE | DECCTLQ},
+	{"ixoff",    IN,    IXOFF,   0,       0,      BOOL | INSANE},
+	{"ixon",     IN,    IXON,    0,       0,      BOOL | DEF},
+	{"parmrk",   IN,    PARMRK,  0,       0,      BOOL},
+	{"tandem",   IN,    IXOFF,   0,       0,      BOOL | DUP},
+
+	{"bs0",      OUT,   BS0,     BSDLY,   0,      SANE},
+	{"bs1",      OUT,   BS1,     BSDLY,   0,      INSANE},
+	{"cr0",      OUT,   CR0,     CRDLY,   0,      SANE},
+	{"cr1",      OUT,   CR1,     CRDLY,   0,      INSANE},
+	{"cr2",      OUT,   CR2,     CRDLY,   0,      INSANE},
+	{"cr3",      OUT,   CR3,     CRDLY,   0,      INSANE},
+	{"ff0",      OUT,   FF0,     FFDLY,   0,      SANE},
+	{"ff1",      OUT,   FF1,     FFDLY,   0,      INSANE},
+	{"nl0",      OUT,   NL0,     NLDLY,   0,      SANE},
+	{"nl1",      OUT,   NL1,     NLDLY,   0,      INSANE},
+	{"ocrnl",    OUT,   OCRNL,   0,       0,      BOOL | INSANE},
+	{"ofdel",    OUT,   OFDEL,   0,       0,      BOOL | INSANE},
+	{"ofill",    OUT,   OFILL,   0,       0,      BOOL | INSANE},
+	{"olcuc",    OUT,   OLCUC,   0,       0,      BOOL | INSANE | LCASE},
+	{"onlcr",    OUT,   ONLCR,   0,       0,      BOOL | SANE | NL},
+	{"onlret",   OUT,   ONLRET,  0,       0,      BOOL | INSANE},
+	{"onocr",    OUT,   ONOCR,   0,       0,      BOOL | INSANE},
+	{"opost",    OUT,   OPOST,   0,       0,      BOOL | SANE | LITOUT | COOKED},
+	{"tab0",     OUT,   TAB0,    TABDLY,  0,      SANE},
+	{"tab1",     OUT,   TAB1,    TABDLY,  0,      INSANE},
+	{"tab2",     OUT,   TAB2,    TABDLY,  0,      INSANE},
+	{"tab3",     OUT,   TAB3,    TABDLY,  0,      INSANE},
+	{"vt0",      OUT,   VT0,     VTDLY,   0,      SANE},
+	{"vt1",      OUT,   VT1,     VTDLY,   0,      INSANE},
+
+	{"crterase", LOCAL, ECHOE,   0,       0,      BOOL | DUP},
+	{"crtkill",  LOCAL, ECHOKE,  0,       0,      BOOL | DUP},
+	{"ctlecho",  LOCAL, ECHOCTL, 0,       0,      BOOL | DUP},
+	{"echo",     LOCAL, ECHO,    0,       0,      BOOL | SANE},
+	{"echoctl",  LOCAL, ECHOCTL, 0,       0,      BOOL | SANE | CRT | DEC},
+	{"echoe",    LOCAL, ECHOE,   0,       0,      BOOL | SANE | CRT | DEC},
+	{"echok",    LOCAL, ECHOK,   0,       0,      BOOL | SANE},
+	{"echoke",   LOCAL, ECHOKE,  0,       0,      BOOL | SANE | CRT | DEC},
+	{"echonl",   LOCAL, ECHONL,  0,       0,      BOOL | INSANE},
+	{"echoprt",  LOCAL, ECHOPRT, 0,       0,      BOOL | INSANE},
+	{"extproc",  LOCAL, EXTPROC, 0,       0,      BOOL | INSANE},
+	{"flusho",   LOCAL, FLUSHO,  0,       0,      BOOL | INSANE},
+	{"icanon",   LOCAL, ICANON,  0,       0,      BOOL | SANE | CBREAK | COOKED},
+	{"iexten",   LOCAL, IEXTEN,  0,       0,      BOOL | SANE},
+	{"isig",     LOCAL, ISIG,    0,       0,      BOOL | SANE | COOKED},
+	{"noflsh",   LOCAL, NOFLSH,  0,       0,      BOOL | INSANE},
+	{"prterase", LOCAL, ECHOPRT, 0,       0,      BOOL | DUP},
+	{"tostop",   LOCAL, TOSTOP,  0,       0,      BOOL | INSANE},
+#ifdef XCASE
+	{"xcase",    LOCAL, XCASE,   0,       0,      BOOL | INSANE | LCASE},
+#endif
+
+	{"cbreak",   COMB,  0,       CBREAK,  0,      BOOL | DUP},
+	{"cooked",   COMB,  COOKED,  0,       cooked, BOOL | DUP},
+	{"crt",      COMB,  CRT,     0,       0,      DUP},
+	{"dec",      COMB,  DEC,     DECCTLQ, dec,    DUP},
+	{"decctlq",  COMB,  0,       DECCTLQ, 0,      BOOL | DUP},
+	{"ek",       COMB,  0,       0,       ek,     DUP},
+	{"evenp",    COMB,  0,       0,       evenp,  BOOL | DUP},
+	{"LCASE",    COMB,  LCASE,   0,       0,      BOOL | DUP},
+	{"lcase",    COMB,  LCASE,   0,       0,      BOOL | DUP},
+	{"litout",   COMB,  0,       LITOUT,  pass8,  BOOL | DUP},
+	{"nl",       COMB,  0,       NL,      nl,     BOOL | DUP},
+	{"oddp",     COMB,  0,       0,       oddp,   BOOL | DUP},
+	{"parity",   COMB,  0,       0,       evenp,  BOOL | DUP},
+	{"pass8",    COMB,  0,       PASS8,   pass8,  BOOL | DUP},
+	{"raw",      COMB,  0,       COOKED,  raw,    BOOL | DUP},
+	{"sane",     COMB,  SANE,    INSANE,  sane,   DUP},
+	{"tabs",     COMB,  0,       0,       tabs,   BOOL | DUP},
+
+	{"size",     SPEC,  0,       0,       size,   DUP},
+	{"speed",    SPEC,  0,       0,       speed,  DUP},
+	{"drain",    SPEC,  0,       0,       drain,  BOOL | DUP},
+
+	{0, 0, 0, 0, 0, 0}
+};
+
+static const struct key keys[] = {
+	{"discard", VDISCARD, CDISCARD},
+	{"eof",     VEOF,     CEOF},
+	{"eol",     VEOL,     CEOL},
+	{"eol2",    VEOL2,    _POSIX_VDISABLE},
+	{"erase",   VERASE,   CERASE},
+	{"intr",    VINTR,    CINTR},
+	{"kill",    VKILL,    CKILL},
+	{"lnext",   VLNEXT,   CLNEXT},
+	{"quit",    VQUIT,    CQUIT},
+	{"rprnt",   VREPRINT, CRPRNT},
+	{"start",   VSTART,   CSTART},
+	{"stop",    VSTOP,    CSTOP},
+	{"susp",    VSUSP,    CSUSP},
+	{"swtch",   VSWTC,    _POSIX_VDISABLE},
+	{"werase",  VWERASE,  CWERASE},
+	{0, 0, 0}
+};
+
+static const struct intvalued ints[] = {
+	{"cols",    cols},
+	{"columns", cols},
+	{"min",     min},
+	{"rows",    rows},
+	{"time",    stime},
+	{"ispeed",  ispeed},
+	{"ospeed",  ospeed},
+	{0, 0}
+};
+
+#define B(baud) {#baud, B##baud}
+static const struct speed speeds[] = {
+	B(0),       B(50),      B(75),      B(110),     B(134),     B(150),     B(200),     B(300),
+	B(600),     B(1200),    B(1800),    B(2400),    B(4800),    B(9600),    B(19200),   B(38400),
+	B(57600),   B(115200),  B(230400),  B(460800),  B(500000),  B(576000),  B(921600),  B(1000000),
+	B(1152000), B(1500000), B(2000000), B(2500000), B(3000000), B(3500000), B(4000000),
+	{"134.5", B134},
+	{"exta",  B19200},
+	{"extb",  B38400},
+	{0, 0}
+};
+#undef B
+
+static const struct line lines[] = {
+	{"tty",      N_TTY},
+	{"slip",     N_SLIP},
+	{"mouse",    N_MOUSE},
+	{"ppp",      N_PPP},
+	{"strip",    N_STRIP},
+	{"ax25",     N_AX25},
+	{"x25",      N_X25},
+	{"6pack",    N_6PACK},
+	{"masc",     N_MASC},
+	{"r3964",    N_R3964},
+	{"profibus", N_PROFIBUS_FDL},
+	{"irda",     N_IRDA},
+	{"smsblock", N_SMSBLOCK},
+	{"hdlc",     N_HDLC},
+	{"syncppp",  N_SYNC_PPP},
+	{"hci",      N_HCI},
+	{0, 0}
+};
+
+static void
+sane(int unset, struct termios *m)
+{
+	const struct key *op = keys;
+	for (; op->op; op++)
+		m->c_cc[op->index] = op->sanevalue;
+	m->c_cc[VMIN] = 1;
+	m->c_cc[VTIME] = 0;
+	(void) unset;
+}
+
+static int
+isxnumber(char* str)
+{
+	if (!*str)
+		return 0;
+	for (; *str; str++)
+		if (!isxdigit(*str))
+			return 0;
+	return 1;
+}
+
+static void
+decodehex(char *dest, char* src)
+{
+	while (*src) {
+		char hi = *src++;
+		char lo = *src++;
+		hi = (hi & 15) + 9 * !isdigit(hi);
+		lo = (lo & 15) + 9 * !isdigit(lo);
+		*dest++ = (hi << 4) | lo;
+	}
+}
+
+static void
+setwinsize(long y, long x)
+{
+	struct winsize winsize;
+	if (ioctl(STDIN_FILENO, TIOCGWINSZ, &winsize))
+		eprintf("TIOCGWINSZ <stdin>:");
+	if (y >= 0)
+		winsize.ws_row = y;
+	if (x >= 0)
+		winsize.ws_col = x;
+	if (ioctl(STDIN_FILENO, TIOCSWINSZ, &winsize))
+		eprintf("TIOCSWINSZ <stdin>:");
+}
+
+static void
+setoperand_mode(int unset, const struct mode *op, struct termios *mode)
+{
+	tcflag_t *bitsp = 0;
+
+	switch (op->type) {
+	case CTRL:  bitsp = &mode->c_cflag; break;
+	case IN:    bitsp = &mode->c_iflag; break;
+	case OUT:   bitsp = &mode->c_oflag; break;
+	case LOCAL: bitsp = &mode->c_lflag; break;
+	case SPEC:  break;
+	default:    abort();
+	}
+
+	if (bitsp) {
+		*bitsp &= ~op->clear;
+		if (!unset)
+			*bitsp |= op->set;
+		else
+			*bitsp &= ~op->set;
+	}
+
+	if (op->fun)
+		op->fun(unset, mode);
+}
+
+static int
+parseoperand_mode(char *arg, struct termios *mode)
+{
+	const struct mode *op = modes;
+	const struct mode *op_proper;
+	int unset = *arg == '-';
+	int flags_set, flags_unset;
+
+	arg += unset;
+	while (op->op && strcmp(arg, op->op))
+		op++;
+	if (!op->op)
+		return -1;
+	if (unset && !(op->flags & BOOL))
+		return -1;
+
+	switch (op->type) {
+	case CTRL:
+	case IN:
+	case OUT:
+	case LOCAL:
+	case SPEC:
+		setoperand_mode(unset, op, mode);
+		return 0;
+	case COMB:
+		break;
+	default:
+		abort();
+	}
+
+	flags_set = (int)(op->set);
+	flags_unset = (int)(op->clear);
+	op_proper = op;
+
+	if (flags_unset || flags_set) {
+		for (op = modes; op->op; op++) {
+			if (op->type == COMB)
+				continue;
+			if (flags_unset && (op->flags & flags_unset))
+				setoperand_mode(!unset, op, mode);
+			if (flags_set && (op->flags & flags_set))
+				setoperand_mode(unset, op, mode);
+		}
+	}
+
+	if (op_proper->fun)
+		op_proper->fun(unset, mode);
+
+	return 0;
+}
+
+static long long
+estrtonum_anyradix(const char *numstr, long long minval, long long maxval)
+{
+	long long ll = 0;
+	char *ep;
+	errno = 0;
+	ll = strtoll(numstr, &ep, 0);
+	if (numstr == ep || *ep != '\0')
+		eprintf("strtoll %s: invalid\n", numstr);
+	else if ((ll == LLONG_MIN && errno == ERANGE) || ll < minval)
+		eprintf("strtoll %s: too small\n", numstr);
+	else if ((ll == LLONG_MAX && errno == ERANGE) || ll > maxval)
+		eprintf("strtoll %s: too large\n", numstr);
+	return ll;
+}
+
+static int
+parseoperand_key(char *arg0, char *arg1, struct termios *mode)
+{
+	const struct key *op = keys;
+	cc_t value;
+
+	while (op->op && strcmp(arg0, op->op))
+		op++;
+	if (!op->op)
+		return -1;
+
+	if (!arg1)
+		eprintf("missing argument for operand: %s\n", arg0);
+
+	if (!strcmp(arg1, "^-") || !strcmp(arg1, "undef"))
+		value = _POSIX_VDISABLE;
+	else if (!strcmp(arg1, "^?"))
+		value = 127;
+	else if (!arg1[0] || !arg1[1])
+		value = arg1[0];
+	else if (arg1[0] == '^')
+		value = (cc_t)(arg1[1]) & ~0x60;
+	else
+		value = estrtonum_anyradix(arg1, 0, CC_MAX);
+
+	mode->c_cc[op->index] = value;
+	return 0;
+}
+
+static int
+parseoperand_int(char *arg0, char *arg1, struct termios *mode)
+{
+	const struct intvalued *op = ints;
+
+	while (op->op && strcmp(arg0, op->op))
+		op++;
+	if (!op->op)
+		return -1;
+
+	if (!arg1)
+		eprintf("missing argument for operand: %s\n", arg0);
+
+	op->fun(arg1, mode);
+	return 0;
+}
+
+static const char *
+baudtostr(speed_t baud)
+{
+	const struct speed *speed = speeds;
+	while (speed->str && speed->speed != baud)
+		speed++;
+	return speed->str ? speed->str : "0";
+}
+
+static const char*
+linetostr(unsigned value)
+{
+	const struct line *ln = lines;
+	while (ln->str && ln->value != value)
+		ln++;
+	return ln->str;
+}
+
+static void
+line(char *arg, struct termios *m)
+{
+	const struct line *ln = lines;
+	while (ln->str && strcmp(ln->str, arg))
+		ln++;
+	if (ln->str)
+		m->c_line = ln->value;
+	else
+		m->c_line = estrtonum(arg, 0, 255);
+}
+
+static int
+parsespeed(char *arg, struct speed *ret)
+{
+	const struct speed *speed = speeds;
+	while (speed->str && strcmp(arg, speed->str))
+		speed++;
+	if (!speed->str)
+		return -1;
+	*ret = *speed;
+	return 0;
+}
+
+static void
+eparsespeed(char *arg, struct speed *ret)
+{
+	if (parsespeed(arg, ret))
+		eprintf("invalid speed parameter: %s\n", arg);
+}
+
+static void
+ispeed(char *arg, struct termios *m)
+{
+	struct speed speed;
+	eparsespeed(arg, &speed);
+	if (cfsetispeed(m, speed.speed))
+		eprintf("cfsetispeed %s:", speed.str);
+}
+
+static void
+ospeed(char *arg, struct termios *m)
+{
+	struct speed speed;
+	eparsespeed(arg, &speed);
+	if (cfsetospeed(m, speed.speed))
+		eprintf("cfsetospeed %s:", speed.str);
+}
+
+static void
+printtoken(const char *fmt, ...)
+{
+	static size_t width = 0;
+	static size_t pos = 0;
+	static char buf[BUFSIZ];
+	va_list ap;
+	int len;
+
+	if (!width) {
+		struct winsize winsize;
+		if (!ioctl(STDOUT_FILENO, TIOCGWINSZ, &winsize))
+			if (winsize.ws_col > 40)
+				width = winsize.ws_col;
+		if (!width)
+			width = SIZE_MAX;
+	}
+
+	if (!strcmp(fmt, "\n")) {
+		if (pos)
+			printf("\n");
+		pos = 0;
+		return;
+	}
+
+	va_start(ap, fmt);
+	len = vsnprintf(buf, sizeof(buf), fmt, ap);
+	va_end(ap);
+	if (len < 0 || (size_t)len >= sizeof(buf))
+		eprintf("vsnprintf:");
+
+	if (pos + !!pos + len > width) {
+		printf("\n");
+		pos = 0;
+	} else if (pos) {
+		printf(" ");
+		pos++;
+	}
+
+	printf("%s", buf);
+	pos += len;
+}
+
+static const char*
+keytostr(cc_t key)
+{
+	static char buf[5];
+	int r;
+	if (key == _POSIX_VDISABLE)
+		return "undef";
+	else if (key < (cc_t)' ')
+		r = snprintf(buf, sizeof(buf), "^%c", key + '@');
+	else if (key < 127)
+		r = snprintf(buf, sizeof(buf), "%c", key);
+	else if (key == 127)
+		r = snprintf(buf, sizeof(buf), "^?");
+	else if (key < 128 + ' ')
+		r = snprintf(buf, sizeof(buf), "M-^%c", key - 128 + '@');
+	else if (key == 128 + 127)
+		r = snprintf(buf, sizeof(buf), "M-^?");
+	else
+		r = snprintf(buf, sizeof(buf), "M-%c", key - 128);
+	if (r < 0 || (size_t)r >= sizeof(buf))
+		eprintf("snprintf:");
+	return buf;
+}
+
+static int
+isdefault(int flags)
+{
+	if (flags & (SANE | INSANE))
+		return (flags & SANE) || !(flags & INSANE);
+	return flags & DEF;
+}
+
+static void
+displaysettings(struct termios *m, int all)
+{
+	const struct key *kbd = keys;
+	const struct mode *mod = modes;
+	struct winsize winsize;
+	speed_t in, out;
+	tcflag_t *bitsp, mask;
+	const char *linestr;
+
+	in = cfgetispeed(m);
+	out = cfgetospeed(m);
+	if (!in || in == out) {
+		if (all || out != B38400)
+			printtoken("speed %s baud;", baudtostr(out));
+	} else {
+		printtoken("ispeed %s baud;", baudtostr(in));
+		printtoken("ospeed %s baud;", baudtostr(out));
+	}
+
+	if (all) {
+		if (ioctl(STDIN_FILENO, TIOCGWINSZ, &winsize))
+			eprintf("TIOCGWINSZ <stdin>:");
+		printtoken("rows %u;", winsize.ws_row);
+		printtoken("columns %u;", winsize.ws_col);
+	}
+	printtoken("\n");
+
+	if (all || m->c_line != 0) {
+		linestr = linetostr(m->c_line);
+		if (linestr)
+			printtoken("line = %s;", linestr);
+		else
+			printtoken("line = %u;", (unsigned)(m->c_line));
+	}
+	if (all || (m->c_cc[VMIN] != 1 && !(m->c_lflag & ICANON)))
+		printtoken("min = %u;", (unsigned)(m->c_cc[VMIN]));
+	if (all || (m->c_cc[VTIME] != 0 && !(m->c_lflag & ICANON)))
+		printtoken("time = %u;", (unsigned)(m->c_cc[VTIME]));
+	printtoken("\n");
+
+	for (; kbd->op; kbd++)
+		if (all || m->c_cc[kbd->index] != kbd->sanevalue)
+			printtoken("%s = %s;", kbd->op, keytostr(m->c_cc[kbd->index]));
+	printtoken("\n");
+
+	for (; mod->op; mod++) {
+		switch (mod->type) {
+		case CTRL:  bitsp = &m->c_cflag; break;
+		case IN:    bitsp = &m->c_iflag; break;
+		case OUT:   bitsp = &m->c_oflag; break;
+		case LOCAL: bitsp = &m->c_lflag; break;
+		default:    bitsp = 0;           break;
+		}
+		if (!bitsp || (mod->flags & DUP))
+			continue;
+		mask = mod->clear ? mod->clear : mod->set;
+		if ((*bitsp & mask) == mod->set) {
+			if (all || !isdefault(mod->flags))
+				printtoken("%s", mod->op);
+		}
+		else if (mod->flags & BOOL) {
+			if (all || isdefault(mod->flags))
+				printtoken("-%s", mod->op);
+		}
+	}
+	printtoken("\n");
+}
+
+static void
+usage(void)
+{
+	eprintf("usage: %s [-a | -g] [operand ...]\n", argv0);
+}
+
+int
+main(int argc, char *argv[])
+{
+	struct termios mode;
+	struct termios mode2;
+	struct winsize winsize;
+	struct speed speed;
+	int aflag = 0;
+	int gflag = 0;
+	size_t n;
+	unsigned char *buf;
+	char *p;
+	speed_t in, out;
+
+	for (argv0 = *argv++, argc--; argc; argv++, argc--) {
+		if (!strcmp(*argv, "-ag") || !strcmp(*argv, "-ga")) {
+			aflag = gflag = 1;
+		} else if (!strcmp(*argv, "-g")) {
+			gflag = 1;
+		} else if (!strcmp(*argv, "-a")) {
+			aflag = 1;
+		} else if (!strcmp(*argv, "--")) {
+			argv++, argc--;
+			break;
+		} else {
+			break;
+		}
+	}
+
+	if (aflag && gflag)
+		usage();
+
+	memset(&mode, 0, sizeof(mode));
+	if (tcgetattr(STDIN_FILENO, &mode))
+		eprintf("tcgetattr <stdin>:");
+	memcpy(&mode2, &mode, sizeof(mode));
+
+	for (; *argv; argv++) {
+		if (**argv == '=') {
+			p = *argv + 1;
+			if (strlen(p) != sizeof(mode) * 2 || !isxnumber(p))
+				goto invalid;
+			decodehex((char *)&mode, p);
+		} else if (!parseoperand_mode(*argv, &mode)) {
+			/* do nothing. */
+		} else if (!parseoperand_key(argv[0], argv[1], &mode)) {
+			argv++;
+		} else if (!parseoperand_int(argv[0], argv[1], &mode)) {
+			argv++;
+		} else if (!strcmp(argv[0], "line")) {
+			if (!argv[1])
+				eprintf("missing argument for operand: %s\n", argv[0]);
+			line(argv[1], &mode);
+			argv++;
+		} else if (!parsespeed(*argv, &speed)) {
+			if (cfsetispeed(&mode, speed.speed))
+				eprintf("cfsetispeed %s:", speed.str);
+			if (cfsetospeed(&mode, speed.speed))
+				eprintf("cfsetospeed %s:", speed.str);
+		} else {
+			goto invalid;
+		}
+	}
+
+	if (memcmp(&mode, &mode2, sizeof(mode))) {
+		memset(&mode2, 0, sizeof(mode2));
+		if (tcsetattr(STDIN_FILENO, drain_requested ? TCSADRAIN : TCSANOW, &mode))
+			eprintf("tcsetattr <stdin>:");
+		if (tcgetattr(STDIN_FILENO, &mode2))
+			eprintf("tcgetattr <stdin>:");
+		if (memcmp(&mode, &mode2, sizeof(mode)))
+			eprintf("tcsetattr <stdin>: unable to apply all operands\n");
+	}
+
+	if (gflag) {
+		buf = (unsigned char *)&mode;
+		printf("=");
+		for (n = sizeof(mode); n--; buf++)
+			printf("%02x", *buf);
+		printf("\n");
+	}
+
+	if (output_size_requested) {
+		if (ioctl(STDIN_FILENO, TIOCGWINSZ, &winsize))
+			eprintf("TIOCGWINSZ <stdin>:");
+		printf("%u %u\n", winsize.ws_row, winsize.ws_col);
+	}
+
+	if (output_speed_requested) {
+		in = cfgetispeed(&mode);
+		out = cfgetospeed(&mode);
+		if (!in || in == out)
+			printf("%s\n", baudtostr(out));
+		else
+			printf("%s %s\n", baudtostr(in), baudtostr(out));
+	}
+
+	if ((aflag || !argc) && !gflag)
+		displaysettings(&mode, aflag);
+
+	return 0;
+
+invalid:
+	eprintf("invalid operand: %s\n", *argv);
+}
diff -Naur ubase-20190312/vmstat.c ubase/vmstat.c
--- ubase-20190312/vmstat.c	1969-12-31 21:00:00.000000000 -0300
+++ ubase/vmstat.c	2022-11-07 16:04:18.812495387 -0300
@@ -0,0 +1,322 @@
+/* See LICENSE file for copyright and license details. */
+#include <ctype.h>
+#include <errno.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+
+#include "util.h"
+
+struct vm {
+	intmax_t cpu_user;
+	intmax_t cpu_nice;
+	intmax_t cpu_system;
+	intmax_t cpu_idle;
+	intmax_t cpu_iowait;
+	intmax_t cpu_irq;
+	intmax_t cpu_softirq;
+	intmax_t cpu_steal;
+	intmax_t cpu_guest;
+	intmax_t cpu_guest_nice;
+	intmax_t cpu_unknown;
+	intmax_t page_in;
+	intmax_t page_out;
+	intmax_t swap_in;
+	intmax_t swap_out;
+	intmax_t intr;
+	intmax_t ctxt_switches;
+	intmax_t processes;
+	intmax_t proc_running;
+	intmax_t proc_blocked;
+	intmax_t mem_free;
+	intmax_t buffers;
+	intmax_t cached;
+	intmax_t active;
+	intmax_t inactive;
+	intmax_t swap_total;
+	intmax_t swap_free;
+	intmax_t sreclaimable;
+};
+
+static intmax_t kb_per_page;
+static intmax_t hz;
+
+static int
+stpstarts(char *str, const char *head, char **end)
+{
+	size_t n = strlen(head);
+	if (!strncmp(str, head, n)) {
+		*end = &str[n];
+		return 1;
+	}
+	return 0;
+}
+
+static intmax_t
+read_ints(const char *s, intmax_t *arr, size_t n)
+{
+	const char *beginning = s;
+	intmax_t rest = 0;
+	size_t tmp;
+	int negative;
+
+	memset(arr, 0, n * sizeof(*arr));
+
+	for (; n--; arr++) {
+		while (*s && !isdigit(*s))
+			s++;
+		negative = (s != beginning && s[-1] == '-');
+		while (isdigit(*s))
+			*arr = *arr * 10 + (*s++ - '0');
+		if (negative)
+			*arr = -*arr;
+	}
+
+	for (; *s; rest += tmp) {
+		tmp = 0;
+		while (*s && !isdigit(*s))
+			s++;
+		negative = (s != beginning && s[-1] == '-');
+		while (isdigit(*s))
+			tmp = tmp * 10 + (*s++ - '0');
+		if (negative)
+			tmp = -tmp;
+	}
+
+	return rest;
+}
+
+static void
+load_vm(struct vm *s)
+{
+	static intmax_t debt = 0;
+
+	int have_page = 0, have_swap = 0;
+	char *line = NULL, *p;
+	size_t size = 0;
+	ssize_t len;
+	FILE *fp;
+
+	memset(s, 0, sizeof(*s));
+
+	fp = fopen("/proc/stat", "r");
+	if (!fp)
+		eprintf("fopen /proc/stat:");
+	while ((len = getline(&line, &size, fp)) >= 0) {
+		if (stpstarts(line, "cpu ", &p)) {
+			s->cpu_unknown = read_ints(p, &s->cpu_user, 10);
+		} else if (stpstarts(line, "page ", &p)) {
+			read_ints(p, &s->page_in, 2);
+			have_page = 1;
+		} else if (stpstarts(line, "swap ", &p)) {
+			read_ints(p, &s->swap_in, 2);
+			have_swap = 1;
+		} else if (stpstarts(line, "intr ", &p)) {
+			read_ints(p, &s->intr, 1);
+		} else if (stpstarts(line, "ctxt ", &p)) {
+			read_ints(p, &s->ctxt_switches, 1);
+		} else if (stpstarts(line, "processes ", &p)) {
+			read_ints(p, &s->processes, 1);
+		} else if (stpstarts(line, "proc_running ", &p)) {
+			read_ints(p, &s->proc_running, 1);
+		} else if (stpstarts(line, "proc_blocked ", &p)) {
+			read_ints(p, &s->proc_blocked, 1);
+		}
+	}
+	if (ferror(fp))
+		eprintf("getline /proc/stat:");
+	fclose(fp);
+
+	if (!have_page || !have_swap) {
+		fp = fopen("/proc/vmstat", "r");
+		if (!fp)
+			eprintf("fopen /proc/vmstat:");
+		while ((len = getline(&line, &size, fp)) >= 0) {
+			if (!have_page && stpstarts(line, "pgpgin ", &p))
+				read_ints(p, &s->page_in, 1);
+			else if (!have_page && stpstarts(line, "pgpgout ", &p))
+				read_ints(p, &s->page_out, 1);
+			else if (!have_swap && stpstarts(line, "pswpin ", &p))
+				read_ints(p, &s->swap_in, 1);
+			else if (!have_swap && stpstarts(line, "pswpout ", &p))
+				read_ints(p, &s->swap_out, 1);
+		}
+		if (ferror(fp))
+			eprintf("getline /proc/vmstat:");
+		fclose(fp);
+	}
+
+	fp = fopen("/proc/meminfo", "r");
+	if (!fp)
+		eprintf("fopen /proc/meminfo:");
+	while ((len = getline(&line, &size, fp)) >= 0) {
+		if (stpstarts(line, "MemFree:", &p))
+			read_ints(p, &s->mem_free, 1);
+		else if (stpstarts(line, "Buffers:", &p))
+			read_ints(p, &s->buffers, 1);
+		else if (stpstarts(line, "Cached:", &p))
+			read_ints(p, &s->cached, 1);
+		else if (stpstarts(line, "Active:", &p))
+			read_ints(p, &s->active, 1);
+		else if (stpstarts(line, "Inactive:", &p))
+			read_ints(p, &s->inactive, 1);
+		else if (stpstarts(line, "SwapTotal:", &p))
+			read_ints(p, &s->swap_total, 1);
+		else if (stpstarts(line, "SwapFree:", &p))
+			read_ints(p, &s->swap_free, 1);
+		else if (stpstarts(line, "SReclaimable:", &p))
+			read_ints(p, &s->sreclaimable, 1);
+	}
+	if (ferror(fp))
+		eprintf("getline /proc/meminfo:");
+	fclose(fp);
+
+	/* yes, this is actually needed */
+	s->cpu_idle += debt;
+	debt = 0;
+	if (s->cpu_idle < 0) {
+		debt = s->cpu_idle;
+		s->cpu_idle = 0;
+	}
+
+	free(line);
+}
+
+static void
+print_vm(struct vm *s1, struct vm *s0, int active_mem, int timestamp, int print_header)
+{
+	struct vm s = *s1;
+	intmax_t ticks;
+	char timezone[21];
+	char timestr[21];
+	struct tm *tm;
+	time_t now;
+	size_t n;
+
+	ticks  = s.cpu_user       -= s0->cpu_user;
+	ticks += s.cpu_nice       -= s0->cpu_nice;
+	ticks += s.cpu_system     -= s0->cpu_system;
+	ticks += s.cpu_idle       -= s0->cpu_idle;
+	ticks += s.cpu_iowait     -= s0->cpu_iowait;
+	ticks += s.cpu_irq        -= s0->cpu_irq;
+	ticks += s.cpu_softirq    -= s0->cpu_softirq;
+	ticks += s.cpu_steal      -= s0->cpu_steal;
+	ticks += s.cpu_guest      -= s0->cpu_guest;
+	ticks += s.cpu_guest_nice -= s0->cpu_guest_nice;
+	ticks += s.cpu_unknown    -= s0->cpu_unknown;
+	s.processes         -= s0->processes;
+	s.intr              -= s0->intr;
+	s.ctxt_switches     -= s0->ctxt_switches;
+	s.page_in           -= s0->page_in;
+	s.page_out          -= s0->page_out;
+
+	s.cpu_user  += s.cpu_nice;
+	s.cpu_guest += s0->cpu_guest_nice;
+	s.cpu_idle  += !ticks;
+	ticks       += !ticks;
+
+	if (timestamp) {
+		now = time(NULL);
+		tm = localtime(&now);
+		strftime(timestr, sizeof(timestr), " %Y-%m-%d %H:%M:%S", tm);
+		strftime(timezone, sizeof(timezone), "%Z", tm);
+		n = strlen(timezone) + 1;
+		memmove(&timezone[sizeof(timezone) - n], timezone, n);
+		memset(timezone, ' ', sizeof(timezone) - n);
+	}
+
+#define PERCENT(X) ((X) * 100 + ticks / 2) / ticks
+#define HERTZ(X)   ((X) * hz  + ticks / 2) / ticks
+
+	if (!print_header)
+		goto print;
+	printf("----procs---- -------------------memory------------------ ---swap-- -----io---- --system- --------------cpu--------------%s\n",
+	       timestamp ? " -----timestamp-----" : "");
+	printf(" r  b      fk       swpd       free      " "%s     "  "%s   si   so    bi    bo   in   cs  us  sy  id  wa  in  si  st  gt%s\n",
+	       active_mem ? "inact" :  " buff", active_mem ? "active" : " cache", timestamp ? timezone : "");
+print:
+	printf("%2ji %2ji %7ji %10ji "   "%10ji "    "%10ji "  "%10ji %4ji %4ji %5ji %5ji ""%4ji %4ji %3ji %3ji %3ji %3ji %3ji %3ji %3ji %3ji%s\n",
+	       s.proc_running, s.proc_blocked, s.processes,
+	       s.swap_total - s.swap_free, s.mem_free, active_mem ? s.inactive : s.buffers, active_mem ? s.active : s.cached  + s.sreclaimable,
+	       HERTZ(s.swap_in * kb_per_page), HERTZ(s.swap_out * kb_per_page),
+	       HERTZ(s.page_in), HERTZ(s.page_out),
+	       HERTZ(s.intr), HERTZ(s.ctxt_switches),
+	       PERCENT(s.cpu_user), PERCENT(s.cpu_system), PERCENT(s.cpu_idle),
+	       PERCENT(s.cpu_iowait), PERCENT(s.cpu_irq), PERCENT(s.cpu_softirq),
+	       PERCENT(s.cpu_steal), PERCENT(s.cpu_guest),
+	       timestamp ? timestr : "");
+
+#undef PERCENT
+#undef HERTZ
+}
+
+static void
+usage(void)
+{
+	eprintf("usage: %s [-ant] [delay [count]]\n", argv0);
+}
+
+int
+main(int argc, char *argv[])
+{
+	static struct vm vm[2];
+	static struct timespec delay;
+	char *end;
+	double tmp;
+	unsigned long long int count = 0, i = 0;
+	int one_header = 0;
+	int active_mem = 0;
+	int timestamp = 0;
+
+	ARGBEGIN {
+	case 'a':
+		active_mem = 1;
+		break;
+	case 'n':
+		one_header = 1;
+		break;
+	case 't':
+		timestamp = 1;
+		break;
+	case 'w':
+		/* Ignored for compatibility (allow output to be wider than 80 columns) */
+		break;
+	default:
+		usage();
+	} ARGEND;
+
+	if (argc > 2)
+		usage();
+
+	kb_per_page = (intmax_t)(sysconf(_SC_PAGESIZE) / 1024);
+	hz = (intmax_t)sysconf(_SC_CLK_TCK);
+
+	if (argc) {
+		errno = 0;
+		tmp = strtod(argv[0], &end);
+		if (errno || *end || tmp <= 0)
+			eprintf("%s: not a valid positive number\n", argv[0]);
+		delay.tv_sec = (time_t)tmp;
+		tmp = (tmp - (double)delay.tv_sec) * 1000000000.;
+		delay.tv_nsec = (long int)tmp;
+		if (delay.tv_nsec > 999999999L)
+			delay.tv_nsec = 999999999L;
+
+		if (argc > 1)
+			count = (unsigned long long int)atoll(argv[1]);
+	}
+
+	for (;;) {
+		load_vm(&vm[i & 1]);
+		print_vm(&vm[i & 1], &vm[~i & 1], active_mem, timestamp, one_header ? !i : (i % 50 == 0));
+		i++;
+		if (!argc || (argc == 2 && i == count))
+			break;
+		clock_nanosleep(CLOCK_MONOTONIC, 0, &delay, NULL);
+	}
+
+	return 0;
+}
