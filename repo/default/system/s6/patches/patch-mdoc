diff -Naur a/mdoc/man7/s6-accessrules.7 b/mdoc/man7/s6-accessrules.7
--- a/mdoc/man7/s6-accessrules.7	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man7/s6-accessrules.7	2023-04-16 04:52:39.110496467 -0300
@@ -0,0 +1,527 @@
+.Dd September 29, 2021
+.Dt S6-ACCESSRULES 7
+.Os
+.Sh NAME
+.Nm s6-accessrules
+.Nd the accessrules library interface
+.Sh DESCRIPTION
+The following functions and structures are declared in the
+.Pa s6/accessrules.h
+header, and implemented in
+.Pa libs6.a
+or
+.Pa libs6.so .
+.Ss General information
+.Nm
+is an access control library.
+It looks up a key in a user-specified database, then returns a code
+depending on whether the database allows access (in which case
+additional information can also be returned), denies access, or does
+not contain the key.
+.Pp
+.Nm
+has been designed to be easily extensible to any database format and
+any key format.
+.Pp
+Check the
+.Pa s6/accessrules.h
+header for the exact definitions.
+.Ss Data structures
+An
+.Vt s6_accessrules_result_t
+is a scalar that can have the following values:
+.Dv S6_ACCESSRULES_ERROR ,
+.Dv S6_ACCESSRULES_DENY ,
+.Dv S6_ACCESSRULES_ALLOW
+or
+.Dv S6_ACCESSRULES_NOTFOUND .
+.Pp
+An
+.Vt s6_accessrules_params_t
+is a structure containing two strallocs[1],
+.Em .env
+and
+.Em .exec ,
+used to return data contained in the database when a key has been
+allowed.
+The interpretation of this data is application-defined.
+.Ss Function types
+.Sy Backend lookups
+.Pp
+An
+.Ft s6_accessrules_backend_func_t
+is the type of a function that takes a single key, looks it up in a
+database, and returns the result.
+Namely:
+.Pp
+.Dl s6_accessrules_result_t f (char const *key, size_t keylen, void *handle, s6_accessrules_params_t *params)
+.Pp
+.Fn f
+looks up key
+.Va key
+of length
+.Va keylen
+in the database represented by
+.Va handle
+in an implementation-defined way.
+It returns a number that says the key has been allowed, denied or not
+found, or an error occurred.
+If the key has been allowed,
+.Va f
+stores additional information from the database into
+.Va *params .
+.Pp
+Two
+.Ft s6_accessrules_backend_func_t
+functions are natively implemented:
+.Bl -bullet -width x
+.It
+.Fn s6_accessrules_backend_fs
+takes a
+.Vt char const *
+.Va handle
+and interprets it as a base directory to look up
+.Va key
+under, in the format understood by
+.Xr s6-accessrules-cdb-from-fs 8 .
+.It
+.Fn s6_accessrules_backend_cdb
+takes a
+.Vt struct cdb *
+.Va handle
+and looks up
+.Va key
+in the CDB[2] it points to.
+.Va handle
+must already be mapped to a CDB file.
+Such a file can be built with the
+.Xr s6-accessrules-cdb-from-fs 8
+utility.
+.El
+.Pp
+.Sy Frontend key checking
+.Pp
+An
+.Ft s6_accessrules_keycheck_func_t
+is the type of a function that takes a user-level key, makes a list of
+corresponding backend-level keys and calls a
+.Ft s6_accessrules_backend_func_t
+function until it finds a match.
+Namely:
+.Pp
+.Dl s6_accessrules_result_t f (void const *key, void *handle, s6_accessrules_params_t *params, s6_accessrules_backend_func_t *backend)
+.Pp
+.Fn f
+derives a list of low-level keys to check from
+.Va key .
+Then, for each key
+.Va k
+of length
+.Va klen
+in this list, it calls
+.Ql (*backend)(k, klen, handle, params) ,
+returning
+.Va *backend Ap
+s result if it is not
+.Dv S6_ACCESSRULES_NOTFOUND .
+If no match can be found in the whole list,
+.Fn f
+finally returns
+.Dv S6_ACCESSRULES_NOTFOUND .
+.Pp
+Five
+.Ft s6_accessrules_keycheck_func_t
+functions are natively implemented:
+.Bl -bullet -width x
+.It
+.Fn s6_accessrules_keycheck_uidgid
+interprets
+.Va key
+as a pointer to a structure containing an uid
+.Va u
+and a gid
+.Va g .
+The following checks are performed, in this order (i.e. subsequent
+checks are not performed if a match is found):
+.Bl -bullet -width x
+.It
+If
+.Va u
+is equal to the effective uid of the process, look for a
+.Pa uid/self
+match.
+.It
+Look for a
+.Sm off
+.Pa uid/
+.Va u
+.Sm on
+match.
+.It
+If
+.Va g
+is equal to the effective gid of the process, look for a
+.Pa gid/self
+match.
+.It
+Look for a
+.Sm off
+.Pa gid/
+.Va g
+.Sm on
+match.
+.It
+Look for a
+.Pa uid/default
+match.
+.El
+.It
+.Fn s6_accessrules_keycheck_reversedns
+interprets
+.Va key
+as a string containing an FQDN.
+Then for each suffix
+.Va k
+of
+.Va key ,
+starting with
+.Va key
+itself and ending with
+.Va key Ap
+s TLD, it looks up
+.Sm off
+.Pa reversedns/
+.Va k
+.Sm on .
+The final dot is excluded from
+.Va k .
+If no match can be found, the function checks
+.Pa reversedns/@
+and returns the result.
+For instance, if
+.Va key
+is
+.Dq foo.bar.com ,
+the following strings are looked up, in this order:
+.Bl -bullet -width x
+.It
+reversedns/foo.bar.com
+.It
+reversedns/bar.com
+.It
+reversedns/com
+.It
+reversedns/@
+.El
+.It
+.Fn s6_accessrules_keycheck_ip4
+interprets
+.Va key
+as 4 network-byte-order characters containing an IPv4 address.
+Then for each netmask
+.Va mask
+from 32 to 0, it constructs the IPv4 network prefix
+.Va addr
+corresponding to that address, and looks up
+.Sm off
+.Pa ip4/
+.Va addr Ns _ Ns Va mask
+.Sm on .
+For instance, if
+.Va key
+is
+.Dq \e300\e250\e001\e007 ,
+representing the 192.168.1.7 address, the following strings are looked
+up, in this order:
+.Bl -bullet -width x
+.It
+ip4/192.168.1.7_32
+.It
+ip4/192.168.1.6_31
+.It
+ip4/192.168.1.4_30
+.It
+ip4/192.168.1.0_29
+.It
+ip4/192.168.0.0_28
+.It
+ip4/192.168.0.0_27
+.El
+.Pp
+and so on, down to:
+.Bl -bullet -width x
+.It
+ip4/192.0.0.0_3
+.It
+ip4/192.0.0.0_2
+.It
+ip4/128.0.0.0_1
+.It
+ip4/0.0.0.0_0
+.El
+.Pp
+Note that the
+.Ql ip4/0.0.0.0_0
+string is a catch-all key that matches everything.
+.It
+.Fn s6_accessrules_keycheck_ip6
+interprets
+.Va key
+as 16 network-byte-order characters containing an IPv6 address.
+Then for each netmask
+.Va mask
+from 128 to 0, it constructs the IPv6 network prefix
+.Va addr
+corresponding to that address, in canonical form, and looks up
+.Sm off
+.Pa ip6/
+.Va addr Ns _ Ns Va mask
+.Sm on .
+For instance, if
+.Va key
+is
+.Dq *\e0\e024P@\e002\eb\e003\e0\e0\e0\e0\e0\e0\e020\e006 ,
+representing the 2a00:1450:4002:803::1006 address, the following
+strings are looked up, in this order:
+.Bl -bullet -width x
+.It
+ip6/2a00:1450:4002:803::1006_128
+.It
+ip6/2a00:1450:4002:803::1006_127
+.It
+ip6/2a00:1450:4002:803::1004_126
+.It
+ip6/2a00:1450:4002:803::1000_125
+.It
+ip6/2a00:1450:4002:803::1000_124
+.It
+ip6/2a00:1450:4002:803::1000_123
+.It
+ip6/2a00:1450:4002:803::1000_122
+.It
+ip6/2a00:1450:4002:803::1000_121
+.It
+ip6/2a00:1450:4002:803::1000_120
+.It
+ip6/2a00:1450:4002:803::1000_119
+.It
+ip6/2a00:1450:4002:803::1000_118
+.It
+ip6/2a00:1450:4002:803::1000_117
+.It
+ip6/2a00:1450:4002:803::1000_116
+.It
+ip6/2a00:1450:4002:803::1000_115
+.It
+ip6/2a00:1450:4002:803::1000_114
+.It
+ip6/2a00:1450:4002:803::1000_113
+.It
+ip6/2a00:1450:4002:803::_112
+.It
+ip6/2a00:1450:4002:803::_111
+.El
+.Pp
+and so on, down to:
+.Bl -bullet -width x
+.It
+ip6/2a00::_11
+.It
+ip6/2800::_10
+.It
+ip6/2800::_9
+.It
+ip6/2000::_8
+.It
+ip6/2000::_7
+.It
+ip6/2000::_6
+.It
+ip6/2000::_5
+.It
+ip6/2000::_4
+.It
+ip6/2000::_3
+.It
+ip6/::_2
+.It
+ip6/::_1
+.It
+ip6/::_0
+.El
+.Pp
+Note that the
+.Ql ip6/::_0
+string is a catch-all key that matches everything.
+.It
+.Fn s6_accessrules_keycheck_ip46
+interprets
+.Va key
+as a pointer to an
+.Vt ip46_t Ns
+[3], and behaves either as
+.Fn s6_accessrules_keycheck_ip6
+or
+.Fn s6_accessrules_keycheck_ip4 ,
+depending on the type of address
+.Va *key
+contains.
+.El
+.Ss Ready-to-use functions
+These functions are mostly macros; they're built by associating a
+frontend function with a backend function.
+.Bl -bullet -width x
+.It
+.Ft s6_accessrules_result_t
+.Fn s6_accessrules_uidgid_cdb "uid_t u" "gid_t g" "struct cdb *c" "s6_accessrules_params_t *params"
+.Pp
+Checks the
+.Va *c
+CDB database for an authorization for uid
+.Va u
+and gid
+.Va g .
+If the result is
+.Dv S6_ACCESSRULES_ALLOW ,
+additional information may be stored into
+.Va params .
+.It
+.Ft s6_accessrules_result_t
+.Fn s6_accessrules_uidgid_fs "uid_t u" "gid_t g" "char const *dir" "s6_accessrules_params_t *params"
+.Pp
+Checks the
+.Va dir
+base directory for an authorization for uid
+.Va u
+and gid
+.Va g .
+If the result is
+.Dv S6_ACCESSRULES_ALLOW ,
+additional information may be stored into
+.Va params .
+.It
+.Ft s6_accessrules_result_t
+.Fn s6_accessrules_reversedns_cdb "char const *name" "struct cdb *c" "s6_accessrules_params_t *params"
+.Pp
+Checks the
+.Va *c
+CDB database for an authorization for the
+.Va name
+FQDN.
+If the result is
+.Dv S6_ACCESSRULES_ALLOW ,
+additional information may be stored into
+.Va params .
+.It
+.Ft s6_accessrules_result_t
+.Fn s6_accessrules_reversedns_fs "char const *name" "char const *dir" "s6_accessrules_params_t *params"
+.Pp
+Checks the
+.Va dir
+base directory for an authorization for the
+.Va name
+FQDN.
+If the result is
+.Dv S6_ACCESSRULES_ALLOW ,
+additional information may be stored into
+.Va params .
+.It
+.Ft s6_accessrules_result_t
+.Fn s6_accessrules_ip4_cdb "char const *ip4" "struct cdb *c" "s6_accessrules_params_t *params"
+.Pp
+Checks the
+.Va *c
+CDB database for an authorization for the
+.Va ip4
+IPv4 address (4 network byte order characters).
+If the result is
+.Dv S6_ACCESSRULES_ALLOW ,
+additional information may be stored into
+.Va params .
+.It
+.Ft s6_accessrules_result_t
+.Fn s6_accessrules_ip4_fs "char const *ip4" "char const *dir" "s6_accessrules_params_t *params"
+.Pp
+Checks the
+.Va dir
+base directory for an authorization for the
+.Va ip4
+IPv4 address (4 network byte order characters).
+If the result is
+.Dv S6_ACCESSRULES_ALLOW ,
+additional information may be stored into
+.Va params .
+.It
+.Ft s6_accessrules_result_t
+.Fn s6_accessrules_ip6_cdb "char const *ip6" "struct cdb *c" "s6_accessrules_params_t *params"
+.Pp
+Checks the
+.Va *c
+CDB database for an authorization for the
+.Va ip6
+IPv6 address (16 network byte order characters).
+If the result is
+.Dv S6_ACCESSRULES_ALLOW ,
+additional information may be stored into
+.Va params .
+.It
+.Ft s6_accessrules_result_t
+.Fn s6_accessrules_ip6_fs "char const *ip6" "char const *dir" "s6_accessrules_params_t *params"
+.Pp
+Checks the
+.Va dir
+base directory for an authorization for the
+.Va ip6
+IPv6 address (16 network byte order characters).
+If the result is
+.Dv S6_ACCESSRULES_ALLOW ,
+additional information may be stored into
+.Va params .
+.It
+.Ft s6_accessrules_result_t
+.Fn s6_accessrules_ip46_cdb "ip46_t *ip" "struct cdb *c" "s6_accessrules_params_t *params"
+.Pp
+Checks the
+.Va *c
+CDB database for an authorization for the
+.Va ip
+IP address.
+If the result is
+.Dv S6_ACCESSRULES_ALLOW ,
+additional information may be stored into
+.Va params .
+.It
+.Ft s6_accessrules_result_t
+.Fn s6_accessrules_ip46_fs "ip46_t const *ip" "char const *dir" "s6_accessrules_params_t *params"
+.Pp
+Checks the
+.Va dir
+base directory for an authorization for the
+.Va ip
+IP address.
+If the result is
+.Dv S6_ACCESSRULES_ALLOW ,
+additional information may be stored into
+.Va params .
+.El
+.Sh SEE ALSO
+.Xr s6-fdholder 7 ,
+.Xr s6-ftrigr 7 ,
+.Xr s6-ftrigw 7 ,
+.Xr s6-libs6 7 ,
+.Xr s6-s6lock 7
+.Pp
+[1]
+.Lk https://skarnet.org/software/skalibs/libstddjb/stralloc.html
+.Pp
+[2]
+.Lk https://cr.yp.to/cdb.html
+.Pp
+[3]
+.Lk https://skarnet.org/software/skalibs/libstddjb/ip46.html
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/libs6/accessrules.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man7/s6-fdholder-error-codes.7 b/mdoc/man7/s6-fdholder-error-codes.7
--- a/mdoc/man7/s6-fdholder-error-codes.7	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man7/s6-fdholder-error-codes.7	2023-04-16 04:52:39.110496467 -0300
@@ -0,0 +1,136 @@
+.Dd September 29, 2021
+.Dt S6-FDHOLDER-ERROR-CODES 7
+.Os
+.Sh NAME
+.Nm s6-fdholder-error-codes
+.Nd error codes returned by the
+.Xr s6-fdholderd 8
+daemon
+.Sh DESCRIPTION
+The following error messages (and corresponding
+.Xr errno 3
+codes) can be returned by the
+.Xr s6-fdholderd 8
+daemon to its various clients.
+This page explains why they occur.
+.Bl -bullet -width x
+.It
+.Ql Protocol error
+.Po
+.Dv EPROTO
+.Pc
+or
+.Ql Protocol wrong type for socket
+.Po
+.Dv EPROTOTYPE
+.Pc
+.Pp
+The client connected to the wrong kind of server and they cannot
+communicate.
+This is generally a programming error.
+It can also signal a bug in the s6-fdholder tools, but protocol bugs
+have usually been wiped out before an s6 release.
+.It
+.Ql Broken pipe
+.Po
+.Dv EPIPE
+.Pc
+.Pp
+The client was not authorized to connect to the server, which closed
+the connection.
+You need to configure the access rights to the server.
+.It
+.Ql Operation not permitted
+.Po
+.Dv EPERM
+.Pc
+.Pp
+Even though the client was authorized to connect to the server, the
+specific operation it wanted to perform was denied.
+You need to configure the access rights to the server.
+.It
+.Ql Too many open files in system
+.Po
+.Dv ENFILE
+.Pc
+.Pp
+The client attempted to store more file descriptors than the server
+can hold.
+Or, the client attempted to retrieve more file descriptors than it can
+hold.
+You should check the
+.Fl n
+option to
+.Xr s6-fdholderd 8 ,
+as well as the
+.Dv RLIMIT_NOFILE Ns [1]
+resource limits used by the client and the server, and adjust them
+accordingly.
+.It
+.Ql Resource busy
+.Po
+.Dv EBUSY
+.Pc
+.Pp
+The client attempted to store a descriptor under an identifier that is
+already used.
+.It
+.Ql Filename too long
+.Po
+.Dv ENAMETOOLONG
+.Pc
+.Pp
+The identifier provided by the client was too long.
+.It
+.Ql \&No such file or directory
+.Po
+.Dv ENOENT
+.Pc
+.Pp
+The identifier provided by the client was not found in the server
+database.
+.It
+.Ql Bad file descriptor
+.Po
+.Dv EBADF
+.Pc
+.Pp
+The client attempted to transmit a closed, or otherwise unsuitable for
+fd-passing, file descriptor.
+.It
+.Ql Operation timed out
+.Po
+.Dv ETIMEDOUT
+.Pc
+.Pp
+The client, or the server, took too long to perform the wanted
+operation.
+This is most probably a programming error, because both client and
+server should have a very fast reaction time.
+Check that the client is connecting to the right server, and check
+.Fl t
+options to both client and server (the argument is interpreted as
+milliseconds!).
+.El
+.Pp
+Other errors indicate a transient error such as lack of memory,
+hardware failure, etc.
+.Sh SEE ALSO
+.Xr s6-fdholder-daemon 8 ,
+.Xr s6-fdholder-delete 8 ,
+.Xr s6-fdholder-getdump 8 ,
+.Xr s6-fdholder-list 8 ,
+.Xr s6-fdholder-retrieve 8 ,
+.Xr s6-fdholder-setdump 8 ,
+.Xr s6-fdholder-store 8 ,
+.Xr s6-fdholder-transferdump 8 ,
+.Xr s6-fdholderd 8
+.Pp
+[1]
+.Lk https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_resource.h.html
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-fdholder-errorcodes.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man7/s6-fdholder.7 b/mdoc/man7/s6-fdholder.7
--- a/mdoc/man7/s6-fdholder.7	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man7/s6-fdholder.7	2023-04-16 04:52:39.110496467 -0300
@@ -0,0 +1,237 @@
+.Dd September 29, 2021
+.Dt S6-FDHOLDER 7
+.Os
+.Sh NAME
+.Nm s6-fdholder
+.Nd API for clients wanting to communicate with an
+.Xr s6-fdholderd 8
+daemon
+.Sh DESCRIPTION
+Check the
+.Pa s6/s6-fdholder.h
+header for the exact function prototypes.
+.Ss A programming example
+The
+.Pa src/fdholder/s6-fdholder-*.c
+files in the s6 package, for instance, illustrate how to use the
+.Nm
+library.
+.Ss Synchronous functions with a specified maximum execution time
+The explanation given in
+.Xr s6-ftrigr 7
+applies here too: the functions documented in this page are
+synchronous, but can return early if the deadline is reached, in which
+case the connection to the server should be closed immediately because
+no protocol consistency is guaranteed.
+.Pp
+The
+.Xr s6-fdholderd 8
+server should be very quick to answer queries, so this mechanism is
+provided as a simple security against programming errors - for
+instance, connecting to the wrong daemon.
+.Ss Starting and ending a session
+.Bd -literal -offset indent
+s6_fdholder_t a = S6_FDHOLDER_ZERO ;
+int fd = 6 ;
+
+tain_now_g() ;
+
+s6_fdholder_init(&a, fd) ;
+(...)
+s6_fdholder_free(&a) ;
+.Ed
+.Pp
+.Fn s6_fdholder_init
+assumes that
+.Va fd
+is a socket already connected to an
+.Xr s6-fdholderd 8
+daemon.
+The
+.Va a
+structure must be initialized to
+.Dv S6_FDHOLDER_ZERO
+before use.
+.Pp
+.Fn tain_now_g
+initializes a global variable that keeps track of the current time,
+for use with later functions.
+.Pp
+.Fn s6_fdholder_free
+frees the resources occupied by
+.Va a .
+It does not, however, close
+.Va fd .
+You should manually close it to end the connection to the server.
+Note that if your program has been started by
+.Xr s6-ipcclient 8 ,
+both fds 6 and 7 are open (and refer to the same socket), so you
+should close both.
+.Pp
+Alternatively, if your connection to
+.Xr s6-fdholderd 8
+has not been created yet, you can use the following functions:
+.Bl -bullet -width x
+.It
+.Ft int
+.Fn s6_fdholder_start "s6_fdholder_t *a" "char const *path" "tain_t const *deadline" "tain_t *stamp"
+.Pp
+Starts a session with an
+.Xr s6-fdholderd 8
+instance listening on
+.Va path .
+.Va a
+must be initialized to
+.Dv S6_FDHOLDER_ZERO
+before calling this function.
+On success, returns nonzero and
+.Va a
+can be used as a handle for the next
+.Fn s6_fdholder_*
+function calls.
+On failure, returns 0, and sets errno.
+.It
+.Ft void
+.Fn s6_fdholder_end "s6_fdholder_t *a"
+.Pp
+Ends the current session and frees all allocated resources.
+If needed,
+.Va a
+is immediately reusable for another
+.Fn s6_fdholder_start
+call.
+.El
+.Ss Storing an fd
+.Bd -literal -offset indent
+int r ;
+int fd ;
+tain_t limit = TAIN_INFINITE ;
+char const *id = "my_identifier" ;
+r = s6_fdholder_store_g(&a, fd, id, &limit, &deadline) ;
+.Ed
+.Pp
+.Fn s6_fdholder_store
+(and its variant
+.Fn s6_fdholder_store_g
+that uses the global timestamp variable) attempts to store a copy of
+descriptor
+.Va fd
+into
+.Xr s6-fdholderd 8 ,
+using identifier
+.Va id ,
+with an expiration date of
+.Va limit .
+In this example,
+.Va limit
+is
+.Dv TAIN_INFINITE ,
+which means no expiration date.
+The operation should return before
+.Va deadline ,
+else it will automatically return 0
+.Dv ETIMEDOUT .
+The result is 1 on success and 0 on failure, with an appropriate errno
+code; refer to
+.Xr s6-fdholder-error-codes 7 .
+.Ss Deleting an fd
+.Dl fd = s6_fdholder_delete_g(&a, id, &deadline) ;
+.Pp
+.Fn s6_fdholder_delete
+attempts to delete the file descriptor identified by
+.Va id .
+It returns 1 on success and 0 on failure, with an appropriate errno
+code; refer to
+.Xr s6-fdholder-error-codes 7 .
+.Ss Retrieving an fd
+.Dl fd = s6_fdholder_retrieve_g(&a, id, &deadline) ;
+.Pp
+.Fn s6_fdholder_retrieve
+attempts to retrieve the file descriptor identified by
+.Va id .
+It returns a valid fd number on success, and -1 on failure, with an
+appropriate errno code; refer to
+.Xr s6-fdholder-error-codes 7 .
+.Pp
+.Fn s6_fdholder_retrieve_delete
+performs a retrieval and a deletion at the same time, if the client is
+authorized to do so.
+.Ss Listing the identifiers held by the server
+.Bd -literal -offset indent
+stralloc list = STRALLOC_ZERO ;
+int n ;
+n = s6_fdholder_list_g(&a, &list, &deadline) ;
+.Ed
+.Pp
+.Fn s6_fdholder_list
+gets the list of all identifiers currently held by the server.
+It stores it into the stralloc[1]
+.Va list ,
+as a series of null-terminated strings, one after the other.
+There are
+.Va n
+such strings.
+The function returns
+.Va n
+on success, or -1 on failure, with an appropriate errno code; refer to
+.Xr s6-fdholder-error-codes 7 .
+.Ss Reading a dump
+.Bd -literal -offset indent
+genalloc dump = GENALLOC_ZERO ;
+r = s6_fdholder_getdump_g(&a, &dump, &deadline) ;
+.Ed
+.Pp
+.Fn s6_fdholder_getdump
+attempts to retrieve the whole set of descriptors from the server.
+It returns 1 on success, and 0 on failure, with an appropriate errno
+code; refer to
+.Xr s6-fdholder-error-codes 7 .
+The set is stored into the genalloc[2]
+.Va dump ,
+which is to be interpreted as a stralloc containing an array of
+.Vt s6_fdholder_fd_t .
+.Pp
+.Ql genalloc_s(s6_fdholder_fd_t, &dump)
+is a pointer to this array, and
+.Ql genalloc_len(s6_fdholder_fd_t, &dump)
+is the number of elements in the array.
+An
+.Vt s6_fdholder_fd_t
+contains at least a descriptor number, an identifier, and an
+expiration date; see the
+.Pa s6/s6-fdholder.h
+header file.
+.Ss Writing a dump
+.Bd -literal -offset indent
+unsigned int dumplen ;
+s6_fdholder_fd_t const *dumparray ;
+r = s6_fdholder_setdump_g(&a, &dumparray, dumplen, &deadline) ;
+.Ed
+.Pp
+.Fn s6_fdholder_setdump
+attempts to send a set of descriptors to the server.
+The descriptors are contained in the array
+.Va dumparray
+of length
+.Va dumplen .
+The function returns 1 on success, and 0 on failure, with an
+appropriate errno code; refer to
+.Xr s6-fdholder-error-codes 7 .
+.Sh SEE ALSO
+.Xr s6-accessrules 7 ,
+.Xr s6-ftrigr 7 ,
+.Xr s6-ftrigw 7 ,
+.Xr s6-libs6 7 ,
+.Xr s6-s6lock 7
+.Pp
+[1]
+.Lk https://skarnet.org/software/skalibs/libstddjb/stralloc.html
+.Pp
+[2]
+.Lk https://skarnet.org/software/skalibs/libstddjb/genalloc.html
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/libs6/s6-fdholder.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man7/s6-fifodir.7 b/mdoc/man7/s6-fifodir.7
--- a/mdoc/man7/s6-fifodir.7	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man7/s6-fifodir.7	2023-04-16 04:52:39.110496467 -0300
@@ -0,0 +1,171 @@
+.Dd January 15, 2023
+.Dt S6-FIFODIR 7
+.Os
+.Sh NAME
+.Nm s6-fifodir
+.Nd rendez-vous point between the notifier of certain events and its listeners
+.Sh DESCRIPTION
+An
+.Nm
+is implemented via a directory in the filesystem.
+No data is stored; it is appropriate to create fifodirs in a RAM
+filesystem.
+.Ss C API
+For the notifier:
+.Bl -bullet -width x
+.It
+You can create fifodirs via the
+.Fn ftrigw_fifodir_create
+function in
+.Xr s6-ftrigw 7 .
+.It
+You can send an event to a fifodir via the
+.Fn ftrigw_notify
+function in the notifier part of
+.Xr s6-ftrigw 7 .
+.It
+You can clean up a fifodir via the
+.Fn ftrigw_clean
+function in
+.Xr s6-ftrigw 7 .
+.It
+You can destroy fifodirs via the
+.Fn rm_rf
+function in libstddjb[1].
+.El
+.Pp
+For a listener:
+.Bl -bullet -width x
+.It
+You can subscribe to a fifodir via the
+.Fn ftrigr_subscribe
+function in the listener part of the
+.Xr s6-ftrigr 7 .
+.It
+Other functions in
+.Xr s6-ftrigr 7
+allow you to receive and handle events synchronously or
+asynchronously.
+.El
+.Ss Unix API
+For the notifier:
+.Bl -bullet -width x
+.It
+You can create fifodirs with the
+.Xr s6-mkfifodir 8
+command.
+.It
+You can send an event to a fifodir with the
+.Xr s6-ftrig-notify 8
+command.
+.It
+You can clean up a fifodir with the
+.Xr s6-cleanfifodir 8
+command.
+.It
+You can destroy fifodirs with the
+.Ql rm -rf
+command.
+.El
+.Pp
+For a listener:
+.Bl -bullet -width x
+.It
+You can subscribe to a fifodir and wait for an event, or a series or
+events, with the
+.Xr s6-ftrig-wait 8
+command.
+.It
+You can subscribe to a fifodir, then trigger a program, then wait for
+an event, with the
+.Xr s6-ftrig-listen1 8
+and
+.Xr s6-ftrig-listen 8
+commands.
+This makes it possible to only send a notification after you're sure a
+notifier is actually listening, in order to prevent race conditions.
+.El
+.Sh IMPLEMENTATION NOTES
+.Bl -bullet -width x
+.It
+Notifiers and listeners agree on a fifodir.
+.It
+The fifodir directory is created by the notifier.
+It must be writable by listeners.
+.It
+To subscribe, a listener atomically creates a named pipe (FIFO) in
+this directory and listens to the reading end.
+This named pipe must be writable by the notifier.
+.It
+To send an event to listeners, the notifier writes the event byte to
+all the named pipes in the directory.
+Credit for this idea goes to Stefan Karrmann.
+.It
+To unsubscribe, a listener unlinks his named pipe from the directory.
+.El
+.Pp
+Note that in the s6 implementation of fifodirs, there are a few
+additional details: for instance, the named pipes created in a fifodir
+by a listener follow a strict naming convention, for efficiency and
+safety reasons.
+If you are using fifodirs, it is recommended that you use the provided
+C library functions or the
+.Ql s6-ftrig-*
+command line utilities instead of directly hacking into the fifodir
+internals.
+.Pp
+Fifodirs are created by, so they always originally have the same uid
+and gid as, their notifier.
+A notifier must be able to make his fifodir either publicly accessible
+(anyone can subscribe) or restricted (only a given group can
+subscribe).
+.Pp
+A publicly accessible fifodir must have rights 1733:
+.Bl -bullet -width x
+.It
+Anyone can create a fifo in that fifodir.
+.It
+Only the notifier can see all the subscribers' fifos.
+.It
+A listener can only delete its own fifo.
+.It
+A notifier can delete any fifo for cleaning purposes.
+.El
+.Pp
+A restricted fifodir must have the gid g of the group of allowed
+listeners and have rights 3730.
+Unless the notifier is root, it must be in the group of allowed
+listeners to be able to create such a fifodir.
+.Bl -bullet -width x
+.It
+Only members of g can create a fifo in that fifodir.
+.It
+Only the notifier can see all the subscribers' fifos.
+.It
+Fifos are always created with gid g.
+.It
+A listener can only delete its own fifo.
+.It
+A notifier can delete any fifo for cleaning purposes.
+.El
+.Pp
+A named pipe in a fifodir must always belong to its listener and have
+rights 0622:
+.Bl -bullet -width x
+.It
+Only this listener can read on the fifo.
+.It
+Anyone who has reading rights on the fifodir (i.e. only the notifier)
+can write to the fifo.
+.El
+.Pp
+The libftrig interface takes care of all the subtleties.
+.Sh SEE ALSO
+[1]
+.Lk https://skarnet.org/software/skalibs/libstddjb/djbunix.html
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/fifodir.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man7/s6-ftrigr.7 b/mdoc/man7/s6-ftrigr.7
--- a/mdoc/man7/s6-ftrigr.7	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man7/s6-ftrigr.7	2023-04-16 04:52:39.110496467 -0300
@@ -0,0 +1,383 @@
+.Dd May 31, 2022
+.Dt S6-FTRIGR 7
+.Os
+.Sh NAME
+.Nm s6-ftrigr
+.Nd API for listeners, i.e. programs that want to subscribe to
+.Xr s6-fifodir 7 Ns
+s and be instantly notified when the proper sequence of events happens
+.Sh DESCRIPTION
+Check the
+.Pa s6/ftrigr.h
+header for the exact function prototypes.
+.Pp
+Make sure your application is not disturbed by children it doesn't
+know it has.
+This means paying some attention to the SIGCHLD handler, if any, and
+to the way you perform
+.Xr waitpid 2 Ns
+s.
+The best practice is to use a self-pipe[1] to handle SIGCHLD (as well as
+other signals the application needs to trap), and to
+.Em always
+use
+.Fn wait_nohang
+to reap children, simply ignoring pids you don't know.
+.Pp
+If your application has trouble handling unknown children, consider
+using an
+.Xr s6-ftrigrd 8
+service.
+(And fix your application!)
+.Ss A programming example
+The
+.Pa src/pipe-tools/s6-ftrig-listen1.c
+and
+.Pa src/supervision/s6-svwait.c
+files in the s6 package, for instance, illustrate how to use the
+.Nm
+library.
+.Ss Synchronous functions with a specified maximum execution time
+Synchronous functions take a
+.Ql Vt tain_t const * Po Va deadline Pc
+parameter and a
+.Ql Vt tain_t * Po Va stamp Pc
+parameter.
+Those are pointers to
+.Vt tain_t
+structures containing absolute times; the former represents a deadline
+(in most cases, this time will be in the future) and the latter must
+be an accurate enough timestamp.
+These structures can be filled using the
+.Ql tain_
+primitives declared in
+.Pa skalibs/tai.h Ns
+[2].
+.Pp
+.Po
+.Dq Accurate enough
+means that
+.Sy no blocking system call
+must have been made since the last time
+.Va stamp
+was updated
+.Po
+by
+.Ql tain_now Po Va &stamp Pc
+.Pc .
+It's a good policy to always update
+.Va stamp
+right after a (potentially) blocking system call like
+.Xr select 2
+returns.
+And unless the application is extremely CPU-intensive (think calculus
+for physicists or astronomers) updating
+.Va stamp
+more frequently is unnecessary.
+.Pc
+.Pp
+If such a synchronous function still hasn't returned when the deadline
+occurs, then it will immediately return a failure code and set errno
+to
+.Dv ETIMEDOUT .
+It is possible to pass null pointers to the function instead of pointers to
+.Vt tain_t
+structures, in which case the function will never timeout.
+.Pp
+If a timeout occurs, the library does not guarantee proper
+interprocess communication later on; the application should either
+die, or at least close the communication channel and open a new one.
+.Pp
+If any waiting occurred, the
+.Va stamp
+structure is automatically updated by the called function, so it
+always represents an accurate enough estimation of the current
+time.
+This allows the programmer to call several such functions in a
+sequence without modifying the
+.Va deadline
+and
+.Va stamp
+parameters: then the whole sequence is bound in execution time.
+.Pp
+This is a general safety mechanism implemented in libunixonacid[3]: in
+interprocess communication, purely synchronous primitives are
+dangerous because they make the calling process rely on proper
+behaviour of the called process.
+Giving synchronous primitives the ability to timeout allows developers
+to write reliable programs even when interacting with software they
+have no control over.
+.Ss Starting and ending a session
+.Bd -literal -offset indent
+ftrigr_t a = FTRIGR_ZERO ;
+tain_t deadline, stamp ;
+
+tain_now(&stamp) ;
+tain_addsec(&deadline, &stamp, 2)
+
+// char const *path = FTRIGR_IPCPATH ;
+// ftrigr_start(&a, path, &deadline, &stamp) ;
+ftrigr_startf(&a, &deadline, &stamp) ;
+.Ed
+.Pp
+.Fn ftrigr_start
+starts a session with an
+.Xr s6-ftrigrd 8
+service listening on
+.Va path .
+.Pp
+.Fn ftrigr_startf
+starts a session with an
+.Xr s6-ftrigrd 8
+process as a child (which is the simplest usage).
+.Pp
+.Va a
+is an
+.Vt ftrigr_t
+structure that must be declared in the stack and initialized to
+.Dv FTRIGR_ZERO .
+.Va stamp
+must be an accurate enough timestamp.
+.Pp
+If the session initialization fails, the function returns 0 and errno
+is set; else the function returns 1.
+.Pp
+If the absolute time
+.Va deadline
+is reached and the function has not returned yet, it immediately
+returns 0 with errno set to
+.Dv ETIMEDOUT .
+Only local interprocess communications are involved; unless your
+system is heavily overloaded, the function should return
+near-instantly.
+One or two seconds of delay between
+.Va stamp
+and
+.Va deadline
+should be enough: if the function takes more than that to return, then
+there is a problem with the underlying processes.
+.Pp
+You can have more than one session open in parallel, by declaring
+several distinct
+.Vt ftrigr_t
+structures and calling
+.Fn ftrigr_startf
+.Po
+or
+.Fn ftrigr_start
+.Pc
+more than once.
+However, this is useless, since one single session can handle
+virtually as many concurrent
+.Xr s6-fifodir 7 Ns
+s as your application needs.
+.Bd -literal -offset indent
+ftrigr_end(&a) ;
+.Ed
+.Pp
+.Fn ftrigr_end
+frees all the resources used by the session.
+The
+.Va a
+structure is then
+reusable for another session.
+.Ss Subscribing to an Xr s6-fifodir 7
+.Bd -literal -offset indent
+char const *path = "/var/lib/myservice/fifodir" ;
+char const *re = "a.*b|c*d" ;
+uint32_t options = 0 ;
+
+uint16_t id = ftrigr_subscribe (&a, path, re, options, &deadline, &stamp) ;
+.Ed
+.Pp
+.Fn ftrigr_subscribe
+instructs the
+.Xr s6-ftrigrd 8
+daemon, related to the open session represented by the
+.Va a
+structure, to subscribe to the
+.Va path
+.Xr s6-fifodir 7 ,
+and to notify the application when it receives a series of events that
+matches the
+.Va re
+regexp.
+.Va options
+can be 0 or
+.Dv FTRIGR_REPEAT .
+If it is 0, the daemon will automatically unsubscribe from
+.Va path
+once
+.Va re
+has been matched by a series of events.
+If it is
+.Dv FTRIGR_REPEAT ,
+it will remain subscribed until told otherwise.
+.Pp
+.Fn ftrigr_subscribe
+returns 0 and sets errno in case of failure, or a nonzero 16-bit
+number identifying the subscription in case of success.
+.Pp
+.Fn ftrigr_subscribe
+should return near-instantly, but if
+.Va deadline
+is reached, it will return 0
+.Dv ETIMEDOUT .
+If
+.Fn ftrigr_subscribe
+returns successfully, then the
+.Xr s6-ftrigrd 8
+daemon is guaranteed to be listening on
+.Pa path ,
+and events can be sent without the risk of a race condition.
+.Ss Synchronously waiting for events
+.Bd -literal -offset indent
+uint16_t list[1] ;
+unsigned int n = 1 ;
+char trigger ;
+list[0] = id ;
+
+// r = ftrigr_wait_and(&amp;a, list, n, &amp;deadline, &amp;stamp) ;
+r = ftrigr_wait_or(&amp;a, list, n, &amp;deadline, &amp;stamp, &amp;trigger) ;
+.Ed
+.Pp
+.Fn ftrigr_wait_and
+waits for all the
+.Va n
+.Xr s6-fifodir 7 Ns s
+whose ids are listed in
+.Va list
+to receive an event.
+It returns -1 in case of error or timeout, or a non-negative integer
+in case of success.
+.Pp
+.Fn ftrigr_wait_or
+waits for one of the
+.Va n
+.Xr s6-fifodir 7 Ns s
+whose ids are listed in
+.Va list
+to receive an event.
+It returns -1 in case of error or timeout; if it succeeds, the return
+value is the position in
+.Va list ,
+starting at 0, of the identifier that received an event; and
+.Va trigger
+is set to the character that triggered that event, i.e. the last
+character of a sequence that matched the regular expression
+.Va re
+used in the subscription.
+.Ss Asynchronously waiting for events
+.Em (From now on, the functions are listed with their prototypes instead of usage examples.)
+.Bl -tag -width x
+.It Ft int Fn ftrigr_fd "ftrigr_t const *a"
+.Pp
+Returns a file descriptor to select on for reading.
+Do not
+.Xr read 2
+it though.
+.It Ft int Fn ftrigr_updateb "ftrigr_t *a"
+.Pp
+Call this function whenever the fd checks readability: it will update
+.Va a Ap
+s internal structures with information from the
+.Xr s6-ftrigrd 8
+daemon.
+It returns -1 if an error occurs; in case of success, it returns the
+number of identifiers for which something happened.
+.Pp
+When
+.Fn ftrigr_updateb
+returns,
+.Ql genalloc_s(uint16_t, &a->list)
+points to an array of
+.Ql genalloc_len(uint16_t, &a->list)
+16-bit unsigned integers.
+Those integers are ids waiting to be passed to
+.Fn ftrigr_check
+or
+.Fn ftrigr_checksa .
+The number of ids already acknowledged is stored in
+.Ql a->head ,
+so the first unacknowledged id is
+.Ql genalloc_s(uint16_t, &a->list)[a->head] .
+.It Ft int Fn ftrigr_check "ftrigr_t *a" "uint16_t id" "char *what"
+.Pp
+Checks whether an event happened to
+.Va id .
+Use after a call to
+.Fn ftrigr_updateb .
+.Bl -bullet -width x
+.It
+If an error occurred, returns -1 and sets errno.
+The error number may have been transmitted from
+.Xr s6-ftrigrd 8 .
+.It
+If no notification happened yet, returns 0.
+.It
+If something happened, writes the character that triggered the latest
+notification into
+.Va what
+and returns the number of times that an event happened to this
+identifier since the last call to
+.Fn ftrigr_check .
+.El
+.It Ft int Fn ftrigr_checksa "ftrigr_t *a" "uint16_t id" "stralloc *what"
+.Pp
+Checks whether an event happened to
+.Va id .
+Use after a call to
+.Fn ftrigr_update ,
+as an alternative to
+.Fn ftrigr_check .
+.Bl -bullet -width x
+.It
+If an error occurred, returns -1 and sets errno.
+The error number may have been transmitted from
+.Xr s6-ftrigrd 8 .
+.It
+If no notification happened yet, returns 0.
+.It
+If something happened, appends one character to the end of the
+.Va what
+stralloc[4] for every time a notification was triggered since the last
+call to
+.Fn ftrigr_check .
+Each character is the one that triggered a notification.
+The function then returns 1.
+.El
+.It Ft int Fn ftrigr_ack "ftrigr_t *a" "size_t n"
+.Pp
+Acknowledges reading
+.Va n
+ids from the id list updated by
+.Fn ftrigr_updateb .
+.It Ft int Fn ftrigr_update "ftrigr_t *a"
+.Pp
+Acknowledges all the pending ids (i.e. clears the stored id list) then calls
+.Fn ftrigr_updateb .
+.El
+.Sh SEE ALSO
+.Xr s6-accessrules 7 ,
+.Xr s6-fdholder 7 ,
+.Xr s6-ftrigw 7 ,
+.Xr s6-libs6 7 ,
+.Xr s6-s6lock 7
+.Pp
+[1]
+.Lk https://skarnet.org/software/skalibs/libstddjb/selfpipe.html
+.Pp
+[2]
+.Lk https://skarnet.org/software/skalibs/libstddjb/tai.html
+.Pp
+[3]
+.Lk https://skarnet.org/software/skalibs/libunixonacid/
+.Pp
+[4]
+.Lk https://skarnet.org/software/skalibs/libstddjb/stralloc.html
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/libs6/ftrigr.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man7/s6-ftrigw.7 b/mdoc/man7/s6-ftrigw.7
--- a/mdoc/man7/s6-ftrigw.7	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man7/s6-ftrigw.7	2023-04-16 04:52:39.110496467 -0300
@@ -0,0 +1,119 @@
+.Dd September 29, 2021
+.Dt S6-FTRIGW 7
+.Os
+.Sh NAME
+.Nm s6-ftrigw
+.Nd API for notifiers, i.e. programs that want to regularly announce what they're doing
+.Sh DESCRIPTION
+Notifiers should create an
+.Xr s6-fifodir 7
+in a hardcoded place in the filesystem, and document its
+location.
+Listeners will then be able to subscribe to that
+.Xr s6-fifodir 7 ,
+and receive the events.
+.Pp
+Check the
+.Pa s6/ftrigw.h
+header for the exact function prototypes.
+.Ss Creating a fifodir
+.Bd -literal -offset indent
+char const *path = "/var/lib/myservice/fifodir" ;
+gid_t gid = -1 ;
+int forceperms = 0 ;
+int r = ftrigw_fifodir_make(path, gid, forceperms) ;
+.Ed
+.Pp
+.Fn ftrigw_fifodir_make
+creates an
+.Xr s6-fifodir 7
+at the
+.Va path
+location.
+It returns 0, and sets errno, if an error occurs.
+It returns 1 if it succeeds.
+.Pp
+If an
+.Xr s6-fifodir 7 ,
+owned by the user, already exists at
+.Va path ,
+and
+.Va forceperms
+is zero, then
+.Fn ftrigw_fifodir_make
+immediately returns success.
+If
+.Va forceperms
+is nonzero, then it tries to adjust
+.Va path
+.Ap s
+permissions before returning.
+.Pp
+If
+.Va gid
+is negative, then
+.Va path
+is created
+.Dq public .
+Any listener will be able to subscribe to
+.Va path .
+If
+.Va gid
+is nonnegative, then
+.Va path
+is created
+.Dq private .
+Only processes belonging to group
+.Va gid
+will be able to subscribe to
+.Va path .
+.Ss Sending an event
+.Bd -literal -offset indent
+char event = 'a' ;
+r = ftrigw_notify(path, event) ;
+.Ed
+.Pp
+.Fn ftrigw_notify
+sends
+.Va event
+to all the processes that are currently subscribed to
+.Va path .
+It returns -1 if an error occurs, or the number of successfully
+notified processes.
+.Ss Cleaning up
+When stray KILL signals hit
+.Xr s6-ftrigrd 8
+processes,
+.Bl -enum -width x
+.It
+it's a sign of incorrect system administration,
+.It
+they can leave unused named pipes in the
+.Xr s6-fifodir 7 .
+.El
+.Pp
+It's the
+.Xr s6-fifodir 7 Ap
+s owner's job, i.e. the notifier's job, to periodically do some
+housecleaning and remove those unused pipes.
+.Bd -literal -offset indent
+r = ftrigw_clean(path) ;
+.Ed
+.Pp
+.Fn ftrigw_clean
+cleans
+.Va path .
+It returns 0, and sets errno, if it encounters an error.
+It returns 1 if it succeeds.
+.Sh SEE ALSO
+.Xr s6-accessrules 7 ,
+.Xr s6-fdholder 7 ,
+.Xr s6-ftrigr 7 ,
+.Xr s6-libs6 7 ,
+.Xr s6-s6lock 7
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/libs6/ftrigw.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man7/s6-instanced-service.7 b/mdoc/man7/s6-instanced-service.7
--- a/mdoc/man7/s6-instanced-service.7	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man7/s6-instanced-service.7	2023-04-16 04:52:39.111496467 -0300
@@ -0,0 +1,162 @@
+.Dd February 19, 2023
+.Dt S6-INSTANCED-SERVICE 7
+.Os
+.Sh NAME
+.Nm s6-instanced-service
+.Nd dynamic instantiation
+.Sh DESCRIPTION
+An
+.Em instanced service
+is a parameterized service that you want to run several copies of,
+with only the parameter changing.
+Each copy of the service is called an
+.Em instance .
+.Pp
+With s6, an
+.Xr s6-service-directory 7
+can only handle one process at a time.
+So, if we want instanced services, there will have to be one service
+directory per instance, always.
+.Pp
+.Em Static instantiation
+means that the set of possible instances is finite and known in
+advance.
+With s6, it means that all the service directories for all possible
+instances are created, typically by a preprocessor, and instances are
+treated like regular services.
+.Pp
+.Em Dynamic instantiation
+means that instances are created on demand instead of preallocated.
+Starting with version 2.11.2.0, s6 provides a few tools to help users
+set up and manage dynamically instanced services.
+.Ss How to make a dynamically instanced service under s6
+.Bl -bullet -width x
+.It
+Write a template for a service directory that would run under
+.Xr s6-supervise 8 .
+The
+.Pa run
+script should take the name of the instance as its first argument; the
+.Pa finish
+script, if present, should take the name of the instance as its third
+argument.
+.It
+Call the
+.Xr s6-instance-maker 8
+program with this template as first argument, and a path
+.Pa dir
+as second argument.
+.Xr s6-instance-maker 8
+will create a service directory in
+.Pa dir .
+This is an offline tool: it does not interact with any currently
+active services or supervision trees.
+.It
+Supervise
+.Pa dir
+by adding it to your regular
+.Xr s6-scan-directory 7 .
+This will be your instanced service, but it's not running any instances yet.
+It is, instead, a nested supervision tree - the instanced service is an
+.Xr s6-svscan 8
+process that will supervise all the instances.
+.It
+Create and delete instances at will with the
+.Xr s6-instance-create 8
+and
+.Xr s6-instance-delete 8
+programs; you can list all the available instances with
+.Xr s6-instance-list 8 .
+These tools are
+.Em online :
+they work with live service directories, i.e. that are being supervised by
+.Xr s6-supervise 8 .
+.It
+Instances are regular supervised processes.
+You can control individual instances with
+.Xr s6-instance-control 8 ,
+and check their status with
+.Xr s6-instance-status 8 .
+These tools are online as well.
+.El
+.Ss Internal workings
+This section is not normative; users should not rely on it.
+It is only here for informational purposes.
+.Bl -bullet -width x
+.It
+The service directory created by
+.Xr s6-instance-maker 8
+has three specifics subdirectories in it:
+.Pa instance
+and
+.Pa instances ,
+which are initially empty, and
+.Pa template ,
+storing the template service directory.
+.It
+When the service is active, there is an
+.Xr s6-svscan 8
+process running on
+.Pa instance .
+.It
+.Xr s6-instance-create 8
+makes a copy of
+.Pa template
+into
+.Pa instances/ Ns Ar name ,
+and
+.Xr s6-svlink 8 Ns
+s
+.Pa instances/ Ns Ar name
+to
+.Pa instance .
+When it returns, there is an
+.Xr s6-supervise 8
+process running on
+.Pa instance/ Ns Ar name ,
+and the instance may be up or not depending on the given options.
+.It
+.Xr s6-instance-control 8
+is syntactic sugar around
+.Xr s6-svc 8
+on
+.Pa instance/ Ns Ar name .
+.It
+.Xr s6-instance-status 8
+is syntactic sugar around
+.Xr s6-svstat 8
+on
+.Pa instance/ Ns Ar name .
+.It
+.Xr s6-instance-delete 8
+is syntactic sugar around
+.Xr s6-svunlink 8
+on
+.Pa instance/ Ns Ar name .
+.It
+.Xr s6-instance-list 8
+is roughly equivalent to
+.Ql ls -1 instance .
+.El
+.Ss Notes
+This implementation of dynamic instances may seem expensive: it
+creates one
+.Xr s6-svscan 8
+process per instanced service, and one
+.Xr s6-supervise 8
+process per instance.
+However, remember that these processes use very little private memory,
+so having additional copies of them is far less expensive than it
+looks.
+It's really a convenient way to implement the feature by reusing
+existing code.
+.Sh SEE ALSO
+.Xr s6-instance-control 8 ,
+.Xr s6-instance-create 8 ,
+.Xr s6-instance-delete 8 ,
+.Xr s6-instance-list 8 ,
+.Xr s6-instance-maker 8 ,
+.Xr s6-instance-status 8
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man7/s6-libftrig.7 b/mdoc/man7/s6-libftrig.7
--- a/mdoc/man7/s6-libftrig.7	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man7/s6-libftrig.7	2023-04-16 04:52:39.111496467 -0300
@@ -0,0 +1,233 @@
+.Dd September 29, 2021
+.Dt S6-LIBFTRIG 7
+.Os
+.Sh NAME
+.Nm s6-libftrig
+.Nd portable Unix C programming interface allowing a process
+.Po
+the
+.Em subscriber
+or
+.Em listener
+.Pc
+to be instantly notified when another process
+.Po
+the
+.Em notifier
+or
+.Em writer
+.Pc
+signals an event
+.Sh DESCRIPTION
+.Ss What is notification?
+.Sy Notification vs. polling
+.Pp
+Process A is
+.Em notified
+of an event E when it gets a instant notice that event E has happened;
+the notice may disrupt A's execution flow.
+Notification is the opposite of
+.Em polling ,
+where A has to periodically (every T milliseconds) check whether E
+happened and has no other way to be informed of it.
+.Pp
+Polling is generally considered bad practice - and is inferior to
+notification in practically every case - for three reasons:
+.Bl -bullet -width x
+.It
+Reaction time.
+When event E happens, process A does not know it instantly.
+It will only learn of E, and be able to react to it, when it
+explicitly checks for E; and if E happened right after A performed the
+check, this can take as long as T milliseconds
+.Po the
+.Em polling period
+.Pc .
+Polling processes have reaction delays due to the polling periods.
+.It
+Resource consumption.
+Even if
+.Em no
+event ever happens, process A will still wake up needlessly every T
+milliseconds.
+This might not seem like a problem, but it is a serious one in
+energy-critical environments.
+Polling processes use more CPU time than is necessary and are not
+energy-friendly.
+.It
+Conflict between the two above reasons.
+The longer the polling period, the more energy-friendly the process,
+but the longer the reaction time.
+The shorter the polling period, the shorter the reaction time, but the
+more resource-consuming the process.
+A delicate balance has to be found, and acceptable behaviour is
+different in every case, so there's no general rule of optimization.
+.El
+.Pp
+Notification, on the other hand, is generally optimal: reaction time
+is zero, and resource consumption is minimal - a process can sleep as
+soon as it's not handling an event, and only wake up when needed.
+.Pp
+Of course, the problem of notification is that it's often more
+difficult to implement.
+Notification frameworks are generally more complex, involving lots of
+asynchronism; polling is widely used because it's easy[1].
+.Pp
+.Sy Notifications and Unix
+.Pp
+Unix provides several frameworks so that a process B (or the kernel)
+can notify process A.
+.Bl -bullet -width x
+.It
+Signals.
+The simplest Unix notification mechanism.
+Sending events amounts to a
+.Xr kill 2
+call, and receiving events amounts to installing a signal handler
+(preferably using a self-pipe[2] if mixing signals with an event
+loop).
+Unfortunately, Unix signals, even the more recent and powerful
+real-time POSIX signals, have important limitations when it's about
+generic notification:
+.Bl -bullet -width x
+.It
+Non-root processes can only send signals to a very restricted and
+implementation-dependent set of processes (roughly, processes with the
+same UID).
+This is a problem when designing secure programs that make use of Unix
+privilege separation.
+.It
+You need to know the PID of a process to send it signals.
+This is generally impractical; process management systems that do not
+use supervisor processes have to do exactly that, and they resort to
+unreliable, ugly hacks (.pid files) to track down process PIDs.
+.El
+.It
+BSD-style IPCs, i.e. file descriptors to perform
+.Xr select 2 /
+.Xr poll 2
+system calls on, in an
+.Em asynchronous event loop .
+This mechanism is very widely used, and rightly so, because it's
+extremely generic and works in every ordinary situation; you have to
+be doing very specific stuff[3] to reach its limits.
+If process A is reading on fd
+.Va f ,
+it is notified every time another process makes
+.Va f
+readable - for instance by writing a byte to the other end if
+.Va f
+is the reading end of a pipe.
+And indeed, this is how
+.Nm
+works internally; but
+.Nm
+is needed because direct use of BSD-style IPCs also has limitations:
+.Bl -bullet -width x
+.It
+Anonymous pipes are the simplest and most common BSD-style IPC.
+If there is a pipe from process B to process A, then B can notify A by
+writing to the pipe.
+The limitation is that A and B must have a common ancestor that
+created the pipe; two unrelated processes cannot communicate this way.
+.It
+Sockets are a good many-to-one notification system: once a server is
+up, it can be notified by any client, and notify all its clients.
+The limitation of sockets is that the server must be up before the
+client, which prevents us from using them in a general notification
+scheme.
+.El
+.It
+System V IPCs, i.e. message queues and semaphores.
+The interfaces to those IPCs are quite specific and can't mix with
+select/poll loops, that's why nobody in their right mind uses them.
+.El
+.Pp
+.Sy What we want
+.Pp
+We need a general framework to:
+.Bl -bullet -width x
+.It
+allow an event-generating process to broadcast notifications to every
+process that asked for one, without having to know their PIDs;
+.It
+allow a process to subscribe to a
+.Dq notification channel
+and be instantly, asynchronously notified when an event occurs on this
+channel.
+.El
+.Pp
+This requires a many-to-many approach that Unix does not provide
+natively, and that is what
+.Nm
+does.
+.Pp
+.Sy That's what a bus is for. D-Bus already does all this.
+.Pp
+Yes, a bus is a good many-to-many notification mechanism
+indeed.
+However, a Unix bus can only be implemented via a daemon - you need a
+long-running process, i.e. a
+.Em service ,
+to implement a bus.
+And s6 is a
+.Em supervision suite ,
+i.e. a set of programs designed to manage services; we would like to
+be able to use notifications in the supervision suite, to be able to
+wait for a service to be up or down...
+.Em without
+relying on a particular service to be up.
+.Nm
+provides a notification mechanism that
+.Em does not need
+a bus service to be up; that's its main advantage over a bus.
+.Pp
+If you are not concerned with supervision and can depend on a bus
+service, though, then yes, by all means, use a bus for your
+notification needs.
+There is a skabus[4] project in the making, which aims to be simpler,
+smaller and more maintainable than D-Bus.
+.Ss How to use Nm
+.Nm
+is really a part of libs6: all the functions are implemented
+in the
+.Pa libs6.a
+archive, or the
+.Pa libs6.so
+dynamic shared object.
+However, the interfaces are different for notifiers and listeners:
+.Bl -bullet -width x
+.It
+Notifiers use the
+.Xr s6-ftrigw 7
+interface.
+.It
+Listeners use the
+.Xr s6-ftrigr 7
+interface.
+.El
+.Sh SEE ALSO
+.Xr s6-accessrules 7 ,
+.Xr s6-fdholder 7 ,
+.Xr s6-ftrigr 7 ,
+.Xr s6-ftrigw 7 ,
+.Xr s6-libs6 7 ,
+.Xr s6-s6lock 7
+.Pp
+[1]
+.Lk https://lib.store.yahoo.net/lib/demotivators/mediocritydemotivationalposter.jpg
+.Pp
+[2]
+.Lk https://skarnet.org/software/skalibs/libstddjb/selfpipe.html
+.Pp
+[3]
+.Lk http://www.kegel.com/c10k.html
+.Pp
+[4]
+.Lk https://skarnet.org/software/skabus/
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/ftrig.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man7/s6-libs6.7 b/mdoc/man7/s6-libs6.7
--- a/mdoc/man7/s6-libs6.7	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man7/s6-libs6.7	2023-04-16 04:52:39.111496467 -0300
@@ -0,0 +1,89 @@
+.Dd September 29, 2021
+.Dt S6-LIBS6 7
+.Os
+.Sh NAME
+.Nm s6-libs6
+.Nd collection of utility C interfaces, used in the s6 executables
+.Sh DESCRIPTION
+.Ss Compiling
+Make sure the s6 headers, as well as the skalibs headers, are visible
+in your header search path.
+.Pp
+Use
+.Ql #include <s6/s6.h> .
+.Ss Linking
+Make sure the s6 libraries, as well as the skalibs libraries, are
+visible in your library search path.
+.Pp
+Link against
+.Ql -ls6
+and
+.Ql -lskarnet .
+If you're using socket functions (which is the case with
+.Xr s6-ftrigr 7 ,
+for instance), add
+.Ql `cat $sysdeps/socket.lib`
+to your command line.
+If you're using timed functions involving TAI timestamps (which is
+also the case with
+.Xr s6-ftrigr 7 ,
+for instance), add
+.Ql `cat $sysdeps/sysclock.lib` .
+.Qq $sysdeps
+stands for your skalibs sysdeps directory.
+.Ss Programming
+The
+.Pa s6/s6.h
+header is actually a concatenation of other headers: libs6 is
+separated into several modules, each of them with its own header.
+.Bl -bullet -width x
+.It
+The
+.Pa s6/accessrules.h
+header provides functions to check credentials against configuration
+files.
+Refer to
+.Xr s6-accessrules 7 .
+.It
+The
+.Pa s6/ftrigr.h
+header provides functions to subscribe to
+.Xr s6-fifodir 7 Ns s
+and be notified of events.
+Refer to
+.Xr s6-ftrigr 7 .
+.It
+The
+.Pa s6/ftrigw.h
+header provides functions to manage
+.Xr s6-fifodir 7 Ns s
+and send notifications to them.
+Refer to
+.Xr s6-ftrigw 7 .
+.It
+The
+.Pa s6/s6lock.h
+header provides functions to acquire locks with a timeout.
+Refer to
+.Xr s6-s6lock 7 .
+.It
+The
+.Pa s6/s6-fdholder.h
+header provides functions to communicate with an
+.Xr s6-fdholderd 8
+server and exchange file descriptors with it.
+Refer to
+.Xr s6-fdholder 7 .
+.El
+.Sh SEE ALSO
+.Xr s6-accessrules 7 ,
+.Xr s6-fdholder 7 ,
+.Xr s6-ftrigr 7 ,
+.Xr s6-ftrigw 7 ,
+.Xr s6-s6lock 7
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/libs6/
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man7/s6-local-service.7 b/mdoc/man7/s6-local-service.7
--- a/mdoc/man7/s6-local-service.7	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man7/s6-local-service.7	2023-04-16 04:52:39.111496467 -0300
@@ -0,0 +1,142 @@
+.Dd September 29, 2021
+.Dt S6-LOCAL-SERVICE 7
+.Os
+.Sh NAME
+.Nm s6-local-service
+.Nd daemon that listens to incoming connections on a Unix domain socket
+.Sh DESCRIPTION
+Clients of the service are programs connecting to a Unix domain socket: the
+daemon performs operations on their behalf.
+.Pp
+The service is called
+.Em local
+because it is not accessible to clients from the network.
+.Pp
+A widely known example of a local service is the
+.Ql syslogd
+daemon.
+On most implementations, it listens to the
+.Pa /dev/log
+socket.
+Its clients connect to it and send their logs via the socket.
+The
+.Fn openlog
+function is just a wrapper arround the
+.Fn connect
+system call, the
+.Fn syslog
+function a wrapper around
+.Fn write ,
+and so on.
+.Ss Benefits
+.Sy Privileges
+.Pp
+The most important benefit of a local service is that it permits
+.Sy controlled privilege gains without using setuid programs .
+The daemon is run as user S; a client running as user C and connecting
+to the daemon asks it to perform operations: those will be done as
+user S.
+.Pp
+Standard Unix permissions on the listening socket can be used to
+implement some basic access control: to restrict access to clients
+belonging to group G, change the socket to user S and group G, and
+give it 0420 permissions.
+This is functionally equivalent to the basic access control for setuid
+programs: a program having user S, group G and permissions 4750 will
+be executable by group G and run with S rights.
+.Pp
+But modern systems implement the
+.Fn getpeereid
+system call or library function.
+This function allows the server to know the client's credentials: so
+fine-grained access control is possible.
+On those systems,
+.Sy local services can do as much authentication as setuid programs, in a much more controlled environment .
+.Sy Fd-passing
+The most obvious difference between a local service and a network
+service is that a local service does not serve network clients.
+But local services have another nice perk: while network services
+usually only provide you with a single channel (a TCP or UDP socket)
+of communication between the client and the server, forcing you to
+multiplex your data into that channel, local services allow you to
+have as many communication channels as you want.
+.Pp
+(The SCTP transport layer provides a way for network services to use
+several communication channels.
+Unfortunately, it is not widely deployed yet, and a lot of network
+services still depend on TCP.)
+.Pp
+The
+.Em fd-passing
+mechanism is Unix domain socket black magic that allows one peer of
+the socket to send open file descriptors to the other peer.
+So, if the server opens a pipe and sends one end of this pipe to a
+client via this mechanism, there is effectively a socket
+.Em and
+a pipe between the client and the server.
+.Ss UCSPI
+The UCSPI[1] protocol is an easy way of abstracting clients and servers
+from the network.
+A server written as a UCSPI server, just as it can be run under inetd
+or
+.Xr s6-tcpserver 8 ,
+can be run under
+.Xr s6-ipcserver 8 :
+choose a socket location and you have a local service.
+.Pp
+Fine-grained access control can be added by inserting
+.Xr s6-ipcserver-access 8
+in your server command line after
+.Xr s6-ipcserver 8 .
+.Pp
+A client written as an UCSPI client, i.e. assuming it has descriptor 6
+(resp. 7) open and reading from (resp. writing to) the server socket,
+can be run under
+.Xr s6-ipcclient 8 .
+.Ss Use in skarnet.org software
+skarnet.org libraries often use a separate process to handle
+asynchronicity and background work in a way that's invisible to the
+user.
+Among them are:
+.Bl -bullet -width x
+.It
+.Xr s6-ftrigrd 8 ,
+managing the reception of notifications and only waking up the client
+process when the notification pattern matches a regular expression.
+.It
+.Xr s6lockd 8 ,
+handling time-constrained lock acquisition on client behalf.
+.It
+skadnsd[2],
+performing asynchronous DNS queries and only waking up the client
+process when an answer arrives.
+.El
+.Pp
+Those processes are usually spawned from a client, via the
+corresponding
+.Ql *_startf*
+library call.
+But they can also be spawned from a
+.Xr s6-ipcserver 8
+program in a local service configuration.
+In both cases, they need an additional control channel to be passed
+from the server to the client: the main socket is used for synchronous
+commands from the client to the server and their answers, whereas the
+additional channel, which is now implemented as a socket as well (but
+created by the server on-demand and not bound to a local path), is
+used for asynchronous notifications from the server to the client.
+The fd-passing mechanism is used to transfer the additional channel
+from the server to the client.
+.Sh SEE ALSO
+.Xr s6-tcpserver 8
+[1]
+.Lk https://cr.yp.to/proto/ucspi.txt
+.Pp
+[2]
+.Lk https://skarnet.org/software/s6-dns/skadns/skadnsd.html
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/localservice.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man7/s6-notifywhenup.7 b/mdoc/man7/s6-notifywhenup.7
--- a/mdoc/man7/s6-notifywhenup.7	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man7/s6-notifywhenup.7	2023-04-16 04:52:39.111496467 -0300
@@ -0,0 +1,272 @@
+.Dd September 29, 2021
+.Dt S6-NOTIFYWHENUP 7
+.Os
+.Sh NAME
+.Nm s6-notifywhenup
+.Nd s6 service startup notifications
+.Sh DESCRIPTION
+It is easy for a process supervision suite to know when a service that
+was up is now down: the long-lived process implementing the service is
+dead.
+The supervisor, running as the daemon's parent, is instantly notified
+via a SIGCHLD.
+When it happens,
+.Xr s6-supervise 8
+sends a
+.Sq d
+event to its
+.Pa ./event
+.Xr s6-fifodir 7 ,
+so every subscriber knows that the service is down.
+All is well.
+.Pp
+It is much trickier for a process supervision suite to know when a
+service that was down is now up.
+The supervisor forks and execs the daemon, and knows when the exec has
+succeeded; but after that point, it's all up to the daemon
+itself.
+Some daemons do a lot of initialization work before they're actually
+ready to serve, and it is impossible for the supervisor to know
+exactly when the service is really ready.
+.Xr s6-supervise 8
+sends a
+.Sq u
+event to its
+.Pa ./event
+.Xr s6-fifodir 7
+when it successfully spawns the daemon, but any subscriber reacting to
+.Sq u
+is subject to a race condition - the service provided by the daemon
+may not be ready yet.
+.Pp
+Reliable startup notifications need support from the daemons
+themselves.
+Daemons should do two things to signal the outside world that they are
+ready:
+.Bl -enum -width -x
+.It
+Update a state file, so other processes can get a snapshot of the
+daemon's state.
+.It
+Send an event to processes waiting for a state change.
+.El
+.Pp
+This is complex to implement in every single daemon, so s6 provides
+tools to make it easier for daemon authors, without any need to link
+against the s6 library or use any s6-specific construct: daemons can
+simply write a line to a file descriptor of their choice, then close
+that file descriptor, when they're ready to serve.
+This is a generic mechanism that some daemons already implement.
+.Pp
+s6 supports that mechanism natively: when the service directory for
+the daemon contains a valid
+.Pa notification-fd
+file, the daemon's supervisor, i.e. the
+.Xr s6-supervise 8
+program, will properly catch the daemon's message, update the status file
+.Sm off
+.Po
+.Pa supervise/status
+.Pc ,
+.Sm on
+then notify all the subscribers with a
+.Sq U
+event, meaning that the service is now up and ready.
+.Pp
+This method should really be implemented in every long-running program
+providing a service.
+When it is not the case, it's impossible to provide reliable startup
+notifications, and subscribers should then be content with the
+unreliable
+.Sq u
+events provided by
+.Xr s6-supervise 8 .
+.Pp
+Unfortunately, a lot of long-running programs do not offer that
+functionality; instead, they provide a way to poll them, an external
+program that runs and checks whether the service is ready.
+This is a bad mechanism, for several reasons.
+Nevertheless, until all daemons are patched to notify their own
+readiness, s6 provides a way to run such a check program to poll for
+readiness, and route its result into the s6 notification system:
+.Xr s6-notifyoncheck 8 .
+.Ss How to use a check program with s6 (i.e. readiness checking via polling)
+Let's say you have a daemon
+.Pa foo ,
+started under s6 via a
+.Pa /run/service/foo
+service directory, and that comes with a
+.Pa foo-check
+program that exhibits different behaviours when
+.Pa foo
+is ready and when it is not.
+.Pp
+Create an executable script
+.Pa /run/service/foo/data/check
+that calls
+.Pa foo-check .
+Make sure this script exits 0 when
+.Pa foo
+is ready and nonzero when it's not.
+.Pp
+In your
+.Pa /run/service/foo/run
+script that starts
+.Pa foo ,
+instead of executing into
+.Pa foo ,
+execute into
+.Ql s6-notifyoncheck foo .
+Read the
+.Xr s6-notifyoncheck 8
+page if you need to give it options to tune the polling.
+.Pp
+Run:
+.Dl echo 3 > /run/service/foo/notification-fd
+.Pp
+If file descriptor 3 is already open when your run script executes
+.Pa foo ,
+replace
+.Ql 3
+with a file descriptor you
+.Em know
+is not already open.
+.Pp
+That's it.
+.Pp
+Your check script will be automatically invoked by
+.Xr s6-notifyoncheck 8 ,
+until it succeeds.
+.Pp
+.Xr s6-notifyoncheck 8 ,
+will send the readiness notification to the file descriptor given in
+the
+.Pa notification-fd
+file.
+.Pp
+.Xr s6-supervise 8
+will receive it and will mark
+.Pa foo
+as ready.
+.Ss How to design a daemon so it uses the s6 mechanism without resorting to polling (i.e. readiness notification)
+The
+.Xr s6-notifyoncheck 8
+mechanism was made to accommodate daemons that provide a check program
+but do not notify readiness themselves; it works, but is
+suboptimal.
+If you are writing the
+.Pa foo
+daemon, here is how you can make things better:
+.Bl -bullet -width x
+.It
+Readiness notification should be optional, so you should guard all the
+following with a run-time option to
+.Pa foo .
+.It
+Assume a file descriptor other than 0, 1 or 2 is going to be open.
+You can hardcode 3 (or 4); or you can make it configurable via a
+command line option.
+See for instance the
+.Fl D Ar notif
+option to the mdevd[1] program.
+It really doesn't matter what this
+number is; the important thing is that your daemon knows that this fd
+is already open, and is not using it for another purpose.
+.It
+Do nothing with this file descriptor until your daemon is ready.
+.It
+When your daemon is ready, write a newline to this file descriptor.
+.Bl -bullet -width x
+.It
+If you like, you may write other data before the newline, just in case
+it is printed to the terminal.
+It is not necessary, and it is best to keep that data short.
+If the line is read by
+.Xr s6-supervise 8 ,
+it will be entirely ignored; only the newline is important.
+.El
+.It
+Then close that file descriptor.
+.El
+.Pp
+The user who then makes
+.Pa foo
+run under s6 just has to do the following:
+.Bl -bullet -width x
+.It
+Write
+.Ql 3 ,
+or the file descriptor the
+.Pa foo
+daemon uses to notify readiness, to the
+.Pa /run/service/foo/notification-fd
+file.
+.It
+In the
+.Pa /run/service/foo/run
+script, invoke
+.Pa foo
+with the option that activates the readiness notification.
+If
+.Pa foo
+makes the notification fd configurable, the user needs to make sure
+that the number that is given to this option is the same as the number
+that is written in the
+.Pa notification-fd
+file.
+.It
+And that is all.
+.Sy \&Do not
+use
+.Xr s6-notifyoncheck 8
+in this case, because you do not need to poll to know whether
+.Pa foo
+is ready; instead,
+.Pa foo
+will directly communicate its readiness to
+.Xr s6-supervise 8 ,
+and that is a much more efficient mechanism.
+.El
+.Ss What does s6-supervise do with this readiness information?
+.Xr s6-supervise 8
+maintains a readiness state for other programs to read.
+You can check for it, for instance, via the
+.Xr s6-svstat 8
+program.
+.Pp
+.Xr s6-supervise 8
+also broadcasts the readiness event to programs that are waiting for
+it - for instance the
+.Xr s6-svwait 8
+program.
+This can be used to make sure that other programs only start when the
+daemon is ready.
+For instance, the s6-rc[2] service manager uses that mechanism to
+bring sets of services up or down: a service starts as soon as all its
+dependencies are ready, but never earlier.
+.Sh SEE ALSO
+.Xr s6-notifyoncheck 8 ,
+.Xr s6-permafailon 8 ,
+.Xr s6-supervise 8 ,
+.Xr s6-svc 8 ,
+.Xr s6-svdt 8 ,
+.Xr s6-svdt-clear 8 ,
+.Xr s6-svlisten 8 ,
+.Xr s6-svlisten1 8 ,
+.Xr s6-svok 8 ,
+.Xr s6-svscan 8 ,
+.Xr s6-svscanctl 8 ,
+.Xr s6-svstat 8 ,
+.Xr s6-svwait 8
+.Pp
+[1]
+.Lk https://skarnet.org/software/mdevd/mdevd.html
+.Pp
+[2]
+.Lk https://skarnet.org/software/s6-rc/
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/notifywhenup.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man7/s6-overview.7 b/mdoc/man7/s6-overview.7
--- a/mdoc/man7/s6-overview.7	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man7/s6-overview.7	2023-04-16 04:52:39.112496467 -0300
@@ -0,0 +1,621 @@
+.Dd January 15, 2023
+.Dt S6-OVERVIEW 7
+.Os
+.Sh NAME
+.Nm s6-overview
+.Nd an overview of s6
+.Sh DESCRIPTION
+s6 is a collection of utilities revolving around process supervision
+and management, logging, and system initialization.
+This page is a high-level description of the different parts of s6.
+.Ss Process supervision
+At its core, s6 is a
+.Em process supervision suite ,
+like its ancestor daemontools[1] and its close cousin runit[2].
+.Pp
+.Sy Concept
+.br
+The concept of process supervision comes from several observations:
+.Bl -bullet -width x
+.It
+Unix systems, even minimalistic ones, need to run
+.Em long-lived processes ,
+aka
+.Em daemons .
+That is one of the core design principles of Unix: one service \(-> one daemon.
+.It
+Daemons can die unexpectedly.
+Maybe they are missing a vital resource and cannot handle a certain
+failure; maybe they tripped on a bug; maybe a misconfigured
+administration program killed them; maybe the kernel killed them.
+Processes are fragile, but daemons are vital to a Unix system: a
+fundamental discrepancy that needs to be solved.
+.It
+Automatically restarting daemons when they die is generally a good
+thing.
+In any case, sysadmin intervention is necessary, but at least the
+daemon is providing service, or trying to, until the sysadmin can log
+in and investigate the underlying problem.
+.It
+Ad-hoc shell scripts that restart daemons
+.Em suck ,
+for several reasons that would each justify their own page.
+The difficulty of keeping track of the PID, explained below, is one of
+those reasons.
+.It
+It is sometimes necessary to send signals to a daemon.
+To kill it, of course, but also to make it read its config file again,
+for instance; signalling a daemon is a natural and very common way of
+sending it simple commands.
+.It
+Generally, to send a signal to a daemon, you need to know its PID.
+Without a supervision suite, knowing the proper PID is hard.
+Most non-supervision systems use a hack known as
+.Em .pid files ,
+i.e. the script that starts the daemon stores its PID into a file, and
+other scripts read that file.
+This is a bad mechanism for several reasons, and the case against .pid
+files would also justify its own page; the most important drawback
+of .pid files is that they create race conditions and management
+scripts may kill the wrong process.
+.It
+Non-supervision systems provide scripts to start and stop daemons, but
+those scripts may fail at boot time even though they work when run
+manually, and vice versa.
+If a sysadmin logs in and runs the script to restart a daemon that has
+died, the result might not be the same as if the whole system had been
+rebooted, and the daemon may exhibit strange behaviours!
+This is because the boot-time environment and the restart-time
+environment are not the same when the script is run; and a
+non-supervision system just cannot ensure reproducibility of the
+environment.
+This is a core problem of non-supervision systems: countless bugs have
+been falsely reported because of simple environment differences or
+configuration errors, countless man-hours have been wasted to try and
+understand what was going on.
+.El
+.Pp
+A process supervision system organizes the process hierarchy in a
+radically different way.
+.Bl -bullet -width x
+.It
+A process supervision system starts an independent hierarchy of
+processes at boot time, called a
+.Em supervision tree .
+This supervision tree never dies: when one of its components dies, it
+is restarted automatically.
+To ensure availability of the supervision tree at all times, it should
+be rooted in process 1, which cannot die.
+.It
+A daemon is never started, either manually or in a script, as a scion
+of the script that starts it.
+Instead, to start a daemon, you configure a specific directory which
+contains all the information about your daemon; then you send a
+command to the supervision tree.
+The supervision tree will start the daemon as a leaf.
+.Bf Em
+In a process supervision system, daemons are always spawned by the
+supervision tree, and never by an admin's shell.
+.Ef
+.It
+The parent of your daemon is a
+.Em supervisor .
+Since your daemon is its direct child,
+.Sm off
+.Bf Em
+the supervisor always knows the correct PID of your daemon
+.Ef
+\&.
+.Sm on
+.It
+The supervisor watches your daemon and can restart it when it dies,
+automatically.
+.It
+The supervision tree always has the same environment, so starting
+conditions are reproducible.
+Your daemon will always be started with the same environment, whether
+it is at boot time via init scripts or for the 100th automatic - or
+manual - restart.
+.It
+To send signals to your daemon, you send a command to its supervisor,
+which will then send a signal to the daemon on your behalf.
+Your daemon is identified by the directory containing its information,
+which is stable, instead of by its PID, which is not stable; the
+supervisor maintains the correct association without a race condition
+or the other problems of .pid files.
+.El
+.Pp
+.Sy Implementation
+.br
+s6 is a straightforward implementation of those concepts.
+.Bl -bullet -width x
+.It
+The
+.Xr s6-svscan 8
+and
+.Xr s6-supervise 8
+programs are the components of the
+.Em supervision tree .
+They are long-lived programs.
+.Bl -bullet -width x
+.It
+.Xr s6-supervise 8
+is a daemon's
+.Em supervisor ,
+its direct parent.
+For every long-lived process on a system, there is a corresponding
+.Xr s6-supervise 8
+process watching it.
+This is okay, because every instance of
+.Xr s6-supervise 8
+uses very few resources.
+.It
+.Xr s6-svscan 8
+is, in a manner of speaking, a supervisor for the supervisors.
+It watches and maintains a collection of
+.Xr s6-supervise 8
+processes: it is the branch of the supervision tree that all
+supervisors are stemming from.
+It can be run and supervised by your regular init process, or it can
+run as process 1 itself; refer to
+.Xr s6-svscan-not-as-process-1 7
+an
+.Xr s6-svscan-as-process-1 7 .
+Running
+.Xr s6-svscan 8
+as process 1 requires some effort from the user, because of the
+inherent non-portability of init processes; the s6-linux-init
+package[3] automates that effort and allows users to run s6 as an init
+replacement.
+.It
+The configuration of a daemon to be supervised by
+.Xr s6-supervise 8
+is done via an
+.Xr s6-service-directory 7 .
+.It
+The place to gather all service directories to be watched by an
+.Xr s6-svscan 8
+instance is called an
+.Xr s6-scan-directory 7 .
+.El
+.It
+The command that controls a single supervisor, and allows you to send
+signals to a daemon, is
+.Xr s6-svc 8 .
+It is a short-lived program.
+.It
+The command that controls a set of supervisors, and allows you to
+start and stop supervision trees, is
+.Xr s6-svscanctl 8 .
+It is a short-lived program.
+.El
+.Pp
+These four programs,
+.Xr s6-svscan 8 ,
+.Xr s6-supervise 8 ,
+.Xr s6-svscanctl 8
+and
+.Xr s6-svc 8 ,
+are the very core of s6.
+Technically, once you have them, you have a functional s6
+installation, and the other utilities are just a bonus.
+.Pp
+.Sy Practical usage
+.br
+To use s6's supervision features, you need to perform the following
+steps:
+.Bl -enum -width x
+.It
+For every daemon you potentially want supervised, write an
+.Xr s6-service-directory 7 .
+Make sure that your daemon does not background itself when started in
+the
+.Pa ./run
+script!
+Auto-backgrounding is a historical hack that was implemented when
+supervision suites did not exist; since you're using a supervision
+suite, auto-backgrounding is unnecessary and in this case detrimental.
+.It
+Write a single
+.Xr s6-scan-directory 7
+for the set of daemons you want to actually run.
+This set can be modified at run time.
+.It
+At some point in your initialization scripts, run
+.Xr s6-svscan 7
+on the scan directory.
+This will start the supervision tree, including your set of daemons.
+The exact way of running
+.Xr s6-svscan 8
+depends on your system: it is not quite the same when you want to run
+it as process 1 on a real machine, or under another init on a real
+machine, or as process 1 in a Docker[4] container, or in another
+context entirely.
+.It
+Alternatively, you can start
+.Xr s6-svscan 8
+on an empty scan directory, then populate it step by step and send an
+update command to
+.Xr s6-svscan 8
+via
+.Xr s6-svscanctl 8
+whenever the supervision tree should pick up the differences and start
+the services you added.
+.It
+That's it, your services are running.
+To control them manually, you can use the
+.Xr s6-svc 8
+command.
+.It
+At the end of the system's lifetime, you can use
+.Xr s6-svscanctl 8
+to bring down the supervision tree.
+.El
+.Ss Service-specific logging
+.Xr s6-svscan 8
+can monitor a supervision tree, but it can also do one more thing.
+It can ensure that a daemon's log, i.e. what the daemon outputs to its
+stdout (or stderr if you redirect it), gets processed by another,
+supervised, long-lived process, called a
+.Em logger ;
+and it can make sure that the logs are never lost between the daemon
+and the logger - even if the daemon dies, even if the logger dies.
+.Pp
+If your daemon is outputting messages, you have a decision to make
+about where to send them.
+.Bl -bullet -width x
+.It
+You can do as non-supervision systems do, and send the messages to
+syslog.
+It's entirely possible with a supervision system too.
+However, like auto-backgrounding, syslog is a historical mechanism
+that predates supervision suites, and is technically inferior; it is
+recommended that you do not use it whenever you can avoid it.
+.It
+You can send them to the daemon's stdout/stderr and do nothing special about it.
+The logs will then be sent to
+.Xr s6-svscan 8 Ap
+s stdout/stderr; what mechanism will read them depends on how you
+started
+.Xr s6-svscan 8 .
+.It
+You can use
+.Xr s6-svscan 8 Ap
+s service-specific logging mechanism and dedicate a logger process to
+your daemon's messages.
+.El
+.Pp
+s6 provides you with a long-lived process to use as a logger:
+.Xr s6-log 8 .
+It will store your logs in one (or more) specific directory of your
+choice, and rotate them automatically.
+.Ss Helpers for run scripts
+Creating a working
+.Xr s6-service-directory 7 ,
+and especially a good
+.Em run script ,
+is the most important part of the work when adapting a daemon to a
+supervision framework.
+.Pp
+If you can find your daemon's invocation script on a non-supervision
+system, for instance a System V-style init script, you can see the
+exact options that the daemon is being run with: environment
+variables, uid and gid, open descriptors, etc.
+This is what you need to replicate in your run script.
+.Pp
+.Po
+Do not replicate the auto-backgrounding, or things like
+start-stop-daemon[5] invocation: start-stop-daemon and its friends are
+hideous and kludgy attempts to work around the lack of proper
+supervision mechanisms.
+Now that you have s6, you should remove them from your system, throw
+them into a bonfire, and dance and laugh while they burn.
+Generally speaking, as a system administrator you want daemons that
+have been designed following the principles described in [6], or at
+least you want to use the command-line options that make them behave
+in such a way.
+.Pc
+.Pp
+The vast majority of the tools provided by s6 are meant to be used in
+run scripts: they help you control the process state and environment
+in your script before it executes into your daemon.
+Or, sometimes, they are daemons themselves, designed to be supervised.
+.Pp
+s6, like other skarnet.org
+software[7], makes heavy use of chain loading[8], also known as
+.Dq Bernstein chaining :
+a lot of s6 tools will perform some action that changes the process
+state, then execute into the rest of their command line.
+This allows the user to change the process state in a very flexible
+way, by combining the right components in the right order.
+Very often, a run script can be reduced to a single command line
+\(em
+likely a long one, but still a single one.
+.Po
+That is the main reason why using the execline[9] language to write
+run scripts is recommended: execline makes it natural to handle long
+command lines made of massive amounts of chain loading.
+This is by no means mandatory, though: a run script can be any
+executable file you want, provided that running it eventually results
+in a long-lived process with the same PID.
+.Pc
+.Pp
+Some examples of s6 programs meant to be used in run scripts:
+.Bl -bullet -width x
+.It
+The
+.Xr s6-log 8
+program is a long-lived process.
+It is meant to be executed into by a
+.Pa ./log/run
+script: it will be supervised, and will process what it reads on its
+stdin
+.Po
+i.e. the output of the
+.Pa ./run
+daemon
+.Pc .
+.It
+The
+.Xr s6-envdir 8
+program is a short-lived process that will update its current
+environment according to what it reads in a given directory, then
+execute into the rest of its command line.
+It is meant to be used in a run script to adjust the
+environment with which the final daemon will be executed into.
+.It
+Similarly, the
+.Xr s6-softlimit 8
+program adjusts its resource limits, then executes into the rest of
+its command line: it is meant to set the resources the final daemon
+will have access to.
+.It
+The
+.Xr s6-applyuidgid 8
+program, part of the
+.Ql s6-*uidgid
+family, drops root privileges before executing into the rest of its
+command line: it is meant to be used in run scripts that need root
+privileges when starting but do not need it for the execution of the
+long-lived process.
+.It
+.Xr s6-ipcserverd 8
+is a daemon that listens to a Unix socket and spawns a program for
+every connection.
+It is meant to be supervised, so it should be used in a run script,
+and it's also meant to be a flexible super-server that you can use for
+different applications: so it is a building block that may appear in
+several of your run scripts defining
+.Xr s6-local-service 7 Ns
+s.
+.El
+.Ss Readiness notification and dependency management
+Now that you have a supervision tree, and long-lived processes running
+supervised, you may want to introduce dependencies between them: do not
+perform an action
+.Po
+e.g. start
+.Po
+with
+.Ql s6-svc -u
+.Pc
+the Web server connecting to a database
+.Pc
+before a given daemon is up and running
+.Po
+e.g. the database server
+.Pc .
+s6 provides tools to do that:
+.Bl -bullet -width x
+.It
+The
+.Xr s6-svwait 8 ,
+.Xr s6-svlisten1 8
+and
+.Xr s6-svlisten 8
+programs will wait until a set of daemons is up, ready, down
+.Po
+as soon as the
+.Pa ./run
+process dies
+.Pc
+or really down
+.Po
+when the
+.Pa ./finish
+process has also died
+.Pc .
+.It
+Unfortunately, a daemon being
+.Em up
+does not mean that it is
+.Em ready :
+.Xr s6-notifywhenup 7
+goes into the details.
+s6 supports a simple mechanism: when a daemon wants to signal that it
+is
+.Em ready ,
+it simply writes a newline to a file descriptor of its choice, and
+.Xr s6-supervise 8
+will pick that notification up and broadcast the information to
+processes waiting for it.
+.It
+s6 also has a legacy mechanism for daemons that do not notify their
+own readiness but provide a way for an external program to check
+whether they're ready or not:
+.Xr s6-notifyoncheck 8 .
+This is polling, which is bad, but unfortunately necessary for many
+daemons as of 2019.
+.El
+.Pp
+s6 does not provide a complete dependency management framework, i.e. a
+program to automatically start (or stop) a set of services in a
+specific order - that order being automatically computed from a graph
+of dependencies between services.
+That functionality belongs to a
+.Em service manager ,
+and is implemented for instance in the s6-rc package[10].
+.Ss Fine-grained control over services
+s6 provides you with a few more tools to control and monitor your
+services.
+For instance:
+.Bl -bullet -width x
+.It
+.Xr s6-svstat 8
+gives you access to the detailed state of a service.
+.It
+.Xr s6-svperms 8
+allows you to configure what users can read that state, what users can
+send control commands to your service, and what users can be notified
+of service start/stop events.
+.It
+.Xr s6-svdt 8
+allows you to see what caused the latest deaths of a supervised
+process.
+.El
+.Pp
+These tools make s6 the most powerful and flexible of the existing
+process supervision suites.
+.Ss Additional utilities
+The other programs in the s6 package are various utilities that may be
+useful in designing servers, and more generally multi-process software.
+They can be used with or without a supervision environment, although
+it is of course recommended to have one; but they are not part of the
+core s6 functionality, and you may safely ignore them for now if you
+are just getting into the supervision world.
+.Pp
+.Sy Generic inter-process notification
+.br
+The
+.Ql s6-ftrig*
+family of programs allows notifications between unrelated processes: a
+set of processes can subscribe to a certain channel - identified by a
+directory in the filesystem - and ask to be notified of certain events
+on that channel; another set of processes can send events to the
+channel.
+.Pp
+The underlying mechanism is the same as the one used by the supervision
+tree for readiness notification, but the
+.Ql s6-ftrig*
+tools provide a more generic access to that mechanism.
+.Pp
+.Sy Helpers for designing local services
+.br
+Local services, i.e. daemons listening to a Unix domain socket, are a
+powerful and flexible mechanism, especially with modern Unix systems
+that allow client authentication.
+s6 includes tools to take advantage of that mechanism.
+.Bl -bullet -width x
+.It
+The
+.Ql s6-ipc*
+family of programs is about designing clients or servers that
+communicate over Unix domain sockets.
+.It
+The
+.Ql s6-*access*
+and
+.Xr s6-connlimit 8
+family of programs is about client access control.
+.It
+The
+.Ql s6-sudo*
+family of programs is about using a local service in order to give
+selected clients the ability to run a command line with the privileges
+of the server, without using suid programs.
+.El
+.Pp
+.Sy Keeping file descriptors open
+.br
+Sometimes you want to keep a file descriptor open, even if the program
+normally using it dies - so the program can restart and use the same
+file descriptor without losing any data.
+To do that, you need to
+.Em hold
+the descriptor in another process, i.e. that process should have it
+open but do nothing with it.
+.Pp
+.Xr s6-svscan 8 ,
+for instance, holds the pipe existing between a supervised daemon and
+its logger, so even if the daemon or the logger dies while there are
+logs in the pipe, the pipe remains open and the logs are not lost.
+.Pp
+s6 provides a mechanism to store and retrieve open file descriptors in
+a totally generic way: the
+.Ql s6-fdholder*
+family of programs.
+.Bl -bullet -width x
+.It
+The
+.Xr s6-fdholder-daemon 8
+program is a daemon
+.Po
+or, rather, executes into the
+.Xr s6-fdholderd 8
+daemon
+.Pc ,
+meant to be supervised, that will hold file descriptors on its
+clients' behalf.
+.It
+Other programs in the family, such as
+.Xr s6-fdholder-store 8 ,
+are client programs that interact with this daemon to store and
+retrieve file descriptors.
+.El
+.Pp
+Note that
+.Dq socket activation ,
+one of the main advertised benefits of the systemd[11] init system,
+sounds similar to fd-holding.
+The reality is that socket activation is a mixture of several
+different mechanisms, one of which is fd-holding; s6 allows you to
+implement the healthy parts of socket activation.
+Refer to
+.Xr s6-socket-activation 7
+for details.
+.Pp
+.Sy Other miscellaneous utilities
+.br
+This page does not list or classify every s6 tool.
+Please explore the
+.Dq Reference
+section of the main s6 page[12] for details on a specific program.
+.Sh SEE ALSO
+[1]
+.Lk https://cr.yp.to/daemontools.html
+.Pp
+[2]
+.Lk http://smarden.org/runit/
+.Pp
+[3]
+.Lk https://skarnet.org/software/s6-linux-init/
+.Pp
+[4]
+.Lk https://www.docker.com/
+.Pp
+[5]
+.Lk http://man.he.net/man8/start-stop-daemon
+.Pp
+[6]
+.Lk https://jdebp.uk/FGA/unix-daemon-design-mistakes-to-avoid.html
+.Pp
+[7]
+.Lk https://skarnet.org/software/
+.Pp
+[8]
+.Lk https://en.wikipedia.org/wiki/Chain_loading#Chain_loading_in_Unix
+.Pp
+[9]
+.Lk https://skarnet.org/software/execline/
+.Pp
+[10]
+.Lk https://skarnet.org/software/s6-rc/
+.Pp
+[11]
+.Lk https://www.freedesktop.org/wiki/Software/systemd/
+.Pp
+[12]
+.Lk https://skarnet.org/software/s6/
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man7/s6-s6lock.7 b/mdoc/man7/s6-s6lock.7
--- a/mdoc/man7/s6-s6lock.7	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man7/s6-s6lock.7	2023-04-16 04:52:39.112496467 -0300
@@ -0,0 +1,276 @@
+.Dd September 29, 2021
+.Dt S6-S6LOCK 7
+.Os
+.Sh NAME
+.Nm s6-s6lock
+.Nd C interface to timed locks
+.Sh DESCRIPTION
+Unix natively provides locks, but the locking primitives are
+synchronous, so either they are unbounded in execution time or they
+require polling.
+.Nm
+provides poll-free locks that can timeout during attempted
+acquisition.
+.Pp
+Check the
+.Pa s6/s6lock.h
+header for the prototypes.
+The functions documented here are often simplified macros, for
+instance relying on the
+.Dv STAMP
+global variable to hold the current time.
+Fully reentrant functions with more control options are usually
+available.
+.Pp
+Given the nature of the
+.Nm
+library, it makes sense to use an
+.Xr s6lockd 8
+.Xr s6-local-service 7
+concurrently accessed by several applications using such locks to gate
+shared resources.
+.Pp
+If you're not using an
+.Xr s6lockd 8
+.Xr s6-local-service 7 ,
+make sure your application is not disturbed by children it doesn't
+know it has.
+Using nonblocking waits, ignoring pids you don't know, and using a
+self-pipe[1] if your application is built around an event loop, are good
+programming practices.
+.Ss Starting and ending a session
+.Bd -literal -offset indent
+s6lock_t a = S6LOCK_ZERO ;
+tain_t deadline ;
+
+tain_now_g() ;
+tain_addsec_g(&deadline, 2)
+
+char const *path = S6LOCK_IPCPATH ;
+s6lock_start_g(&a, path, &deadline) ;
+// char const *lockdir = "/tmp/lock" ;
+// s6lock_startf_g(&a, lockdir, &deadline) ;
+.Ed
+.Pp
+.Fn s6lock_start_g
+starts a session by connecting to an
+.Xr s6lockd 8
+service listening on
+.Va path .
+The working directory is set by the administrator of the service.
+.Pp
+.Fn s6lock_startf_g
+starts a session with an
+.Xr s6lockd 8
+process as a child, using
+.Va lockdir
+as its working directory.
+.Pp
+.Va a
+is an
+.Vt s6lock_t
+structure that must be declared in the stack and initialized to
+.Dv S6LOCK_ZERO .
+If the session initialization fails, the function returns 0 and errno
+is set; else the function returns 1.
+.Pp
+If the absolute time
+.Va deadline
+is reached and the function has not returned yet, it immediately
+returns 0 with errno set to
+.Dv ETIMEDOUT .
+Only local interprocess communications are involved; unless your
+system is heavily overloaded, the function should return
+near-instantly.
+One or two seconds of delay between the current time and
+.Va deadline
+should be enough: if the function takes more than that to return, then
+there is a problem with the underlying processes.
+.Pp
+You can have more than one session open in parallel, by declaring
+several distinct
+.Vt s6lock_t
+structures and calling
+.Fn s6lock_startf_g
+.Po
+or
+.Fn s6lock_start_g
+.Pc
+more than once.
+However, one single session can handle virtually as many concurrent
+locks as your application needs, so opening several sessions is only
+useful if you need to acquire locks in various distinct lock
+directories.
+.Pp
+.Dl s6lock_end(&a) ;
+.Pp
+.Fn s6lock_end
+frees all the resources used by the session.
+The
+.Va a
+structure is then reusable for another session.
+.Ss Acquiring and releasing locks
+.Bd -literal -offset indent
+uint16_t id ;
+char const *file = "lockfile" ;
+tain_t limit ;
+tain_t deadline ;
+
+int r = s6lock_acquire_sh_g (&a, &id, file, &limit, &deadline) ;
+/* int r = s6lock_acquire_ex_g (&a, &id, file, &limit, &deadline) ; */
+r = s6lock_release_g(&a, id, &deadline) ;
+.Ed
+.Pp
+.Fn s6lock_acquire_sh_g
+instructs the
+.Xr s6lockd 8
+daemon, related to the open session represented by the
+.Va a
+handle, to try and acquire a shared lock on the
+.Va file
+file located under that daemon's working directory
+.Po
+typically
+.Pa /var/lock
+.Pc .
+.Va file
+will be interpreted as relative to the daemon's working directory even
+if it starts with a slash; however, slashes in the middle of
+.Va file
+are likely to result in an error.
+.Pp
+.Va limit
+and
+.Va deadline
+are two absolute dates.
+.Va deadline
+is a deadline for the execution of the function: if by
+.Va deadline
+the function has not returned, then it instantly returns 0 and sets
+errno to
+.Dv ETIMEDOUT .
+The function is normally near-instantaneous, so
+.Va deadline
+can be very close in the future and serves only as a protection
+against malicious servers.
+.Va limit
+is the acquisition deadline: if by
+.Va limit
+the daemon still has not been able to acquire a lock on
+.Va file ,
+then it will report a timeout to the client.
+.Pp
+The function returns 1 in case of success, or 0 if an error occurs,
+with errno set to a suitable value.
+If it succeeds, then a 16-bit number is stored into
+.Va *id ;
+this number serves as an identifier for this lock.
+.Pp
+.Fn s6lock_acquire_ex_g
+works just like
+.Fn s6lock_acquire_sh_g ,
+except that the daemon tries to acquire an exclusive lock.
+.Pp
+.Fn s6lock_release_g
+releases the lock identified by
+.Va id .
+It normally returns 1.
+It can return 0 with errno set to a suitable value if it fails.
+.Va id
+is not valid after the corresponding lock has been released.
+The function normally returns instantly, with
+.Va deadline
+as a safeguard.
+.Ss Asynchronously waiting for locks
+.Em (From now on, the functions are listed with their prototypes instead of usage examples.)
+.Bl -tag -width x
+.It Ft int Fn s6lock_fd "s6lock_t const *a"
+.Pp
+Returns a file descriptor to select on for reading.
+Do not
+.Xr read 2
+it though.
+.It Ft int Fn s6lock_update "s6lock_t *a"
+.Pp
+Call this function whenever the fd checks readability: it will update
+.Va a Ap
+s internal structures with information from the
+.Xr s6lockd 8
+daemon.
+It returns -1 if an error occurs; in case of success, it returns the
+number of identifiers for which something happened.
+.Pp
+When
+.Fn s6lock_update
+returns,
+.Ql genalloc_s(uint16_t, &a->list)
+points to an array of
+.Ql genalloc_len(uint16_t, &a->list)
+16-bit unsigned integers.
+Those integers are ids waiting to be passed to
+.Fn s6lock_check .
+.It Ft int Fn s6lock_check "s6lock_t *a" "uint16_t id" "char *what"
+.Pp
+Checks whether the lock identified by
+.Va id
+has been acquired.
+Use after a call to
+.Fn s6lock_update .
+.Bl -bullet -width x
+.It
+If an error occurred, returns -1 and sets errno.
+The error number may have been transmitted from
+.Xr s6lockd 8 .
+.It
+If the lock has not been acquired yet, returns 0.
+.It
+If the lock has been acquired, returns 1.
+.El
+.El
+.Ss Synchronously waiting for locks
+.Bl -tag -width x
+.It Ft int Fn s6lock_wait_or_g "s6lock_t *a" "uint16_t const *idlist" "unsigned int n" "tain_t const *deadline"
+.Pp
+Synchronously waits for one of the locks represented by the array
+pointed to by
+.Va idlist
+of length
+.Va n
+to be acquired.
+Returns -1 if it fails, or a nonnegative number on success, which is
+the index in
+.Va idlist
+of the acquired lock's id.
+If no result has been obtained by
+.Va deadline ,
+the function returns -1
+.Dv ETIMEDOUT .
+.It Ft int Fn s6lock_wait_and_g "s6lock_t *a" "uint16_t const *idlist" "unsigned int n" "tain_t const *deadline"
+.Pp
+Synchronously waits for all of the locks represented by the array
+pointed to by
+.Va idlist
+of length
+.Va n
+to be acquired.
+Returns -1 if it fails and 0 if it succeeds.
+If no result has been obtained by
+.Va deadline ,
+the function returns -1
+.Dv ETIMEDOUT .
+.El
+.Sh SEE ALSO
+.Xr s6-accessrules 7 ,
+.Xr s6-fdholder 7 ,
+.Xr s6-ftrigr 7 ,
+.Xr s6-ftrigw 7 ,
+.Xr s6-libs6 7
+.Pp
+[1]
+.Lk https://skarnet.org/software/skalibs/libstddjb/selfpipe.html
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/libs6/s6lock.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man7/s6-scan-directory.7 b/mdoc/man7/s6-scan-directory.7
--- a/mdoc/man7/s6-scan-directory.7	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man7/s6-scan-directory.7	2023-04-16 04:52:39.112496467 -0300
@@ -0,0 +1,176 @@
+.Dd September 29, 2021
+.Dt S6-SCAN-DIRECTORY 7
+.Os
+.Sh NAME
+.Nm s6-scan-directory
+.Nd directory containing a list of service directories, or symbolic links pointing to service directories
+.Sh DESCRIPTION
+A
+.Em scan directory
+represents a list of services that are supposed to be
+supervised.
+Running
+.Xr s6-svscan 8
+on this scan directory launches a
+.Em supervision tree :
+every service listed in the scan directory will be supervised.
+.Pp
+There is normally only one scan directory per system, although nothing
+prevents a system administrator from having more. daemontools[1]
+traditionally uses
+.Pa /service ,
+and runit[2] traditionally uses
+.Pa /etc/service .
+s6 does not care where your scan directory is, but I would advise
+.Pa /service
+for compatibility with daemontools.
+Depending on your installation,
+.Pa /service
+could be a symbolic link and point to a place either in a RAM
+filesystem or in
+.Pa /var .
+.Ss Where and how to build a scan directory
+Opinions and practices differ.
+.Pp
+It is generally accepted that the place where you store all your
+service directories (your
+.Dq service repository )
+should not be used as a scan directory - for a simple reason: you
+might want to have service directories for more services than what you
+want to start at any given time.
+In other words, your scan directory will be a subset of your service
+repository, so you cannot just run
+.Xr s6-svscan 8
+on every service you have a service directory for.
+So, the first thing is to separate your service repository, which is
+just a storage place for all the services you might want to manage
+someday, and your scan directory, which is a directory representing
+all the services that you are currently managing.
+.Ss SERVICE REPOSITORY
+Where to store your service repository is purely a matter of personal
+preference.
+You just have to be aware that
+.Xr s6-supervise 8
+needs writable
+.Pa supervise
+and
+.Pa event
+subdirectories in a service directory it monitors.
+.Ss SCAN DIRECTORY
+Where and how to build your scan directory depends heavily on your
+boot system - and on your personal preference too.
+.Pp
+Standard daemontools[1] and runit[2] installations like to have a
+fixed scan directory containing symlinks to service directories
+located in the service repository.
+In other words, the service repository contains the real working
+copies of the service directories.
+This works, as long as:
+.Bl -bullet -width x
+.It
+It is possible to create writable
+.Pa supervise
+and
+.Pa event
+subdirectories in every managed service directory.
+This can be achieved for instance via symlinks, or by having the
+service repository stored on a writable filesystem.
+.It
+The scan program
+.Po
+.Xr s6-svscan 8 ,
+svscan,
+.Xr runsvdir 8 ...
+.Pc
+is started late enough for all the necessary filesystems to be mounted.
+.El
+.Pp
+My own recommendation would be to have working copies of the service
+directories entirely separate from the service repository.
+The service repository can be safely stored on the root filesystem,
+and the needed directories copied to a RAM filesystem at boot
+time.
+The scan directory can be either the place where the working copies
+are written, or another directory containing symlinks to those working
+copies. (The latter is useful if you are using the
+.Fl t
+option to
+.Xr s6-svscan 8
+with a nonzero argument: copying a directory is not atomic, but making
+a symlink is, so there is no risk of your scanner finding a directory
+while it is being copied - which could result in
+.Xr s6-supervise 8
+getting the wrong information and not managing the service properly.)
+.Pp
+An example:
+.Bl -bullet -width x
+.It
+Have your service repository in
+.Pa /img/services ,
+i.e. have service directories in
+.Pa /img/services/ftpd ,
+.Pa /img/services/httpd ,
+.Pa /img/services/sshd ,
+etc.
+.It
+When booting, make
+.Pa /tmp
+a RAM filesystem, and create the directories
+.Pa /tmp/services
+and
+.Pa /tmp/service .
+.It
+Have
+.Xr s6-svscan 8
+run on
+.Pa /tmp/service ,
+as early as possible in your boot sequence.
+This is possible whether you want to run
+.Xr s6-svscan 8
+as process 1[3] or not[4].
+.It
+During the boot sequence, populate
+.Pa /tmp/services
+with copies of the service directories you need: for instance,
+.Bd -literal -offset indent
+cp -a /img/services/sshd /tmp/services/sshd
+cp -a /img/services/ftpd /tmp/services/ftpd
+etc.
+.Ed
+.It
+When you are ready to start a service, make a symlink in the
+.Pa /tmp/service
+scan directory pointing to the working copy of the
+.Xr s6-service-directory 7
+you need in
+.Pa /tmp/services ,
+then notify
+.Xr s6-svscan 8 .
+For instance, to start ftpd and httpd together:
+.Bd -literal -offset indent
+ln -s ../services/ftpd /tmp/service
+ln -s ../services/httpd /tmp/service
+s6-svscanctl -a /tmp/service
+.Ed
+.El
+.Sh SEE ALSO
+.Xr s6-fifodir 7 ,
+.Xr s6-service-directory 7
+.Pp
+[1]
+.Lk https://cr.yp.to/daemontools.html
+.Pp
+[2]
+.Lk http://smarden.org/runit/
+.Pp
+[3]
+.Lk https://skarnet.org/software/s6/s6-svscan-1.html
+.Pp
+[4]
+.Lk https://skarnet.org/software/s6/s6-svscan-not-1.html
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/scandir.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man7/s6-service-directory.7 b/mdoc/man7/s6-service-directory.7
--- a/mdoc/man7/s6-service-directory.7	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man7/s6-service-directory.7	2023-04-16 04:52:39.113496467 -0300
@@ -0,0 +1,558 @@
+.Dd January 15, 2023
+.Dt S6-SERVICE-DIRECTORY 7
+.Os
+.Sh NAME
+.Nm s6-service-directory
+.Nd directory containing all the information related to a service, i.e. a long-running process maintained and supervised by
+.Xr s6-supervise 8
+.Sh DESCRIPTION
+Strictly speaking, a
+.Em service
+is not always equivalent to a long-running process.
+Things like Ethernet interfaces fit the definition of
+.Em services
+one may want to supervise; however, s6 does not
+provide
+.Em service supervision ;
+it provides
+.Em process supervision ,
+and it is impractical to use the s6 architecture as is to supervise
+services that are not equivalent to one long-running process.
+However, we still use the terms
+.Em service
+and
+.Em service directory
+for historical and compatibility reasons.
+.Ss Directory contents
+A service directory foo may contain the following elements:
+.Bl -bullet -width x
+.It
+An executable file named
+.Pa run .
+It can be any executable file (such as a binary file or a link to any
+other executable file), but most of the time it will be a script,
+called
+.Em run script .
+This file is the most important one in your service directory: it
+contains the commands that will setup and run your
+.Em foo
+service.
+.Bl -bullet -width x
+.It
+It is forked and executed by
+.Xr s6-supervise 8
+every time the service must be started, i.e. normally when
+.Xr s6-supervise 8
+starts, and whenever the service goes down when it is supposed to be
+up.
+.It
+It is given one argument, which is the same argument that the
+.Xr s6-supervise 8
+process is running with, i.e. the name of the service directory
+\(em
+or, if
+.Xr s6-supervise 8
+is run under
+.Xr s6-svscan 8 ,
+the name of the service directory as seen by
+.Xr s6-svscan 8
+in its
+.Xr s6-scan-directory 7 .
+That is,
+.Pa "" Ns Ar foo
+or
+.Pa "" Ns Ar foo Ns /log ,
+if
+.Ar foo
+is the name of the
+.Em symbolic link
+in the scan directory.
+.El
+A run script should normally:
+.Bl -bullet -width x
+.It
+adjust redirections for stdin, stdout and stderr.
+When a run script starts, it inherits its standard file descriptors
+from
+.Xr s6-supervise 8 ,
+which itself inherits them from
+.Xr s6-svscan 8 .
+stdin is normally
+.Pa /dev/null .
+If
+.Xr s6-svscan 8
+was launched by another init system, stdout and stderr likely point to
+that init system's default log (or
+.Pa /dev/null
+in the case of sysvinit).
+If
+.Xr s6-svscan 8
+is running as pid 1 via the help of software like s6-linux-init[1],
+then its stdout and stderr point to a catch-all logger, which catches
+and logs any output of the supervision tree that has not been caught
+by a dedicated logger.
+If the defaults provided by your installation are not suitable for
+your run script, then your run script should perform the proper
+redirections before executing into the final daemon.
+For instance, dedicated logging mechanisms, such as the
+.Pa log
+subdirectory (see below) or the s6-rc[2] pipeline feature, pipe your
+run script's stdout to the logging service, but chances are you want
+to log stderr as well, so the run script should make sure that its
+stderr goes into the log pipe.
+This is achieved by
+.Ql fdmove -c 2 1
+in execline[3], and
+.Ql exec 2>&1
+in shell[4].
+.It
+adjust the environment for your
+.Em foo
+daemon.
+Normally the run script inherits its environment from
+.Xr s6-supervise 8 ,
+which normally inherits its environment from
+.Xr s6-svscan 8 ,
+which normally inherits a minimal environment from the boot
+scripts.
+Service-specific environment variables should be set in the run
+script.
+.It
+adjust other parameters for the
+.Em foo
+daemon, such as its uid and gid.
+Normally the supervision tree, i.e.
+.Xr s6-svscan 8
+and the various
+.Xr s6-supervise 8
+processes, is run as root, so run scripts are also run as root;
+however, for security purposes, services should not run as root if
+they don't need to.
+You can use the
+.Xr s6-setuidgid 8
+utility in
+.Pa foo/run
+to lose privileges before executing into
+.Em foo Ap
+s long-lived process; or the
+.Xr s6-envuidgid 8
+utility if your long-lived process needs root privileges at start time
+but can drop them afterwards.
+.It
+execute into the long-lived process that is to be supervised by
+.Xr s6-supervise 8 ,
+i.e. the real
+.Em foo
+daemon.
+That process must not
+.Dq background itself :
+being run by a supervision tree already makes it a
+.Dq background task.
+.El
+.It
+An optional executable file named
+.Pa finish .
+Like
+.Pa run ,
+it can be any executable file.
+This
+.Em finish script ,
+if present, is executed everytime the
+.Pa run
+script dies.
+Generally, its main purpose is to clean up non-volatile data such as
+the filesystem after the supervised process has been killed.
+If the
+.Em foo
+service is supposed to be up,
+.Pa foo/run
+is restarted after
+.Pa foo/finish
+dies.
+.Bl -bullet -width x
+.It
+By default, a finish script must do its work and exit in less than 5
+seconds; if it takes more than that, it is killed.
+(The point is that the run script, not the finish script, should be
+running; the finish script should really be short-lived.)
+The maximum duration of a
+.Pa finish
+execution can be configured via the
+.Pa timeout-finish
+file, see below.
+.It
+The finish script is executed with three arguments:
+.Bl -enum -width x
+.It
+the exit code from the run script (resp. 256 if the run script was
+killed by a signal);
+.It
+an undefined number (resp. the number of the signal that killed the
+run script);
+.It
+the name of the service directory, the same that has been given to
+.Pa ./run .
+.El
+.It
+If the finish script exits 125, then
+.Xr s6-supervise 8
+interprets this as a permanent failure for the service, and does not
+restart it, as if an
+.Ql s6-svc -O
+command had been sent.
+.It
+If
+.Xr s6-supervise 8
+has been instructed to exit after the service dies, via an
+.Ql s6-svc -x
+command or a
+.Dv SIGHUP ,
+then the next invocation of
+.Pa finish
+will (obviously) be the last, and it will run with stdin and stdout
+pointing to
+.Pa /dev/null .
+.El
+.It
+A directory named
+.Pa supervise .
+It is automatically created by
+.Xr s6-supervise 8
+if it does not exist.
+This is where
+.Xr s6-supervise 8
+stores its internal information.
+The directory must be writable.
+.It
+An optional, empty, regular file named
+.Pa down .
+If such a file exists, the default state of the service is considered
+down, not up:
+.Xr s6-supervise 8
+will not automatically start it until it receives a
+.Ql s6-svc -u
+command.
+If no
+.Pa down
+file exists, the default state of the service is up.
+.It
+An optional regular file named
+.Pa notification-fd .
+If such a file exists, it means that the service supports readiness
+notification; refer to
+.Xr s6-notifywhenup 7 .
+The file must only contain an unsigned integer, which is the number of
+the file descriptor that the service writes its readiness notification
+to.
+(For instance, it should be 1 if the daemon is
+.Xr s6-ipcserverd 8
+run with the
+.Fl 1
+option.)
+When a service is started, or restarted, by
+.Xr s6-supervise 8 ,
+if this file exists and contains a valid descriptor number,
+.Xr s6-supervise 8
+will wait for the notification from the service and broadcast
+readiness, i.e. any
+.Ql s6-svwait -U ,
+.Ql s6-svlisten1 -U
+or
+.Ql s6-svlisten -U
+processes will be triggered.
+.It
+An optional regular file named
+.Pa lock-fd .
+If such a file exists, it must contain an unsigned integer,
+representing a file descriptor that will be open in the service.
+The service
+.Em should not write to that descriptor
+and
+.Em should not close it .
+In other words, it should totally ignore it.
+That file descriptor holds a lock, that will naturally be released
+when the service dies.
+The point of this feature is to prevent
+.Xr s6-supervise 8
+from accidentally spawning several copies of the service in case
+something goes wrong: for instance, the service backgrounds itself
+(which it shouldn't do when running under a supervision suite), or
+.Xr s6-supervise 8
+is killed, restarted by
+.Xr s6-svscan 8 ,
+and attempts to start another copy of the service while the first copy
+is still alive.
+If
+.Xr s6-supervise 8
+detects that the lock is held when it tries to start the service, it
+will print a warning message; the new service instance will block
+until the lock is released, then proceed as usual.
+.It
+An optional regular file named
+.Pa timeout-kill .
+If such a file exists, it must only contain an unsigned integer
+.Em t .
+If
+.Em t
+is nonzero, then on receipt of an
+.Ql s6-svc -d
+command, which sends a SIGTERM (by default, see down-signal below) and
+a SIGCONT to the service, a timeout of
+.Em t
+milliseconds is set; and if the service is still not dead after
+.Em t
+milliseconds, then it is sent a SIGKILL.
+If
+.Pa timeout-kill
+does not exist, or contains 0 or an invalid value, then the service is
+never forcibly killed (unless, of course, an
+.Ql s6-svc -k
+command is sent).
+.It
+An optional regular file named
+.Pa timeout-finish .
+If such a file exists, it must only contain an unsigned integer, which
+is the number of milliseconds after which the
+.Pa ./finish
+script, if it exists, will be killed with a SIGKILL.
+The default is 5000: finish scripts are killed if they're still alive
+after 5 seconds.
+A value of 0 allows finish scripts to run forever.
+.It
+An optional regular file named
+.Pa max-death-tally .
+If such a file exists, it must only contain an unsigned integer, which
+is the maximum number of service death events that
+.Xr s6-supervise 8
+will keep track of.
+If the service dies more than this number of times, the oldest events
+will be forgotten.
+Tracking death events is useful, for instance, when throttling service
+restarts.
+The value cannot be greater than 4096.
+If the file does not exist, a default of 100 is used.
+.It
+An optional regular file named
+.Pa down-signal .
+If such a file exists, it must only contain the name or number of a
+signal, followed by a newline.
+This signal will be used to kill the supervised process when a
+.Ql s6-svc -d
+or
+.Ql s6-svc -r
+command is used.
+If the file does not exist, SIGTERM will be used by default.
+.It
+A
+.Xr s6-fifodir 7
+named
+.Pa event .
+It is automatically created by
+.Xr s6-supervise 8
+if it does not exist.
+.Pa "" Ns Ar foo Ns /event
+is the rendez-vous point for listeners, where
+.Xr s6-supervise 8
+will send notifications when the service goes up or down.
+.It
+Optional directories named
+.Pa instance
+and
+.Pa instances .
+Those are internal subdirectories created by
+.Xr s6-instance maker 8
+in a templated service directory.
+Outside of instanced services, these directories should never appear,
+and you should never create them manually.
+.It
+An optional service directory named
+.Pa log .
+If it exists and
+.Em foo
+is in a
+.Xr s6-scan-directory 7 ,
+and
+.Xr s6-svscan 8
+runs on that scandir, then two services are monitored:
+.Em foo
+and
+.Pa foo/log .
+A pipe is open and maintained between
+.Em foo
+and
+.Pa foo/log ,
+i.e. everything that
+.Pa foo/run
+writes to its stdout will appear on
+.Pa foo/log/run Ap
+s stdin.
+The
+.Em foo
+service is said to be logged; the
+.Em foo/log
+service is called
+.Em foo Ap
+s logger.
+A logger service cannot be logged: if
+.Pa foo/log/log
+exists, nothing special happens.
+.El
+.Pp
+.Sy Stability
+.Pp
+With the evolution of s6, it is possible that
+.Xr s6-supervise 8
+configuration uses more and more files in the service directory.
+The
+.Pa notification-fd
+and
+.Pa timeout-finish
+files, for instance, have appeared in 2015; users who previously had
+files with the same name had to change them.
+There is no guarantee that
+.Xr s6-supervise 8
+will not use additional names in the service directory in the same
+fashion in the future.
+.Pp
+There is, however, a guarantee that
+.Xr s6-supervise 8
+will never touch subdirectories named
+.Pa data
+or
+.Pa env .
+So if you need to store user information in the service directory with
+the guarantee that it will never be mistaken for a configuration file,
+no matter the version of s6, you should store that information in the
+.Pa data
+or
+.Pa env
+subdirectories of the service directory.
+.Ss Where should I store my service directories?
+Service directories describe the way services are launched.
+Once they are designed, they have little reason to change on a given
+machine.
+They can theoretically reside on a read-only filesystem - for
+instance, the root filesystem, to avoid problems with mounting
+failures.
+.Pp
+However, two subdirectories - namely
+.Pa supervise
+and
+.Pa event
+- of every service directory need to be writable.
+So it has to be a bit more complex.
+Here are a few possibilities.
+.Bl -bullet -width x
+.It
+The laziest option: you're not using
+.Xr s6-svscan 8
+as process 1, you're only using it to start a collection of services,
+and your booting process is already handled by another init
+system.
+Then you can just store your service directories and your
+.Xr s6-scan-directory 7
+on some read-write filesystem such as
+.Pa /var ;
+and you tell your init system to launch (and, if possible, maintain)
+.Xr s6-svscan 8
+on the scan directory after that filesystem is mounted.
+.It
+The almost-as-lazy option: just have the service directories on the
+root filesystem.
+Then your service directory collection is for instance in
+.Pa /etc/services
+and you have a
+.Pa /service
+.Xr s6-scan-directory 7
+containing symlinks to that collection.
+This is the easy setup, not requiring an external init system to mount
+your filesystems - however, it requires your root filesystem to be
+read-write, which is unacceptable if you are concerned with
+reliability - if you are, for instance, designing an embedded
+platform.
+.It
+Some people[5] like to have their service directories in a read-only
+filesystem, with supervise symlinks pointing to various places in
+writable filesystems.
+This setup looks a bit complex to me: it requires careful handling of
+the writable filesystems, with not much room for error if the
+directory structure does not match the symlinks (which are then
+dangling).
+But it works.
+.It
+Service directories are usually small; most daemons store their
+information elsewhere.
+Even a complete set of service directories often amounts to less than
+a megabyte of data - sometimes much less.
+Knowing this, it makes sense to have an image of your service
+directories in the (possibly read-only) root filesystem, and copy it
+all to a
+.Xr s6-scan-directory 7
+located on a RAM filesystem that is mounted at boot time.
+This is the setup I recommend, and the one used by the s6-rc[2] service
+manager.
+It has several advantages:
+.Bl -bullet -width x
+.It
+Your service directories reside on the root filesystem and are not
+modified during the lifetime of the system.
+If your root filesystem is read-only and you have a working set of
+service directories, you have the guarantee that a reboot will set
+your system in a working state.
+.It
+Every boot system requires an early writeable filesystem, and many
+create it in RAM.
+You can take advantage of this to copy your service directories early
+and run
+.Xr s6-svscan 8
+early.
+.It
+No dangling symlinks or potential problems with unmounted filesystems:
+this setup is robust.
+A simple
+.Ql /bin/cp -a
+or
+.Ql tar -x
+is all it takes to get a working service infrastructure.
+.It
+You can make temporary modifications to your service directories
+without affecting the main ones, safely stored on the disk.
+Conversely, every boot ensures clean service directories - including
+freshly created
+.Pa supervise
+and
+.Pa event
+subdirectories.
+No stale files can make your system unstable.
+.El
+.El
+.Sh SEE ALSO
+s6-envuidgid 1 ,
+s6-ipcserverd 1 ,
+s6-setuidgid 1 ,
+s6-supervise 1 ,
+s6-svscan 1 ,
+s6-fifodir 7 ,
+s6-notifywhenup 7 ,
+s6-scan-directory 7
+.Pp
+[1]
+.Lk https://skarnet.org/software/s6-linux-init/
+.Pp
+[2]
+.Lk https://skarnet.org/software/s6-rc/
+.Pp
+[3]
+.Lk https://skarnet.org/software/execline/
+.Pp
+[4]
+.Lk https://pubs.opengroup.org/onlinepubs/9699919799/utilities/sh.html
+.Pp
+[5]
+.Lk https://code.dogmap.org/
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/servicedir.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man7/s6-socket-activation.7 b/mdoc/man7/s6-socket-activation.7
--- a/mdoc/man7/s6-socket-activation.7	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man7/s6-socket-activation.7	2023-04-16 04:52:39.113496467 -0300
@@ -0,0 +1,152 @@
+.Dd January 15, 2023
+.Dt S6-SOCKET-ACTIVATION 7
+.Os
+.Sh NAME
+.Nm s6-socket-activation
+.Nd performing socket activation with s6
+.Sh DESCRIPTION
+First, it's important to realize that you don't
+.Em need
+socket activation.
+It's a marketing word used by systemd advocates that mixes a couple
+useful architecture concepts and several horrible ideas, for a very
+minor speed benefit.
+Read [1] and [2] for details.
+.Bl -bullet -width x
+.It
+s6
+.Em will not
+help you implement super-servers in process 1, because doing so is bad
+engineering.
+However, it
+.Em will
+help you set up super-servers.
+The
+.Xr s6-ipcserver 8
+program, for Unix domain sockets, as well as the
+.Xr s6-tcpserver4 8
+and
+.Xr s6-tcpserver6 8
+programs, for TCP INET domain sockets
+.Po
+available in the s6-networking package[3]
+.Pc
+are super-servers you can use to your heart's content.
+They are even wrappers around simpler programs, and you can use their
+components in the way you choose: bind sockets, drop privileges,
+accept connections from clients, it's all about what you write in your
+command line.
+Super-servers are a good thing; using process 1 to act as a
+super-server is not.
+s6 provides you with the tools to get the good without the bad.
+.It
+s6
+.Em will not
+help you run all your services before their dependencies are met,
+because doing so is
+.Em very
+bad engineering.
+However, it
+.Em will
+provide you with:
+.Bl -bullet -width x
+.It
+a reliable logging infrastructure, that makes sure your services
+never lose logs:
+.Xr s6-log 8 ,
+in conjunction with
+.Xr s6-supervise 8
+and
+.Xr s6-svscan 8 .
+.It
+ways to open your sockets and bind them as early as you want in your
+boot process, and make them accept client connections later:
+.Xr s6-ipcserver-socketbinder 8 ,
+.Xr s6-tcpserver4-socketbinder 8
+and
+.Xr s6-tcpserver6-socketbinder 8 .
+.It
+a supervision infrastructure that can start as many services in
+parallel as you want:
+.Xr s6-supervise 8
+and
+.Xr s6-svscan 8 .
+.El
+.It
+s6
+.Em will not
+help you centralize all your socket information in process 1, because
+doing so is contrary to modularity and independence of services.
+However, s6
+.Em will
+provide you with a way to store your open sockets and retrieve them
+when you want, which it calls
+.Dq fd holding :
+.Xr s6-fdholder-daemon 8 .
+.El
+.Ss So, how do I open all my sockets first, store them, and dispatch them to daemons later?
+Again, it's not necessary to do that: you'll be fine, and quite
+speedy, just starting your daemons in their good time.
+You
+.Em will not
+reap any noticeable benefit from performing
+.Dq socket activation .
+But if you really want to:
+.Bl -enum -width x
+.It
+Make sure you have an early supervision infrastructure running.
+Ideally, you would make
+.Xr s6-svscan 8
+your process 1 .
+.It
+Start an early fd-holding service, e.g.
+.Xr s6-fdholder-daemon 8 .
+Let's say the fd-holding daemon is listening on socket
+.Pa /service/fdholder/s .
+.It
+For every Unix domain socket
+.Pa /my/socket
+you need to open, run:
+.Bd -literal
+s6-ipcserver-socketbinder /my/socket s6-fdholder-store /service/fdholder/s unix:/my/socket
+.Ed
+.Pp
+You can do the same with INET domain sockets.
+.It
+Proceed to your initialization.
+.It
+When you want to run a daemon
+.Ql myserverd
+that accepts clients connecting to
+.Pa /my/socket ,
+run:
+.Bd -literal
+s6-fdholder-retrieve /service/fdholder/s unix:/my/socket myserverd
+.Ed
+.Pp
+.Ql myserverd
+will be executed with
+.Pa /my/socket
+as its standard input.
+.It
+The descriptors remain safely stored in the fd-holding daemon and you
+can retrieve them again whenever you want, for instance when your
+service crashes and is restarted.
+.El
+.Pp
+That is all there is to it.
+You don't have to use specific libraries or write complex unit files,
+you just need to understand how a command line works.
+This is Unix.
+.Sh SEE ALSO
+[1]
+.Lk https://skarnet.org/lists/supervision/0422.html
+.Pp
+[2]
+.Lk https://forums.gentoo.org/viewtopic-t-994548-postdays-0-postorder-asc-start-25.html#7581522
+.Pp
+[3]
+.Lk https://skarnet.org/software/s6-networking/
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man7/s6-svscan-as-process-1.7 b/mdoc/man7/s6-svscan-as-process-1.7
--- a/mdoc/man7/s6-svscan-as-process-1.7	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man7/s6-svscan-as-process-1.7	2023-04-16 04:52:39.113496467 -0300
@@ -0,0 +1,581 @@
+.Dd January 15, 2023
+.Dt S6-SVSCAN-AS-PROCESS-1 7
+.Os
+.Sh NAME
+.Nm s6-svscan-as-process-1
+.Nd running
+.Xr s6-svscan 8
+as process 1
+.Sh DESCRIPTION
+.Bf Em
+Since 2015-06-17, if you're a Linux user, you can use the
+s6-linux-init package[1] to help you do so!
+Please read this documentation page first, though, it will help you
+understand what s6-linux-init does.
+.Ef
+.Pp
+It is possible to run
+.Xr s6-svscan 8
+as process 1, i.e. the
+.Ql init
+process.
+However, that does not mean you can directly
+.Em boot
+on
+.Xr s6-svscan 8 ;
+that little program cannot do everything your stock init does.
+Replacing the
+.Ql init
+process requires a bit of understanding of what is going on.
+.Ss The three stages of init
+Okay, it's actually four, but the fourth stage is an implementation
+detail that users don't care about, so we'll stick with three.
+.Pp
+The life of a Unix machine has three stages.
+Yes, three.
+.Bl -enum -width x
+.It
+The
+.Em early initialization
+phase.
+It starts when the kernel launches the first userland process,
+traditionally called
+.Ql init .
+During this phase, init is the only lasting process; its duty is to
+prepare the machine for the start of
+.Em other
+long-lived processes, i.e. services.
+Work such as mounting filesystems, setting the system clock, etc. can
+be done at this point.
+This phase ends when process 1 launches its first services.
+.It
+The
+.Em cruising
+phase.
+This is the
+.Dq normal ,
+stable state of an up and running Unix machine.
+Early work is done, and init launches and maintains
+.Em services ,
+i.e. long-lived processes such as gettys, the ssh server, and so on.
+During this phase, init's duties are to reap orphaned zombies and to
+supervise services
+\(em
+also allowing the administrator to add or remove services.
+This phase ends when the administrator requires a shutdown.
+.It
+The
+.Em shutdown
+phase.
+Everything is cleaned up, services are stopped, filesystems are
+unmounted, the machine is getting ready to be halted.
+At the end of this phase, all processes are killed, first with a
+.Dv SIGTERM ,
+then with a
+.Dv SIGKILL
+.Po
+to catch processes that resist
+.Dv SIGTERM
+.Pc .
+The only processes that survive it are process 1; if this process is
+.Xr s6-svscan 8
+and its
+.Xr s6-scan-directory 7
+is not empty, then the supervision tree is restarted.
+.It
+The
+.Em hardware shutdown
+phase.
+The system clock is stored, filesystems are unmounted, and the system
+call that reboots the machine or powers it off is called.
+.El
+.Pp
+Unless you're implementing a shutdown procedure over a supervision
+tree, you can absolutely consider that the hardware shutdown is part of stage 3.
+.Pp
+As you can see, process 1's duties are
+.Em radically different
+from one stage to the next, and init has the most work when the
+machine is booting or shutting down, which means a normally negligible
+fraction of the time it is up.
+The only common thing is that at no point is process 1 allowed to
+exit.
+.Pp
+Still, all common init systems insist that the same
+.Ql init
+executable must handle these three stages.
+From System V init to launchd, via busybox init, you name it
+\(em
+one init program from bootup to shutdown.
+No wonder those programs, even basic ones, seem complex to write and
+complex to understand!
+.Pp
+Even the runit[2] program, designed with supervision in mind, remains
+as process 1 all the time; at least runit makes things simple by
+clearly separating the three stages and delegating every stage's work
+to a different script that is
+.Em not
+run as process 1.
+.Po
+Since runit does not distinguish between stage 3 and stage 4, it needs
+very careful handling of the
+.Ql kill -9 -1
+part of stage 3: getting
+.Pa /etc/runit/3
+killed before it unmounts the filesystems would be bad.
+.Pc
+.Pp
+One init to rule them all?
+It ain't necessarily so!
+.Ss The role of s6-svscan
+init does not have the right to die, but fortunately,
+.Bf Em
+it has the right to
+.Xr execve 3 !
+.Ef
+During stage 2, why use precious RAM, or at best, swap space, to store
+data that are only relevant to stages 1 or 3-4?
+It only makes sense to have an init process that handles stage 1, then
+executes into an init process that handles stage 2, and when told to
+shutdown, this
+.Dq stage 2
+init executes into a
+.Dq stage 3
+init which just performs shutdown.
+Just as runit does with the
+.Pa /etc/runit/[123]
+scripts, but
+.Xr exec 3 Ns
+ing the scripts as process 1 instead of forking them.
+.Pp
+It becomes clear now that
+.Xr s6-svscan 8
+is perfectly suited to exactly fulfill process 1's role
+.Em during stage 2 .
+.Bl -bullet -width x
+.It
+It does not die.
+.It
+The reaper takes care of every zombie on the system.
+.It
+The scanner maintains services alive.
+.It
+It can be sent commands via the
+.Xr s6-svscanctl 8
+interface.
+.It
+It
+.Xr exec 3 Ns
+s into a given script when told to.
+.El
+.Pp
+However, an init process for stage 1 and another one for stage 3 are
+still needed.
+Fortunately, those processes are very easy to design!
+The only difficulty here is that they're heavily system-dependent, so
+it's not possible to provide a stage 1 init and a stage 3 init that
+will work everywhere.
+s6 was designed to be as portable as possible, and it should run on
+virtually every Unix platform; but outside of stage 2 is where
+portability stops.
+.Pp
+The s6-linux-init package[1] provides a tool,
+.Ql s6-linux-init-maker ,
+to automatically create a suitable stage 1 init
+.Po
+so, the
+.Pa /sbin/init
+binary
+.Pc
+for Linux.
+It is also possible to write similar tools for other operating
+systems, but the details are heavily system-dependent.
+.Pp
+For the adventurous and people who need to do this by hand, though, here are
+are some general design tips.
+.Ss How to design a stage 1 init
+.Sy What stage 1 init must do
+.Bl -bullet -width x
+.It
+Prepare an initial
+.Xr s6-scan-directory 7 ,
+say in
+.Pa /run/service ,
+with a few vital services, such as
+.Xr s6-svscan 8 Ap
+s own logger, and an early getty (in case debugging is needed).
+That implies mounting a read-write filesystem, creating it in RAM if
+needed, if the root filesystem is read-only.
+.It
+Either perform all the one-time initialization, as stage 1 runit[2] does;
+.It
+or fork a process that will perform most of the one-time initialization once
+.Xr s6-svscan 8
+is in charge.
+.It
+Be extremely simple and not fail, because recovery is almost impossible
+here.
+.El
+.Pp
+Unlike the
+.Pa /etc/runit/1
+script, an init-stage1 script running as process 1 has nothing to back
+it up, and if it fails and dies, the machine crashes.
+Does that mean the runit approach is better?
+It's certainly safer, but not necessarily better, because init-stage1
+can be made
+.Em extremely small ,
+to the point it is practically failproof, and if it fails, it means
+something is so wrong that you would have had to reboot the machine
+with
+.Ql init=/bin/sh
+anyway.
+.Pp
+To make init-stage1 as small as possible, only this realization is
+needed: you do not need to perform all of the one-time initialization
+tasks before launching
+.Xr s6-svscan 8 .
+Actually, once init-stage1 has made it possible for
+.Xr s6-svscan 8
+to run, it can fork a background
+.Dq init-stage2
+process and
+.Xr exec 3
+into
+.Xr s6-svscan 8
+immediately!
+The
+.Dq init-stage2
+process can then pursue the one-time initialization, with a big
+advantage over the
+.Dq init-stage1
+process:
+.Xr s6-svscan 8
+is running, as well as a few vital services, and if something bad
+happens, there's a getty for the administrator to log on.
+No need to play fancy tricks with
+.Pa /dev/console
+anymore!
+Yes, the theoretical separation in 3 stages is a bit more flexible in
+practice: the
+.Dq stage 2
+process 1 can be already running when a part of the
+.Dq stage 1
+one-time tasks are still being run.
+.Pp
+Of course, that means that the scan directory is still incomplete when
+.Xr s6-svscan 8
+first starts, because most services can't yet be run, for
+lack of mounted filesystems, network etc.
+The
+.Dq init-stage2
+one-time initialization script must populate the scan directory when
+it has made it possible for all wanted services to run, and trigger
+the scanner.
+Once all the one-time tasks are done, the scan directory is fully
+populated and the scanner has been triggered, the machine is fully
+operational and in stage 2, and the
+.Dq init-stage2
+script can die.
+.Pp
+.Sy Is it possible to write stage 1 init in a scripting language?
+.br
+It is very possible, and if you are attempting to write your own stage
+1, I definitely recommend it.
+If you are using
+.Xr s6-svscan 8
+as stage 2 init, stage 1 init should be simple enough that it can be
+written in any scripting language you want, just as
+.Pa /etc/runit/1
+is if you're using runit.
+And since it should be so small, the performance impact will be
+negligible, while maintainability is enhanced.
+Definitely make your stage 1 init a script.
+.Pp
+Of course, most people will use the
+.Em shell
+as scripting language; however, I advocate the use of execline[3] for
+this, and not only for the obvious reasons.
+Piping
+.Xr s6-svscan 8 Ap
+s stderr to a logging service before said service is even up requires
+some tricky FIFO handling that execline can do and the shell cannot.
+.Ss  How to design a stage 3-4 init
+If you're using
+.Xr s6-svscan 8
+as stage 2 init on
+.Pa /run/service ,
+then stage 3 init is naturally the
+.Pa /run/service/.s6-svscan/finish
+program.
+Of course,
+.Pa /run/service/.s6-svscan/finish
+can be a symbolic link to anything else; just make sure it points to
+something in the root filesystem (unless your program is an execline
+script, in which case it is not even necessary).
+.Pp
+.Sy What stage 3-4 init must do
+.Bl -bullet -width x
+.It
+Destroy the supervision tree and stop all services.
+.It
+Kill all processes
+.Em save itself ,
+first gently, then harshly, and
+.Em reap all the zombies .
+.It
+Up until that point we were in stage 3; now we're in stage 4.
+.It
+Unmount all the filesystems.
+.It
+Halt or reboot the machine, depending on what root asked for.
+.El
+.Pp
+This is seemingly very simple, even simpler than stage 1, but
+experience shows that it's trickier than it looks.
+.Pp
+One tricky part is the
+.Ql kill -9 -1
+operation at the end of stage 3: you must make sure that
+.Em process 1
+regains control and keeps running after it, because it will be the
+only process left alive.
+If you are running a stage 3 script as process 1, it is almost
+automatic: your script survives the kill and continues running, up
+into stage 4.
+If you are using another model, the behaviour becomes
+system-dependent: your script may or may not survive the kill, so on
+systems where it does not, you will have to design a way to regain
+control in order to accomplish stage 4 tasks.
+.Pp
+Another tricky part, that is only apparent with practice, is solidity.
+It is even more vital that
+.Em nothing fails
+during stages 3 and 4 than it is in stage 1, because in stage 1, the
+worst that can happen is that the machine does not boot, whereas in
+stages 3 and 4, the worst that can happen is that the machine
+.Em does not shut down ,
+and that is a much bigger issue.
+.Pp
+For these reasons, I now recommend
+.Em not
+tearing down the supervision tree for stages 3-4.
+It is easier to work in a stable environment, as a regular process,
+than it is to manage a whole shutdown sequence as pid 1: the presence
+of
+.Xr s6-svscan 8
+as pid 1, and of a working supervision tree, is a pillar
+you can rely on, and with experience I find it a good idea to keep the
+supervision infrastructure running until the end.
+Of course, that requires the scandir, and the active supervision
+directories, to be on a RAM filesystem such as
+.Ql tmpfs ;
+that is good policy anyway.
+.Pp
+.Sy Is it possible to write stage 3 init in a scripting language?
+.br
+Yes, definitely, just like stage 1.
+.Pp
+However, you really should leave
+.Pa /run/service/.s6-svscan/finish
+.Po
+and the other scripts in
+.Pa /run/service/.s6-svscan
+.Pc
+alone, and write your shutdown sequence without dismantling the
+supervision tree.
+You will still have to stop most of the services, but
+.Xr s6-svscan 8
+should stay.
+.Pp
+For a more in-depth study of what to do in stages 3-4 and how
+to do it, you can look at the source of
+.Ql s6-linux-init-shutdownd
+in the s6-linux-init package[1].
+.Ss How to log the supervision tree's messages
+When the Unix kernel launches your (stage 1) init process, it does it
+with descriptors 0, 1 and 2 open and reading from or writing to
+.Pa /dev/console .
+This is okay for the early boot: you actually want early error
+messages to be displayed to the system console.
+But this is not okay for stage 2: the system console should only be
+used to display extremely serious error messages such as kernel
+errors, or errors from the logging system itself; everything else
+should be handled by the logging system, following the logging chain
+mechanism
+.Po
+refer to
+.Xr s6-log 8
+for details
+.Pc .
+The supervision tree's messages should go to the catch-all logger
+instead of the system console.
+.Po
+And the console should never be read, so no program should run with
+.Pa /dev/console
+as stdin, but this is easy enough to fix:
+.Xr s6-svscan 8
+will be started with stdin redirected from
+.Pa /dev/null .
+.Pc
+.Pp
+The catch-all logger is a service, and we want
+.Em every
+service to run under the supervision tree.
+Chicken and egg problem: before starting
+.Xr s6-svscan 8 ,
+we must redirect
+.Xr s6-svscan 8 Ap
+s output to the input of a program that will only be started once
+.Xr s6-svscan 8
+is running and can start services.
+.Pp
+There are several solutions to this problem, but the simplest one is
+to use a FIFO, a.k.a. named pipe.
+.Xr s6-svscan 8 Ap
+s stdout and stderr can be redirected to a named pipe before
+.Xr s6-svscan 8
+is run, and the catch-all logger service can be made to read from this
+named pipe.
+Only two minor problems remain:
+.Bl -bullet -width x
+.It
+If
+.Xr s6-svscan 8
+or
+.Xr s6-supervise 8
+writes to the FIFO before there is a reader, i.e. before the catch-all
+logging service is started, the write will fail
+.Po
+and a
+.Dv SIGPIPE
+will be emitted
+.Pc .
+This is not a real issue for an s6 installation because
+.Xr s6-svscan 8
+and
+.Xr s6-supervise 8
+ignore
+.Dv SIGPIPE ,
+and they only write to their stderr if an error occurs; and if an
+error occurs before they are able to start the catch-all logger, this
+means that the system is seriously damaged (as if an error occurs
+during stage 1) and the only solution is to reboot with
+.Ql init=/bin/sh
+anyway.
+.It
+Normal Unix semantics
+.Em do not allow
+a writer to open a FIFO before there is a reader: if there is no
+reader when the FIFO is opened for writing, the
+.Xr open 3
+system call
+.Em blocks
+until a reader appears.
+This is obviously not what we want: we want to be able to
+.Em actually start
+.Xr s6-svscan 8
+with its stdout and stderr pointing to the logging FIFO, even without
+a reader process, and we want it to run normally so it can start the
+logging service that will provide such a reader process.
+.El
+.Pp
+This second point cannot be solved in a shell script, and that is why
+you are discouraged to write your stage 1 init script in the shell
+language: you cannot properly set up a FIFO output for
+.Xr s6-svscan 8
+without resorting to horrible and unreliable hacks involving a
+temporary background FIFO reader process.
+.Pp
+Instead, you are encouraged to use the execline[3] language
+\(em
+or, at least, the
+.Xr redirfd 1
+command, which is part of the execline distribution.
+The
+.Xr redirfd 1
+command does just the right amount of trickery with FIFOs for you to
+be able to properly redirect process 1's stdout and stderr to the
+logging FIFO without blocking:
+.Bd -literal
+redirfd -w 1 /run/service/s6-svscan-log/fifo
+.Ed
+.Pp
+blocks if there's no process reading on
+.Pa /run/service/s6-svscan-log/fifo ,
+but
+.Bd -literal
+redirfd -wnb 1 /run/service/s6-svscan-log/fifo
+.Ed
+.Pp
+.Em does not .
+.Pp
+This trick with FIFOs can even be used to avoid potential race
+conditions in the one-time initialization script that runs in stage 2.
+If forked from init-stage1 right before executing
+.Xr s6-svscan 8 ,
+depending on the scheduler mood, this script may actually run a long
+way before
+.Xr s6-svscan 8
+is actually executed and running the initial services
+\(em
+and may do dangerous things, such as writing messages to the logging
+FIFO before there's a reader, and eating a
+.Dv SIGPIPE
+and dying without completing the initialization.
+To avoid that and be sure that
+.Xr s6-svscan 8
+really runs and initial services are really started before the stage 2
+init script is allowed to continue, it is possible to redirect the
+child script's output (stdout and/or stderr)
+.Em once again
+to the logging FIFO, but in the normal way without
+.Xr redirfd 1
+trickery,  before it
+.Xr exec 3 Ns
+s into the init-stage2 script.
+So, the child process blocks on the FIFO until a reader appears, while
+process 1 - which does not block -
+.Xr exec 3 Ns
+s into
+.Xr s6-svscan 8
+and starts the logging service, which then opens the logging FIFO for
+reading and unblocks the child process, which then runs the
+initialization tasks with the guarantee that
+.Xr s6-svscan 8
+is running.
+.Pp
+It really is simpler than it sounds. :-)
+.Ss A working example
+This whole page may sound very theoretical, dry, wordy, and hard to
+grasp without a live example to try things on; unfortunately, s6
+cannot provide live examples without becoming system-specific.
+.Pp
+However, the s6-linux-init package[1] provides you with the
+.Ql s6-linux-init-maker Ns
+[4] command, which produces a set of working scripts, including a
+script that is suitable as
+.Pa /sbin/init ,
+for you to study and edit.
+You can
+.Em run
+the
+.Ql s6-linux-init-maker
+command even on non-Linux systems: it will produce scripts that do not
+work as is for another OS, but can still be used for study and as a
+basis for a working stage 1 script.
+.Sh SEE ALSO
+[1]
+.Lk https://skarnet.org/software/s6-linux-init/
+.Pp
+[2]
+.Lk http://smarden.org/runit/runit.8.html
+.Pp
+[3]
+.Lk https://skarnet.org/software/execline/
+.Pp
+[4]
+.Lk https://skarnet.org/software/s6-linux-init/s6-linux-init-maker.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man7/s6-svscan-not-as-process-1.7 b/mdoc/man7/s6-svscan-not-as-process-1.7
--- a/mdoc/man7/s6-svscan-not-as-process-1.7	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man7/s6-svscan-not-as-process-1.7	2023-04-16 04:52:39.113496467 -0300
@@ -0,0 +1,149 @@
+.Dd January 15, 2023
+.Dt S6-SVSCAN-NOT-AS-PROCESS-1 7
+.Os
+.Sh NAME
+.Nm s6-svscan-not-as-process-1
+.Nd running
+.Xr s6-svscan 8
+under another init process
+.Sh DESCRIPTION
+You can have a reliable supervision tree even if
+.Xr s6-svscan 8
+is not your process 1.
+The supervision tree just has to be
+.Em rooted
+in process 1: that means that your process 1 will have to supervise
+your
+.Xr s6-svscan 8
+process somehow.
+That way, if
+.Xr s6-svscan 8
+dies, it will be restarted, and your set of services will always be
+maintained.
+.Pp
+Be aware, though, that pipes between services and loggers are
+maintained by the
+.Xr s6-svscan 8
+process; if this process dies, the pipes will be closed and some logs
+may be lost.
+.Ss Logging the supervision tree's output
+.Xr s6-svscan 8
+and the various
+.Xr s6-supervise 8
+processes might produce error or warning messages; those messages are written to
+.Xr s6-svscan 8 Ap
+s stderr
+.Po
+which is inherited by the
+.Xr s6-supervise 8
+processes
+.Pc .
+To log these messages:
+.Bl -bullet -width x
+.It
+You can use your init system's logging tools, and make your init
+system launch
+.Xr s6-svscan 8
+as is; its stderr should already be taken care of by the logging
+tools.
+.It
+You can use a trick similar to the
+.Xr s6-svscan-as-process-1 7
+process 1 output logging trick so the supervision tree's messages are
+logged via a service that's maintained by the supervision tree itself.
+Then your init system should not launch
+.Xr s6-svscan 8
+directly, but a wrapper script that performs the proper redirections.
+The
+.Pa examples/s6-svscanboot
+file in the s6 distribution gives an example of such a script.
+Make sure that your initial
+.Xr s6-scan-directory 7
+contains an
+.Xr s6-service-directory 7
+for your initial logging service, that must read on the logging FIFO.
+.El
+.Pp
+In some of the following examples, we'll assume that
+.Pa /command/s6-svscanboot
+is the name of the script you are using to start
+.Xr s6-svscan 8 .
+We will also assume that all of the s6 executables are available
+through the
+.Pa /command
+path.
+Adjust this accordingly.
+.Ss System V init
+Put an appropriate line in your
+.Pa /etc/inittab
+file, then reload this config file with
+.Ql telinit q :
+.Bd -literal
+SV:123456:respawn:/command/s6-svscanboot
+.Ed
+.Ss Upstart
+Put an appropriate configuration file in the
+.Pa /etc/init
+folder, for instance
+.Pa /etc/init/s6-svscan.conf ,
+then start the service with
+.Ql start s6-svscan :
+.Bd -literal
+# s6-svscan
+start on runlevel [2345]
+stop on runlevel [!2345]
+
+oom never
+respawn
+exec /command/s6-svscanboot
+.Ed
+.Ss systemd
+Put an appropriate unit file in the
+.Pa /etc/systemd/system
+folder, for instance
+.Pa /etc/systemd/system/s6.service .
+It will be picked up by systemd at boot time:
+.Bd -literal
+[Unit]
+Description=s6 supervision tree
+Documentation=https://skarnet.org/software/s6/
+
+[Install]
+WantedBy=multi-user.target
+
+[Service]
+Type=simple
+ExecStart=/command/s6-svscan /service
+ExecStop=/command/s6-svscanctl -t /service
+ExecReload=/command/s6-svscanctl -an /service
+Restart=always
+RestartSec=1
+.Ed
+.Pp
+Please note that, among other things, systemd performs process
+supervision, so depending on the level of integration with your
+distribution that you wish to achieve, you may be better off using
+systemd to directly manage your daemons.
+Please also note that systemd is a terrible piece of software
+engineering[1], and if at all possible, you should try and switch to a
+distribution that does not use it.
+.Ss BSD init
+Put an appropriate line in your
+.Pa /etc/ttys
+file, then reload this file with
+.Ql kill -s HUP 1 :
+.Bd -literal
+sv /command/s6-svscanboot "" on
+.Ed
+.Ss MacOS launchd
+Like systemd, launchd comes with its own way of supervising
+services[2]; if you are a launchd user, you probably do not need s6.
+.Sh SEE ALSO
+[1]
+.Lk https://skarnet.org/software/systemd.html
+.Pp
+[2]
+.Lk https://developer.apple.com/library/mac/documentation/macosx/conceptual/bpsystemstartup/chapters/CreatingLaunchdJobs.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man7/s6-why.7 b/mdoc/man7/s6-why.7
--- a/mdoc/man7/s6-why.7	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man7/s6-why.7	2023-04-16 04:52:39.114496467 -0300
@@ -0,0 +1,356 @@
+.Dd April 9, 2023
+.Dt S6-WHY 7
+.Os
+.Sh NAME
+.Nm s6-why
+.Nd why another supervision suite
+.Sh DESCRIPTION
+.Ss Why another supervision suite?
+Supervision suites are becoming quite common.
+Today, we already have:
+.Bl -bullet
+.It
+Good (?) old System V init, which can be made to supervise services if
+you perform
+.Pa /etc/inittab
+voodoo.
+BSD init can also be used the same way with the
+.Pa /etc/ttys
+file, but for some reason, nobody among BSD developers is using
+.Pa /etc/ttys
+to this purpose, so I won't consider BSD init here.
+.It
+daemontools[1], the pioneer.
+.It
+daemontools-encore[2], Bruce Guenter's upgrade to daemontools.
+.It
+runit[3], Gerrit Pape's suite, well-integrated with Debian.
+.It
+perp[4], Wayne Marshall's take on supervision.
+.It
+Integrated init systems providing a lot of features, process
+supervision being one of them.
+For instance, Upstart[5], MacOS X's launchd[6], and Fedora's
+systemd[7].
+.El
+.Pp
+Why is s6 needed?
+What does it do differently?
+Here are the criteria I used.
+.Pp
+.Sy Supervision suites should not wake up unless notified
+.Pp
+System V init fails the test: it wakes up every 5 seconds, for the
+reason that
+.Pa /dev/initctl
+might have changed.
+.Pp
+daemontools fails the test: it wakes up every 5 seconds to check for
+new services.
+.Pp
+daemontools-encore does the same.
+.Pp
+The current version of runit fails the test: it wakes up every 14
+seconds.
+But this is a workaround for a bug in some Linux kernels; there is no
+design flaw in runit that prevents it from passing the test.
+.Pp
+perp works.
+.Pp
+Upstart works.
+.Pp
+I have no idea what other integrated init systems do: it's much too
+difficult to
+.Xr strace 1
+them to see exactly where they're spending their time, and when it is
+possible, the trace output is so big that it's hard to extract any
+valuable information from it.
+.Pp
+s6 works.
+The
+.Fl t
+option to
+.Xr s6-svscan 8
+makes it check its services with a configurable timeout; by default,
+this timeout is infinite, i.e. it never wakes up unless it receives a
+command via
+.Xr s6-svscanctl 8 .
+.Pp
+.Sy Supervision suites should provide a program that can run as process 1
+.Pp
+System V init is process 1, so no problem here.
+.Pp
+Integrated init systems, by definition, provide a process 1.
+.Pp
+daemontools was not designed to take over init, although it can be
+made to work[8] with enough hacking skills.
+Same thing with daemontools-encore.
+.Pp
+runit provides an init functionality, but the mechanism is separate
+from the supervision itself; the
+.Pa runit
+process, not the
+.Pa runsvdir
+process, runs as process 1.
+This lengthens the supervision chain.
+.Pp
+perp was not designed to run as process 1.
+It probably could be made to work too without too much trouble.
+.Pp
+.Xr s6-svscan 8
+was designed from the start to be run as process 1, although it does
+not have to.
+.Pp
+.Sy Supervision suites should be bug-free, lightweight and easy to understand
+.Pp
+daemontools, daemontools-encore, runit and perp all qualify.
+All of this is excellent quality code, unsurprisingly.
+.Pp
+System V init is understandable, and reasonably lightweight; but it is
+still too big for what it does \(em poorly.
+The
+.Pa /etc/inittab
+file needs to be parsed; that parser has to be in process 1.
+There is support in process 1 for the whole
+.Dq runlevel
+concept, which is a primitive form of service management.
+The same executable handles all 3 stages of the machine's lifetime and
+does not separate them properly.
+All in all, System V init does its job, but is showing its age and
+nowadays we know much better designs.
+.Pp
+This is where integrated init systems fail, hard.
+By wanting to organize the way a the machine is operated \(em so,
+machine state management \(em in the same package as the init and
+process supervision system, they add incredible complexity where it
+does not belong:
+.Bl -bullet
+.It
+Upstart uses
+.Xr ptrace 2
+to watch its children
+.Xr fork 2 ,
+and links process 1 against libdbus.
+This is insane.
+Process 1 should be absolutely stable, it should be guaranteed to
+never crash, so the whole of its source code should be under control.
+At Upstart's level of complexity, those goals are outright impossible
+to achieve, so this approach is flawed by design.
+It is a shame, because the concepts and ideas behind Upstart are good
+and sound; it's the implementation choices that are its downfall.
+.It
+launchd suffers from the same kind of problems.
+Example: Services running under launchd must be configured using XML;
+the launchctl process interprets the XML, converts it into a key-value
+store
+.Po
+which is strictly less powerful than XML, so why do they even use XML
+in the first place?
+.Pc
+and sends it to launchd via a Mach-specific IPC.
+Process 1 needs to be linked against the library that handles the Mach
+IPC, it needs to decode the key-value store, and use it to run and
+supervise a daemon.
+And it needs to keep everything in memory.
+This is a lot more complex and resource-consuming than it needs to be.
+.It
+systemd is much, much worse than the other ones, and a real danger for
+the future of GNU/Linux.
+I have a special page dedicated to it[9].
+.El
+.Pp
+What those systems fail to recognize is that process supervision,
+rooted in process 1, is a good thing, and machine management is also a
+good thing, but
+.Em those are two different functions ,
+and a good init
+system needs, and
+.Em should ,
+only provide process supervision, in order to keep such a crucial
+piece of code as easy to maintain as possible.
+Machine management can be added
+.Em on top of
+a process supervision suite, in a different package, and it has
+nothing to do with process 1.
+.Pp
+s6, which has been designed with embedded environments in mind, tries
+harder than anyone to pass this.
+It tries so hard that
+.Xr s6-svscan 8
+and
+.Xr s6-supervise 8 ,
+the two long-running programs that make the supervision chain,
+.Em do not even allocate heap memory ,
+and their main program source files are less than 500 lines long.
+.Pp
+.Sy Supervision suites should provide a basis for high-level service management
+.Pp
+Neither System V init, daemontools, runit or perp provides any hooks
+to wait for a service to go up or down.
+runit provides a waiting mechanism, but it's based on polling, and the
+.Pa ./check
+script has to be manually written for every service.
+.Pp
+daemontools-encore qualifies: the
+.Em notify script
+can be used for inter-service communication.
+But it's just a hook: all the real notification work has to be done by
+the notify script itself, no notification framework is provided.
+.Pp
+Integrated init systems provide high-level service management themselves.
+Again, this is not good design: service management has nothing to do
+with init or process supervision, and should be implemented on top of
+it, not as a part of it.
+.Pp
+s6 comes with an event notification library
+.Po
+.Xr s6-libftrig 7
+.Pc ,
+and command-line tools based on this library, thus providing a simple
+API for future service management tools to build upon.
+.Pp
+.Sy Artistic considerations
+.Pp
+.Xr s6-svscan 8
+and
+.Xr s6-supervise 8
+are
+.Em entirely asynchronous .
+Even during trouble
+.Po
+full process table, for instance
+.Pc ,
+they'll remain reactive and instantly respond to commands they may
+receive.
+.Xr s6-supervise 8
+has even been implemented as a full deterministic finite automaton, to
+ensure it always does the right thing under any circumstance.
+Other supervision suites do not achieve that for now.
+.Pp
+daemontools' svscan[10] maintains an open pipe between a daemon and
+its logger, so even if the daemon, the logger,
+.Em and
+both supervise[11] processes die, the pipe is still the same
+.Em so no logs are lost, ever ,
+unless svscan itself dies.
+.Pp
+runit has only one supervisor, runsv[12], for both a daemon and its
+logger.
+The pipe is maintained by
+.Pa runsv .
+If the
+.Pa runsv
+process dies, the pipe disappears and logs are lost.
+So, runit does not offer as strong a guarantee as daemontools.
+.Pp
+perp has only one process, perpd[13], acting both as a
+.Dq daemon and logger supervisor
+.Po like runsv
+.Pc
+and as a
+.Dq service directory scanner
+.Po
+like runsvdir
+.Pc .
+It maintains the pipes between the daemons and their respective
+loggers.
+If perpd dies, everything is lost.
+Since perpd cannot be run as process 1, this is a possible SPOF for a
+perp installation; however, perpd is well-written and has virtually no
+risk of dying, especially compared to process 1 behemoths provided by
+integrated init systems.
+.Pp
+Besides, the
+.Pa runsv
+model, which has to handle both a daemon and its logger, is more
+complex than the
+.Pa supervise
+model
+.Po
+which only has to handle a daemon
+.Pc .
+Consequently, the
+.Pa runsvdir
+model is simpler than the
+.Pa svscan
+model, but there is only one
+.Pa svscan
+instance when there are several
+.Pa runsv Ns s
+and
+.Pa supervise Ns
+s .
+The
+.Pa perpd
+model is obviously the most complex; while very understandable,
+.Pa perpd
+is unarguably harder to maintain than the other two.
+.Pp
+So, to achieve maximum simplicity and code reuse, and minimal memory
+footprint, s6's design is close to daemontools' one.
+And when
+.Xr s6-svscan 8
+is run as process 1
+.Po
+cf.\&
+.Xr s6-svscan-as-process-1 7
+.Pc ,
+pipes between daemons and loggers are never lost.
+.Pp
+.Sy Conclusion
+.Pp
+All in all, I believe that s6 offers the best overall implementation
+of a supervision suite as it should be designed.
+At worst, it's just another take on daemontools with a reliable base
+library and a few nifty features.
+.Sh SEE ALSO
+.Xr s6-libftrig 7 ,
+.Xr s6-svscan-as-process-1 7 ,
+.Xr s6-supervise 8 ,
+.Xr s6-svscan 8 ,
+.Xr s6-svscanctl 8
+.Pp
+[1]
+.Lk https://cr.yp.to/daemontools.html
+.Pp
+[2]
+.Lk https://untroubled.org/daemontools-encore/
+.Pp
+[3]
+.Lk http://smarden.org/runit/
+.Pp
+[4]
+.Lk http://b0llix.net/perp/
+.Pp
+[5]
+.Lk https://upstart.ubuntu.com/
+.Pp
+[6]
+.Lk https://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man8/launchd.8.html
+.Pp
+[7]
+.Lk https://freedesktop.org/wiki/Software/systemd
+.Pp
+[8]
+.Lk https://code.dogmap.org./svscan-1/
+.Pp
+[9]
+.Lk https://skarnet.org/software/systemd.html
+.Pp
+[10]
+.Lk https://cr.yp.to/daemontools/svscan.html
+.Pp
+[11]
+.Lk https://cr.yp.to/daemontools/supervise.html
+.Pp
+[12]
+.Lk http://smarden.org/runit/runsv.8.html
+.Pp
+[13]
+.Lk http://b0llix.net/perp/site.cgi?page=perpd.8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/why.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-accessrules-cdb-from-fs.8 b/mdoc/man8/s6-accessrules-cdb-from-fs.8
--- a/mdoc/man8/s6-accessrules-cdb-from-fs.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-accessrules-cdb-from-fs.8	2023-04-16 04:52:39.114496467 -0300
@@ -0,0 +1,179 @@
+.Dd September 29, 2021
+.Dt S6-ACCESSRULES-CDB-FROM-FS 8
+.Os
+.Sh NAME
+.Nm s6-accessrules-cdb-from-fs
+.Nd compile a directory containing a ruleset suitable for
+.Xr s6-ipcserver-access 8
+or
+.Xr s6-tcpserver-access 8
+into a CDB[1] file
+.Sh SYNOPSIS
+.Nm
+.Ar cdbfile
+.Ar dir
+.Sh DESCRIPTION
+.Nm
+compiles the
+.Ar dir
+directory containing a ruleset into a CDB[1] file
+.Ar cdbfile
+then exits 0.
+.Ss Ruleset directory format
+To be understood by
+.Nm ,
+.Xr s6-ipcserver-access 8 ,
+or
+.Xr s6-tcpserver-access 8 ,
+.Ar dir
+must have a specific format.
+.Pp
+.Ar dir
+contains a series of directories:
+.Bl -bullet -width x
+.It
+.Pa ip4
+for rules on IPv4 addresses.
+.It
+.Pa ip6
+for rules on IPv6 addresses.
+.It
+.Pa reversedns
+for rules on host names.
+.It
+.Pa uid
+for rules on user IDs.
+.It
+.Pa gid
+for rules on group IDs.
+.El
+.Pp
+Depending on the application, other directories can appear in
+.Ar dir
+and be compiled into
+.Ar cdbfile ,
+but
+.Xr s6-tcpserver-access 8
+only uses the first three, and
+.Xr s6-ipcserver-access 8
+only uses the last two.
+.Pp
+Each of those directories contains a set of rules.
+A rule is a subdirectory named after the set of keys it matches, and
+containing actions that will be executed if the rule is the first
+matching rule for the tested key.
+.Pp
+The syntax for the rule name is dependent on the nature of keys, and
+fully documented in
+.Xr s6-accessrules 7 .
+For instance, a subdirectory named 192.168.0.0_27 in the
+.Pa ip4
+directory will match every IPv4 address in the 192.168.0.0/27 network
+that does not match a more precise rule.
+.Pp
+The syntax for the actions, however, is the same for every type of
+key.
+A rule subdirectory can contain the following elements:
+.Bl -bullet -width x
+.It
+A file (that can be empty) named
+.Pa allow .
+If such a file exists, a key matching this rule will be immediately
+accepted.
+.It
+A file (that can be empty) named
+.Pa deny .
+If such a file exists and no
+.Pa allow
+file exists, a key matching this rule will be immediately denied.
+.It
+A subdirectory named
+.Pa env .
+If such a directory exists along with an
+.Pa allow
+file, then its contents represent environment modifications that will
+be applied after accepting the connection and before executing the
+next program in the chain, as if the
+.Xr s6-envdir 8
+program, without options, was applied to
+.Pa env .
+.Pa env
+has exactly the same format as a directory suitable for
+.Xr s6-envdir 8 ;
+however, if the modifications take up more than 4096 bytes when
+compiled into
+.Ar cdbfile ,
+then
+.Nm
+will complain and exit 100.
+.It
+A file named
+.Pa exec .
+If such a file exists along with an
+.Pa allow
+file, then its contents represent a command line that, interpreted by
+the
+.Xr execlineb 1
+launcher, will be executed after accepting the connection, totally
+bypassing the original command line.
+.Nm
+truncates the
+.Pa exec
+file to 4096 bytes max when embedding it into
+.Ar cdbfile ,
+so make sure it is not larger than that.
+.El
+.Pp
+.Ar cdbfile
+can exist prior to, and during, the compilation, which actually works
+in a temporary file in the same directory as
+.Ar cdbfile
+and performs an atomic replacement when it is done.
+So it is not necessary to interrupt a running service during the
+compilation.
+.Pp
+If
+.Nm
+fails at some point, the temporary file is removed.
+However, this doesn't happen if
+.Nm
+is interrupted by a signal.
+.Pp
+After the program successfully completes, if
+.Ar dir
+was a suitable candidate for the
+.Fl i
+option of
+.Xr s6-ipcserver-access 8
+or
+.Xr s6-tcpserver-access 8 ,
+then
+.Ar cdbfile
+will be a suitable candidate for the
+.Fl x
+option of the same program, implementing the same ruleset.
+.Pp
+.Ar cdbfile
+can be decompiled by the
+.Xr s6-accessrules-fs-from-cdb 8
+program.
+.Sh SEE ALSO
+.Xr execlineb 1 ,
+.Xr s6-accessrules-fs-from-cdb 8 ,
+.Xr s6-connlimit 8 ,
+.Xr s6-ioconnect 8 ,
+.Xr s6-ipcclient 8 ,
+.Xr s6-ipcserver 8 ,
+.Xr s6-ipcserver-access 8 ,
+.Xr s6-ipcserver-socketbinder 8 ,
+.Xr s6-ipcserverd 8 ,
+.Xr s6-tcpserver-access 8
+.Pp
+[1]
+.Lk https://en.wikipedia.org/wiki/Cdb_(software)
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-accessrules-cdb-from-fs.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-accessrules-fs-from-cdb.8 b/mdoc/man8/s6-accessrules-fs-from-cdb.8
--- a/mdoc/man8/s6-accessrules-fs-from-cdb.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-accessrules-fs-from-cdb.8	2023-04-16 04:52:39.114496467 -0300
@@ -0,0 +1,75 @@
+.Dd September 29, 2021
+.Dt S6-ACCESSRULES-FS-FROM-CDB 8
+.Os
+.Sh NAME
+.Nm s6-accessrules-fs-from-cdb
+.Nd decompile a CDB[1] database containing a ruleset suitable for
+.Xr s6-ipcserver-access 8
+or
+.Xr s6-tcpserver-access 8
+and that has been compiled with
+.Xr s6-accessrules-cdb-from-fs 8
+.Sh SYNOPSIS
+.Nm
+.Ar dir
+.Ar cdbfile
+.Sh DESCRIPTION
+.Nm
+decompiles the CDB[1] file
+.Ar cdbfile
+into the directory
+.Ar dir ,
+then exits 0.
+.Pp
+.Ar dir
+must not exist prior to the decompilation.
+.Pp
+.Ar dir
+must be considered a work in progress as long as
+.Nm
+is running.
+It is only safe to use
+.Ar dir
+as a ruleset once the program has exited.
+.Pp
+If
+.Nm
+fails at some point, the partial arborescence at
+.Ar dir
+is removed.
+However, this doesn't happen if
+.Nm
+is interrupted by a signal.
+.Pp
+After the program successfully completes, if
+.Ar cdbfile
+was a suitable candidate for the
+.Fl x
+option of
+.Xr s6-ipcserver-access 8
+or
+.Xr s6-tcpserver-access 8 ,
+then
+.Ar dir
+will be a suitable candidate for the
+.Fl i
+option of the same program, implementing the same ruleset.
+.Sh SEE ALSO
+.Xr s6-accessrules-cdb-from-fs 8 ,
+.Xr s6-connlimit 8 ,
+.Xr s6-ioconnect 8 ,
+.Xr s6-ipcclient 8 ,
+.Xr s6-ipcserver 8 ,
+.Xr s6-ipcserver-access 8 ,
+.Xr s6-ipcserver-socketbinder 8 ,
+.Xr s6-ipcserverd 8 ,
+.Xr s6-tcpserver-access 8
+.Pp
+[1]
+.Lk https://en.wikipedia.org/wiki/Cdb_(software)
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-accessrules-fs-from-cdb.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-applyuidgid.8 b/mdoc/man8/s6-applyuidgid.8
--- a/mdoc/man8/s6-applyuidgid.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-applyuidgid.8	2023-04-16 04:52:39.114496467 -0300
@@ -0,0 +1,82 @@
+.Dd September 29, 2021
+.Dt S6-APPLYUIDGID 8
+.Os
+.Sh NAME
+.Nm s6-applyuidgid
+.Nd execute a program with reduced privileges
+.Sh SYNOPSIS
+.Nm
+.Op Fl z
+.Op Fl u Ar uid
+.Op Fl g Ar gid
+.Op Fl G Ar gidlist
+.Op Fl U
+.Ar prog...
+.Sh DESCRIPTION
+.Nm
+sets its uid, gid and supplementary group list to the values given,
+then executes into
+.Ar prog .
+.Nm
+can only be run as root.
+Its main use is to drop root privileges before starting a daemon.
+.Nm
+is a more generic version of
+.Xr s6-setuidgid 8 .
+It is used as a command line building block by some programs that
+rewrite their command line, such as
+.Xr s6-tcpserver 8 .
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl u Ar uid
+Set the process' user ID to
+.Ar uid .
+.It Fl g Ar gid
+Set the process' group ID to
+.Ar gid .
+.It Fl G Ar gidlist
+Set the process' supplementary group list to
+.Ar gidlist ,
+which must be given as a comma-separated list of numeric GIDs, without
+spaces.
+.It Fl U
+Set the process' user ID, group ID and supplementary group list to the
+values of the
+.Ev UID ,
+.Ev GID
+and
+.Ev GIDLIST
+environment variables.
+If a
+.Fl u ,
+.Fl g
+or
+.Fl G
+option is given after
+.Fl U ,
+the command line value overrides the environment variable.
+.It Fl z
+Unexport.
+The
+.Ev UID ,
+.Ev GID
+and
+.Ev GIDLIST
+variables will be removed from the process environment.
+.El
+.Sh SEE ALSO
+.Xr s6-envdir 8 ,
+.Xr s6-envuidgid 8 ,
+.Xr s6-fghack 8 ,
+.Xr s6-setsid 8 ,
+.Xr s6-setuidgid 8 ,
+.Xr s6-softlimit 8 ,
+.Xr s6-tai64n 8 ,
+.Xr s6-tai64nlocal 8 ,
+.Xr s6-tcpserver 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-applyuidgid.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-cleanfifodir.8 b/mdoc/man8/s6-cleanfifodir.8
--- a/mdoc/man8/s6-cleanfifodir.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-cleanfifodir.8	2023-04-16 04:52:39.114496467 -0300
@@ -0,0 +1,37 @@
+.Dd September 29, 2021
+.Dt S6-CLEANFIFODIR 8
+.Os
+.Sh NAME
+.Nm s6-cleanfifodir
+.Nd clean up an
+.Xr s6-fifodir 7
+.Sh SYNOPSIS
+.Nm
+.Ar fifodir
+.Sh DESCRIPTION
+.Nm
+cleans up
+.Ar fifodir ,
+that must belong to the current user.
+That means it removes all stale FIFOs in
+.Ar fifodir .
+.Pp
+In normal use, it is not necessary to call
+.Nm .
+However, stale FIFOs can be left by
+.Xr s6-ftrigrd 8
+processes that were violently killed, so it's good practice to
+regularly clean up fifodirs.
+.Sh SEE ALSO
+.Xr s6-ftrig-listen 8 ,
+.Xr s6-ftrig-listen1 8 ,
+.Xr s6-ftrig-notify 8 ,
+.Xr s6-ftrig-wait 8 ,
+.Xr s6-ftrigrd 8 ,
+.Xr s6-mkfifodir 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-cleanfifodir.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-connlimit.8 b/mdoc/man8/s6-connlimit.8
--- a/mdoc/man8/s6-connlimit.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-connlimit.8	2023-04-16 04:52:39.115496467 -0300
@@ -0,0 +1,129 @@
+.Dd September 29, 2021
+.Dt S6-CONNLIMIT 8
+.Os
+.Sh NAME
+.Nm s6-connlimit
+.Nd perform IP-based control on the number of client connections to a TCP socket, and uid-based control on the number of client connections to a Unix domain socket
+.Sh SYNOPSIS
+.Nm
+.Ar prog...
+.Sh DESCRIPTION
+.Nm
+reads its environment for the
+.Ev PROTO
+environment variable, and then for
+.Ev ${PROTO}CONNNUM
+and
+.Ev ${PROTO}CONNMAX ,
+which must contain integers.
+.Pp
+If the value of
+.Ev ${PROTO}CONNNUM
+is superior or equal to the value of
+.Ev ${PROTO}CONNMAX ,
+.Nm
+exits 1 with an error message.
+.Pp
+Else it execs into
+.Ar prog... .
+.Pp
+If
+.Ev ${PROTO}CONNMAX
+is unset,
+.Nm
+directly execs into
+.Ar prog...
+without performing any check: no maximum number of connections has
+been defined.
+.Pp
+The
+.Xr s6-tcpserver4 8
+and
+.Xr s6-tcpserver6 8
+programs define the
+.Ev PROTO
+environment variable to
+.Dq TCP ,
+and spawn every child server with the
+.Ev TCPCONNNUM
+environment variable set to the number of connections from the same IP
+address.
+The
+.Xr s6-tcpserver-access 8
+program can set environment variables depending on the client's IP
+address.
+If the
+s6-tcpserver-access
+database is configured to set the
+.Ev TCPCONNMAX
+environment variable for a given set of IP addresses, and
+s6-tcpserver-access
+execs into
+.Nm ,
+then
+.Nm
+will drop connections if there already are
+.Ev ${TCPCONNMAX}
+connections from the same client IP address.
+.Pp
+The
+.Xr s6-ipcserver 8
+and
+.Xr s6-ipcserver-access 8
+programs can be used the same way, with
+.Dq IPC
+instead of
+.Dq TCP ,
+to limit the number of client connections by UID.
+.Pp
+The
+.Nm
+utility was once part of the s6-networking[1] suite, and is mostly useful
+with TCP connections, which is why the examples here involve TCP.
+Nevertheless, it can be used with connections across Unix domain
+sockets, and that is why it has been moved to the s6 package.
+.Sh EXAMPLES
+The following command line:
+.Bd -literal -offset indent
+s6-tcpserver4 -v2 -c1000 -C40 1.2.3.4 80 \
+  s6-tcpserver-access -v2 -RHl0 -i dir \
+  s6-connlimit \
+  prog...
+.Ed
+.Pp
+will run a server listening to IPv4 address 1.2.3.4, on port 80,
+serving up to 1000 concurrent connections, and up to 40 concurrent
+connections from the same IP address, no matter what the IP
+address.
+For every client connection, it will look up the database set up in
+.Ql dir ;
+if the connection is accepted, it will run
+.Ql prog... .
+.Pp
+If the
+.Pa dir/ip4/5.6.7.8_32/env/TCPCONNMAX
+file exists and contains the string 30, then at most 30 concurrent
+connections from 5.6.7.8 will execute
+.Ql prog... ,
+instead of the default of 40.
+.Sh SEE ALSO
+.Xr s6-accessrules-cdb-from-fs 8 ,
+.Xr s6-accessrules-fs-from-cdb 8 ,
+.Xr s6-ioconnect 8 ,
+.Xr s6-ipcclient 8 ,
+.Xr s6-ipcserver 8 ,
+.Xr s6-ipcserver-access 8 ,
+.Xr s6-ipcserver-socketbinder 8 ,
+.Xr s6-ipcserverd 8 ,
+.Xr s6-tcpserver-access 8 ,
+.Xr s6-tcpserver4 8 ,
+.Xr s6-tcpserver6 8
+.Pp
+[1]
+.Lk https://skarnet.org/software/s6-networking/
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-connlimit.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-envdir.8 b/mdoc/man8/s6-envdir.8
--- a/mdoc/man8/s6-envdir.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-envdir.8	2023-04-16 04:52:39.115496467 -0300
@@ -0,0 +1,116 @@
+.Dd March 13, 2022
+.Dt S6-ENVDIR 8
+.Os
+.Sh NAME
+.Nm s6-envdir
+.Nd change environment, then execute into another program
+.Sh SYNOPSIS
+.Nm
+.Op Fl I | i
+.Op Fl n
+.Op Fl f
+.Op Fl L
+.Op Fl c Ar nullis
+.Ar dir
+.Ar prog...
+.Sh DESCRIPTION
+.Nm
+reads files in
+.Ar dir .
+For every file
+.Em f
+in
+.Ar dir ,
+that does not begin with a dot and does not contain the
+.Ql =
+character:
+.Bl -bullet -width x
+.It
+If
+.Em f
+is empty, remove a variable named
+.Ev f
+from the environment, if any.
+.It
+Else add a variable named
+.Ev f
+to the environment (or replace
+.Ev f
+if it already exists) with the first line of the contents of file
+.Pa f
+as value.
+Spaces and tabs at the end of this line are removed, as well as any
+trailing newline; null characters in this line are changed to newlines
+in the environment variable.
+.El
+.Pp
+.Nm
+without options behaves exactly like envdir[1].
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl i
+Strict.
+If
+.Ar dir
+does not exist, exit 111 with an error message.
+This is the default.
+.It Fl I
+Loose.
+If
+.Ar dir
+does not exist, exec into
+.Ar prog
+without modifying the environment first.
+.It Fl f
+Verbatim mode.
+All the file is given as the value of the environment variable,
+including newlines (except the last one if the
+.Fl n
+option is not given).
+Null characters are still translated.
+.It Fl n
+Do not chomp.
+If the
+.Fl f
+option is given and the file ends with a newline, keep that last
+newline in the value.
+If the
+.Fl f
+option is not given, keep the trailing blanks at the end of the first
+line (but not the ending newline).
+.It Fl L
+Do not clamp.
+With this option,
+.Nm
+will process the whole first line of each file (if the
+.Fl f
+option hasn't been given) or read each file entirely (if the
+.Fl f
+option has been given), even if it means adding huge variables to the
+environment.
+Without this option,
+.Nm
+only reads the first 4096 bytes of each file.
+.It Fl c Ar nullis
+Replace null characters with the first character of
+.Ar nullis
+instead of a newline.
+.El
+.Sh SEE ALSO
+.Xr s6-applyuidgid 8 ,
+.Xr s6-envuidgid 8 ,
+.Xr s6-fghack 8 ,
+.Xr s6-setsid 8 ,
+.Xr s6-setuidgid 8 ,
+.Xr s6-softlimit 8 ,
+.Xr s6-tai64n 8 ,
+.Xr s6-tai64nlocal 8
+.Pp
+[1]
+.Lk https://cr.yp.to/daemontools/envdir.html
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-envdir.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-envuidgid.8 b/mdoc/man8/s6-envuidgid.8
--- a/mdoc/man8/s6-envuidgid.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-envuidgid.8	2023-04-16 04:52:39.115496467 -0300
@@ -0,0 +1,167 @@
+.Dd September 29, 2021
+.Dt S6-ENVUIDGID 8
+.Os
+.Sh NAME
+.Nm s6-envuidgid
+.Nd potentially set the
+.Ev UID ,
+.Ev GID
+and
+.Ev GIDLIST
+environment variables according to the options and arguments it is
+given, then execute into another program
+.Sh SYNOPSIS
+.Nm
+.Op Fl u | g | B
+.Op Fl n
+.Op Fl i | D Ar uid : Ns Ar gid : Ns Ar gidlist
+.Ar account
+.Ar prog...
+.Sh DESCRIPTION
+.Nm
+looks
+.Ar account
+up by name in the account database.
+.Pp
+It sets the UID environment variable to
+.Ar account Ap
+s uid, and the GID environment variable to
+.Ar account Ap
+s gid.
+.Pp
+It also sets the
+.Ev GIDLIST
+environment variable to a comma-separated list of supplementary group
+ids
+.Ar account
+is a member of according to the group database. (If
+.Ar account
+doesn't belong to any other group than its primary group,
+.Ev GIDLIST
+is still set, but empty.)
+.Pp
+Then it executes into
+.Ar prog... .
+.Pp
+.Nm
+without options behaves like envuidgid[1], except that the exit code is 1 if
+.Ar account
+doesn't exist, and it also exports supplementary groups.
+.Pp
+.Nm
+is useful when running a program that must start as root but can drop
+its privileges later.
+Such a program can read its new uid/gid/groups info from the
+.Ev UID ,
+.Ev GID
+and
+.Ev GIDLIST
+environment variables.
+Super-servers such as
+.Xr s6-tcpserver4 8
+make use of this.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl u
+User.
+.Ar account
+will be interpreted as a user name; the
+.Ev UID
+environment variable will be set to its numerical value, and the
+.Ev GID
+and
+.Ev GIDLIST
+variables will not be touched.
+.It Fl g
+Group.
+.Ar account
+will be interpreted as a group name instead of a user name; the
+.Ev GID
+environment variable will be set to its numerical value, and the
+.Ev UID
+and
+.Ev GIDLIST
+variables will not be touched.
+.It Fl B
+Both user and group.
+.Ar account
+will be interpreted as
+.Sm off
+.So
+.Em user :
+.Em group
+.Sc .
+.Sm on
+The
+.Ev GIDLIST
+variable will not be touched.
+If
+.Em user
+does not exist, the
+.Ev UID
+variable will be set to 0 unless a better default is provided with the
+.Fl D
+option.
+If
+.Em group
+does not exist, the
+.Ev GID
+variable will be set to 0 unless a better default is provided with the
+.Fl D
+option.
+.It Fl n
+Numerical fallback.
+If
+.Ar account
+cannot be found in the user or group database, try to interpret the
+given values literally.
+For instance,
+.Ql s6-envuidgid -B root:42
+will fail if there's no group named
+.Ql 42
+in the group database, but
+.Ql s6-envuidgid -nB root:42
+will set
+.Ev UID
+to 0 and
+.Ev GID
+to 42.
+.It Fl i
+Insist.
+If
+.Ar account
+is unknown, exit 1 with an error message.
+This is the default.
+.It Fl D Ar uid : Ns Ar gid : Ns Ar gidlist
+If
+.Ar account
+is unknown, use
+.Ar uid ,
+.Ar gid
+and
+.Ar gidlist
+as the values for
+.Ev UID ,
+.Ev GID
+and
+.Ev GIDLIST .
+.El
+.Sh SEE ALSO
+.Xr s6-applyuidgid 8 ,
+.Xr s6-envdir 8 ,
+.Xr s6-fghack 8 ,
+.Xr s6-setsid 8 ,
+.Xr s6-setuidgid 8 ,
+.Xr s6-softlimit 8 ,
+.Xr s6-tai64n 8 ,
+.Xr s6-tai64nlocal 8 ,
+.Xr s6-tcpserver4 8
+.Pp
+[1]
+.Lk https://cr.yp.to/daemontools/envuidgid.html
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-envuidgid.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-fdholder-daemon.8 b/mdoc/man8/s6-fdholder-daemon.8
--- a/mdoc/man8/s6-fdholder-daemon.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-fdholder-daemon.8	2023-04-16 04:52:39.115496467 -0300
@@ -0,0 +1,225 @@
+.Dd September 29, 2021
+.Dt S6-FDHOLDER-DAEMON 8
+.Os
+.Sh NAME
+.Nm s6-fdholder-daemon
+.Nd fd-holding daemon
+.Sh SYNOPSIS
+.Nm
+.Op Fl 1
+.Op Fl v Ar verbosity
+.Op Fl d | D
+.Op Fl c Ar maxconn
+.Op Fl n Ar maxfds
+.Op Fl b Ar backlog
+.Op Fl G Ar gidlist
+.Op Fl g Ar gid
+.Op Fl u Ar uid
+.Op Fl U
+.Op Fl t Ar clienttimeout
+.Op Fl T Ar lameducktimeout
+.Op Fl i Ar rulesdir | Fl x Ar rulesfile
+.Ar path
+.Sh DESCRIPTION
+.Nm
+listens on a Unix domain socket, then accepts client connections; it
+stores file descriptors on behalf of clients, along with an identifier
+for every file descriptor stored, and possibly an expiration date
+(after which the file descriptor will be forgotten).
+It also allows clients to retrieve a file descriptor by its
+identifier.
+.Pp
+.Nm
+parses the options and arguments it is given, and builds a new command
+line with them.
+It then executes into that new command line.
+.Pp
+The first program
+.Nm
+executes into is
+.Xr s6-ipcserver-socketbinder 8 .
+It will create and bind a Unix domain socket to
+.Ar path ,
+then execute into the rest of the command line.
+.Pp
+If a privilege-dropping operation has been requested, the program that
+.Xr s6-ipcserver-socketbinder 8
+executes into is
+.Xr s6-applyuidgid 8 .
+It will drop root privileges, then execute into the rest of the
+command line.
+.Pp
+The last program in the chain is
+.Xr s6-fdholderd 8 .
+It is executed into by
+.Xr s6-applyuidgid 8 ,
+or directly by
+.Xr s6-ipcserver-socketbinder 8
+if no privilege-dropping operation has been requested.
+.Xr s6-fdholderd 8
+is the long-lived process, the daemon itself, performing fd holding
+and accepting connections from clients.
+.Pp
+.Nm
+does not interpret its options itself.
+It just dispatches them to the appropriate program on the command line
+that it builds.
+.Pp
+From the user's point of view,
+.Nm
+behaves like a long-lived process, even if the long-lived process
+itself is called
+.Xr s6-fdholderd 8 .
+Every operational detail of
+.Xr s6-fdholderd 8
+applies to
+.Nm
+as well; in particular, make sure to properly configure the clients'
+access rights, as described in
+.Xr s6-fdholderd 8 .
+.Pp
+.Nm
+is meant to be used in an s6 run script, as a supervised local
+service.
+It does not fork itself or write to syslog.
+However, it can be run under any infrastructure, including other
+supervision infrastructures, OpenRC, systemd, or SysV scripts.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl 1
+Write a newline to stdout, before closing it, right after binding and
+listening to the Unix socket.
+If stdout is suitably redirected, this can be used by monitoring
+programs to check when the server is ready to accept connections.
+.It Fl v Ar verbosity
+Be quiet, normally verbose, or more verbose, depending on if verbosity
+is 0, 1, or more.
+The default is 1.
+.It Fl d
+Allow instant rebinding to the same path even if it has been used not
+long ago - this is the
+.Dv SO_REUSEADDR
+flag to
+.Xr setsockopt 2
+and is generally used with server programs.
+This is the default.
+Note that
+.Ar path
+will be deleted if it already exists at program start time.
+.It Fl D
+Disallow instant rebinding to the same path.
+.It Fl c Ar maxconn
+Accept at most
+.Ar maxconn
+concurrent client connections.
+Default is 16.
+It is impossible to set it higher than the value of the
+.Dv S6_FDHOLDER_MAX
+macro, which is 256.
+Client connections to this server are short-lived, so this number
+needs not be too high.
+Every client connection eats up one available file descriptor, so it
+is best for
+.Ar maxconn
+to be as small as possible.
+.It Fl n Ar maxfds
+Store at most
+.Ar maxfds
+file descriptors.
+Default is 1000.
+It is impossible to set it higher than the number of files that can be
+opened by the
+.Nm
+process minus a few descriptors needed for correct
+.Xr s6-fdholderd 8
+operation.
+Before running
+.Nm ,
+make sure to properly adjust, via
+.Xr s6-softlimit 8 ,
+the number of openable files[1] of the current process.
+.It Fl b Ar backlog
+Set a maximum of
+.Ar backlog
+backlog connections on the socket.
+Extra connection attempts will rejected by the kernel.
+.It Fl G Ar gidlist
+Change
+.Nm Ap
+s supplementary group list to
+.Ar gidlist
+after binding the socket.
+This is only valid when run as root.
+.Ar gidlist
+must be a comma-separated list of numerical group IDs.
+.It Fl g Ar gid
+Change
+.Nm Ap
+s groupid to
+.Ar gid
+after binding the socket.
+This is only valid when run as root.
+.It Fl u Ar uid
+Change
+.Nm Ap
+s userid to
+.Ar uid
+after binding the socket.
+This is only valid when run as root.
+.It Fl U
+Change
+.Nm Ap
+s user id, group id and supplementary group list according to the
+values of the
+.Ev UID ,
+.Ev GID
+and
+.Ev GIDLIST
+environment variables after binding the socket.
+This is only valid when run as root.
+This can be used with the
+.Xr s6-envuidgid 8
+program to easily script a service that binds to a privileged socket
+then drops its privileges to those of a named non-root account.
+.It Fl t Ar clienttimeout
+Disconnect a client if it's in the middle of an operation and it has
+not written or read any data in
+.Ar clienttimeout
+milliseconds.
+By default,
+.Ar clienttimeout
+is 0, which means infinite.
+.It Fl T Ar lameducktimeout
+Give clients
+.Ar lameducktimeout
+milliseconds to finish their current operation before exiting after
+.Xr s6-fdholderd 8
+has received a SIGTERM.
+By default,
+.Ar lameducktimeout
+is 0, which means infinite.
+.It Fl x Ar rulesfile
+Read access rights configuration from CDB file
+.Ar rulesfile .
+.It Fl i Ar rulesdir
+Read access rights configuration from the filesystem in directory
+.Ar rulesdir .
+.El
+.Sh SEE ALSO
+.Xr s6-fdholder-delete 8 ,
+.Xr s6-fdholder-getdump 8 ,
+.Xr s6-fdholder-list 8 ,
+.Xr s6-fdholder-retrieve 8 ,
+.Xr s6-fdholder-setdump 8 ,
+.Xr s6-fdholder-store 8 ,
+.Xr s6-fdholder-transferdump 8 ,
+.Xr s6-fdholderd 8
+.Pp
+[1]
+.Lk https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_resource.h.html
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-fdholder-daemon.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-fdholder-delete.8 b/mdoc/man8/s6-fdholder-delete.8
--- a/mdoc/man8/s6-fdholder-delete.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-fdholder-delete.8	2023-04-16 04:52:39.116496467 -0300
@@ -0,0 +1,74 @@
+.Dd September 29, 2021
+.Dt S6-FDHOLDER-DELETE 8
+.Os
+.Sh NAME
+.Nm s6-fdholder-delete
+.Nd connect to an
+.Xr s6-fdholderd 8
+daemon listening on a Unix domain socket, and delete a file
+descriptor from the daemon storage
+.Sh SYNOPSIS
+.Nm
+.Op Fl t Ar timeout
+.Ar path
+.Ar id
+.Sh DESCRIPTION
+.Nm
+connects to an
+.Xr s6-fdholderd 8
+server process listening on
+.Ar path .
+.Pp
+It tells the server to close the file descriptor that has been stored
+with identifier
+.Ar id .
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl t Ar timeout
+If the operation cannot be processed in
+.Ar timeout
+milliseconds, then fail with an error message.
+Communications with the server should be near-instant, so this option
+is only here to protect users against programming errors (connecting
+to the wrong socket, for instance).
+.El
+.Sh EXIT STATUS
+.Bl -tag -width x
+.It 0
+Success.
+.It 1
+The server denied the operation.
+The meanings of the error messages are explained in
+.Xr s6-fdholder-error-codes 7 .
+.It 100
+Wrong usage.
+.It 111
+System call failed - this includes attempting to connect to a
+nonexistent socket, or one where no
+.Xr s6-fdholderd 8
+daemon is listening.
+.El
+.Sh EXAMPLES
+.Dl s6-fdholder-delete /service/fdholderd/s MYSOCKET
+.Pp
+will tell an
+.Xr s6-fdholderd 8
+daemon listening on the
+.Pa /service/fdholderd/s
+socket to close the file descriptor identified as
+.Ql MYSOCKET .
+.Sh SEE ALSO
+.Xr s6-fdholder-daemon 8 ,
+.Xr s6-fdholder-getdump 8 ,
+.Xr s6-fdholder-list 8 ,
+.Xr s6-fdholder-retrieve 8 ,
+.Xr s6-fdholder-setdump 8 ,
+.Xr s6-fdholder-store 8 ,
+.Xr s6-fdholder-transferdump 8 ,
+.Xr s6-fdholderd 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-fdholder-delete.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-fdholder-getdump.8 b/mdoc/man8/s6-fdholder-getdump.8
--- a/mdoc/man8/s6-fdholder-getdump.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-fdholder-getdump.8	2023-04-16 04:52:39.116496467 -0300
@@ -0,0 +1,127 @@
+.Dd September 29, 2021
+.Dt S6-FDHOLDER-GETDUMP 8
+.Os
+.Sh NAME
+.Nm s6-fdholder-getdump
+.Nd connect to an
+.Xr s6-fdholderd 8
+daemon listening on a Unix domain socket, and retrieves its entire
+state: file descriptors with their identifiers and expiration dates
+.Sh SYNOPSIS
+.Nm
+.Op Fl t Ar timeout
+.Ar path
+.Ar prog...
+.Sh DESCRIPTION
+.Nm
+connects to an
+.Xr s6-fdholderd 8
+server process listening on
+.Ar path .
+.Pp
+It retrieves a copy of the whole set of file descriptors stored in
+this daemon, including their identifiers and expiration dates.
+.Pp
+It then executes into
+.Ar prog...
+with the additional open descriptors and the additional environment
+variables.
+.Pp
+Getting the whole state of an
+.Xr s6-fdholderd 8
+daemon requires specific privileges.
+Make sure you properly configure
+.Xr s6-fdholderd 8
+access rights so your client can perform that operation.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl t Ar timeout
+If the operation cannot be processed in
+.Ar timeout
+milliseconds, then fail with an error message.
+Communications with the server should be near-instant, so this option
+is only here to protect users against programming errors (connecting
+to the wrong socket, for instance).
+.El
+.Sh ENVIRONMENT
+.Ar prog...
+is executed with the following environment variables set:
+.Bl -bullet -width x
+.It
+.Ev S6_FD#
+contains the number
+.Va n
+of file descriptors retrieved from the server.
+.It
+Then, for every
+.Va i
+between 0 and
+.Va n Ns -1
+inclusive:
+.Bl -tag -width x
+.It Ev S6_FD_ Ns Va i
+Contains the number of the
+.Va i Ns th
+open file descriptor.
+.It Ev S6_FDID_ Ns Va i
+Contains the identifier of the
+.Va i Ns th
+open file descriptor.
+.It Ev S6_FDLIMIT_ Ns Va i
+Contains the expiration date of the
+.Va i Ns th
+open file descriptor, if applicable.
+That date is stored in external TAI64N format[1].
+If the file descriptor is not supposed to expire, this
+environment variable is not defined.
+.El
+.El
+.Sh EXIT STATUS
+On success, the program doesn't exit; instead, it execs into
+.Ar prog... .
+.Bl -tag -width x
+.It 1
+The server denied the operation.
+The meanings of the error messages are explained in
+.Xr s6-fdholder-error-codes 7 .
+.It 100
+Wrong usage.
+.It 111
+System call failed - this includes attempting to connect to a
+nonexistent socket, or one where no
+.Xr s6-fdholderd 8
+daemon is listening.
+.El
+.Sh EXAMPLES
+.Dl s6-fdholder-getdump /service/fdholderd/s s6-fdholder-setdump /service/fdholderd-2/s
+.Pp
+will get the state of the
+.Xr s6-fdholderd 8
+daemon listening on the
+.Pa /service/fdholderd/s
+socket, and transmit it to the other
+.Xr s6-fdholderd 8
+daemon listening on the
+.Pa /service/fdholderd-2/s
+socket.
+Note that in this precise case, the
+.Xr s6-fdholder-transferdump 8
+program does the same thing more efficiently.
+.Sh SEE ALSO
+.Xr s6-fdholder-daemon 8 ,
+.Xr s6-fdholder-delete 8 ,
+.Xr s6-fdholder-list 8 ,
+.Xr s6-fdholder-retrieve 8 ,
+.Xr s6-fdholder-setdump 8 ,
+.Xr s6-fdholder-store 8 ,
+.Xr s6-fdholder-transferdump 8 ,
+.Xr s6-fdholderd 8 ,
+.Pp
+[1]
+.Lk https://cr.yp.to/libtai/tai64.html#tai64n
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-fdholder-getdump.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-fdholder-list.8 b/mdoc/man8/s6-fdholder-list.8
--- a/mdoc/man8/s6-fdholder-list.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-fdholder-list.8	2023-04-16 04:52:39.116496467 -0300
@@ -0,0 +1,62 @@
+.Dd September 29, 2021
+.Dt S6-FDHOLDER-LIST 8
+.Os
+.Sh NAME
+.Nm s6-fdholder-list
+.Nd list the descriptors currently held by
+.Xr s6-fdholderd 8
+.Sh SYNOPSIS
+.Nm
+.Op Fl t Ar timeout
+.Ar path
+.Sh DESCRIPTION
+.Nm
+connects to an
+.Xr s6-fdholderd 8
+server process listening on
+.Ar path .
+.Pp
+It gets the list of identifiers corresponding to the currently held
+file descriptors.
+It prints this list to stdout, one per line.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl t Ar timeout
+If the operation cannot be processed in
+.Ar timeout
+milliseconds, then fail with an error message.
+Communications with the server should be near-instant, so this option
+is only here to protect users against programming errors (connecting
+to the wrong socket, for instance).
+.El
+.Sh EXIT STATUS
+.Bl -tag -width x
+.It 0
+Success.
+.It 1
+The server denied the operation.
+The meanings of the error messages are explained in
+.Xr s6-fdholder-error-codes 7 .
+.It 100
+Wrong usage.
+.It 111
+System call failed - this includes attempting to connect to a
+nonexistent socket, or one where no
+.Xr s6-fdholderd 8
+daemon is listening.
+.El
+.Sh SEE ALSO
+.Xr s6-fdholder-daemon 8 ,
+.Xr s6-fdholder-delete 8 ,
+.Xr s6-fdholder-getdump 8 ,
+.Xr s6-fdholder-retrieve 8 ,
+.Xr s6-fdholder-setdump 8 ,
+.Xr s6-fdholder-store 8 ,
+.Xr s6-fdholder-transferdump 8 ,
+.Xr s6-fdholderd 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-fdholder-list.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-fdholder-retrieve.8 b/mdoc/man8/s6-fdholder-retrieve.8
--- a/mdoc/man8/s6-fdholder-retrieve.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-fdholder-retrieve.8	2023-04-16 04:52:39.116496467 -0300
@@ -0,0 +1,107 @@
+.Dd September 29, 2021
+.Dt S6-FDHOLDER-RETRIEVE 8
+.Os
+.Sh NAME
+.Nm s6-fdholder-retrieve
+.Nd connect to an
+.Xr s6-fdholderd 8
+daemon listening on a Unix domain socket, retrieve a file descriptor
+from this daemon, then execute a program with this file descriptor as
+the program's standard input
+.Sh SYNOPSIS
+.Nm
+.Op Fl D
+.Op Fl t Ar timeout
+.Ar path
+.Ar id
+.Ar prog...
+.Sh DESCRIPTION
+.Nm
+connects to an
+.Xr s6-fdholderd 8
+server process listening on
+.Ar path .
+.Pp
+It attempts to retrieve a copy of the file descriptor that has been
+stored into that daemon under identifier
+.Ar id .
+.Pp
+It then executes into
+.Ar prog... ,
+with the retrieved file descriptor as standard input.
+.Pp
+To execute
+.Ar prog
+with the newly retrieved file descriptor as number
+.Em n
+while preserving stdin, use the following construct:
+.Pp
+.Dl fdmove n 0 s6-fdholder-retrieve path id fdswap 0 n prog....
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl D
+Delete the file descriptor from the server's storage after
+retrieval.
+This option requires writing rights over the given identifier as well
+as reading rights: check the server's configuration.
+Refer to
+.Xr s6-fdholder 7
+for details.
+.It Fl t Ar timeout
+If the operation cannot be processed in
+.Ar timeout
+milliseconds, then fail with an error message.
+Communications with the server should be near-instant, so this option
+is only here to protect users against programming errors (connecting
+to the wrong socket, for instance).
+.El
+.Sh EXIT STATUS
+On success, the program doesn't exit; instead, it execs into
+.Ar prog... .
+.Bl -tag -width x
+.It 1
+The server denied the operation.
+The meanings of the error messages are explained in
+.Xr s6-fdholder-error-codes 7 .
+.It 100
+Wrong usage.
+.It 111
+System call failed - this includes attempting to connect to a
+nonexistent socket, or one where no
+.Xr s6-fdholderd 8
+daemon is listening.
+.El
+.Sh EXAMPLES
+.Dl s6-fdholder-retrieve /service/fdholderd/s MYSOCKET s6-ipcserverd cat
+.Pp
+will retrieve a file descriptor stored under the
+.Ql MYSOCKET
+identifier in the
+.Xr s6-fdholderd 8
+daemon listening on the
+.Pa /service/fdholderd/s
+socket, and execute into
+.Ql s6-ipcserverd cat
+with this file descriptor as stdin.
+In this case, if
+.Ql MYSOCKET
+referred to a Unix domain socket,
+.Xr s6-ipcserverd 8
+will then accept client connections on it and spawn a
+.Ql cat
+program for every connection.
+.Sh SEE ALSO
+.Xr s6-fdholder-daemon 8 ,
+.Xr s6-fdholder-delete 8 ,
+.Xr s6-fdholder-getdump 8 ,
+.Xr s6-fdholder-list 8 ,
+.Xr s6-fdholder-setdump 8 ,
+.Xr s6-fdholder-store 8 ,
+.Xr s6-fdholder-transferdump 8 ,
+.Xr s6-fdholderd 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-fdholder-retrieve.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-fdholder-setdump.8 b/mdoc/man8/s6-fdholder-setdump.8
--- a/mdoc/man8/s6-fdholder-setdump.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-fdholder-setdump.8	2023-04-16 04:52:39.116496467 -0300
@@ -0,0 +1,88 @@
+.Dd September 29, 2021
+.Dt S6-FDHOLDER-SETDUMP 8
+.Os
+.Sh NAME
+.Nm s6-fdholder-setdump
+.Nd connect to an
+.Xr s6-fdholderd 8
+daemon listening on a Unix domain socket, and dump a set of file
+descriptors into that daemon
+.Sh SYNOPSIS
+.Nm
+.Op Fl t Ar timeout
+.Ar path
+.Sh DESCRIPTION
+.Nm
+connects to an
+.Xr s6-fdholderd 8
+server process listening on
+.Ar path .
+.Pp
+It attempts to pass a complete state - i.e. a set of file descriptors
+with identifiers and expiration dates - to the server.
+.Pp
+The file descriptors to transmit to the server should of course be
+already open in the
+.Nm
+program; also,
+.Nm
+should have certain environment variables that describe that set of
+file descriptors.
+The format of the environment is the same as the one set by
+.Xr s6-fdholder-getdump 8 .
+.Pp
+Setting the whole state of an
+.Xr s6-fdholderd 8
+daemon requires specific privileges.
+Make sure you properly configure
+.Xr s6-fdholderd 8
+access rights so your client can perform that operation.
+.Pp
+Previously held fds will still be kept by the server (so,
+.Dq setting
+the state is more like
+.Dq adding to
+the state), unless there is an identifier collision, in which case the
+fd in the transmitted set takes precedence and the previously held fd
+is overwritten.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl t Ar timeout
+If the operation cannot be processed in
+.Ar timeout
+milliseconds, then fail with an error message.
+Communications with the server should be near-instant, so this option
+is only here to protect users against programming errors (connecting
+to the wrong socket, for instance).
+.El
+.Sh EXIT STATUS
+.Bl -tag -width x
+.It 0
+Success.
+.It 1
+The server denied the operation.
+The meanings of the error messages are explained in
+.Xr s6-fdholder-error-codes 7 .
+.It 100
+Wrong usage.
+.It 111
+System call failed - this includes attempting to connect to a
+nonexistent socket, or one where no
+.Xr s6-fdholderd 8
+daemon is listening.
+.El
+.Sh SEE ALSO
+.Xr s6-fdholder-daemon 8 ,
+.Xr s6-fdholder-delete 8 ,
+.Xr s6-fdholder-getdump 8 ,
+.Xr s6-fdholder-list 8 ,
+.Xr s6-fdholder-retrieve 8 ,
+.Xr s6-fdholder-store 8 ,
+.Xr s6-fdholder-transferdump 8 ,
+.Xr s6-fdholderd 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-fdholder-setdump.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-fdholder-store.8 b/mdoc/man8/s6-fdholder-store.8
--- a/mdoc/man8/s6-fdholder-store.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-fdholder-store.8	2023-04-16 04:52:39.116496467 -0300
@@ -0,0 +1,97 @@
+.Dd September 29, 2021
+.Dt S6-FDHOLDER-STORE 8
+.Os
+.Sh NAME
+.Nm s6-fdholder-store
+.Nd connect to an
+.Xr s6-fdholderd 8
+daemon listening on a Unix domain socket, and give it a copy of one of
+its open file descriptors for the daemon to hold
+.Sh SYNOPSIS
+.Nm
+.Op Fl d Ar fd
+.Op Fl T Ar fdtimeout
+.Op Fl t Ar timeout
+.Ar path
+.Ar id
+.Sh DESCRIPTION
+.Nm
+connects to an
+.Xr s6-fdholderd 8
+server process listening on
+.Ar path .
+.Pp
+It attempts to pass a copy of its standard input, or of its descriptor
+.Ar fd ,
+to the server, with identifier
+.Ar id .
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl d Ar fd
+Store descriptor number
+.Ar fd .
+By default,
+.Ar fd
+is 0 (i.e. the program's stdin will be stored).
+.It Fl T Ar fdtimeout
+The descriptor is stored with an expiration time of
+.Ar fdtimeout
+milliseconds, which means the
+.Xr s6-fdholderd 8
+daemon will close and get rid of the descriptor after this time.
+By default,
+.Ar fdtimeout
+is 0, which means infinite - no expiration time.
+.It Fl t Ar timeout
+If the operation cannot be processed in
+.Ar timeout
+milliseconds, then fail with an error message.
+Communications with the server should be near-instant, so this option
+is only here to protect users against programming errors (connecting
+to the wrong socket, for instance).
+.El
+.Sh EXIT STATUS
+.Bl -tag -width x
+.It 0
+Success.
+.It 1
+The server denied the operation.
+The meanings of the error messages are explained in
+.Xr s6-fdholder-error-codes 7 .
+.It 100
+Wrong usage.
+.It 111
+System call failed - this includes attempting to connect to a
+nonexistent socket, or one where no
+.Xr s6-fdholderd 8
+daemon is listening.
+.El
+.Sh EXAMPLES
+.Dl s6-ipcserver-socketbinder /tmp/mysocket s6-fdholder-store /service/fdholderd/s MYSOCKET
+.Pp
+will open a Unix domain socket, bind it to
+.Pa /tmp/mysocket
+and listen to incoming connections, then give it to an
+.Xr s6-fdholderd 8
+instance listening on
+.Pa /service/fdholderd/s ,
+with no expiration date, with the
+.Dq MYSOCKET
+identifier.
+Another program will be able to retrieve the socket later, using
+.Xr s6-fdholder-retrieve 8 .
+.Sh SEE ALSO
+.Xr s6-fdholder-daemon 8 ,
+.Xr s6-fdholder-delete 8 ,
+.Xr s6-fdholder-getdump 8 ,
+.Xr s6-fdholder-list 8 ,
+.Xr s6-fdholder-retrieve 8 ,
+.Xr s6-fdholder-setdump 8 ,
+.Xr s6-fdholder-transferdump 8 ,
+.Xr s6-fdholderd 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-fdholder-store.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-fdholder-transferdump.8 b/mdoc/man8/s6-fdholder-transferdump.8
--- a/mdoc/man8/s6-fdholder-transferdump.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-fdholder-transferdump.8	2023-04-16 04:52:39.117496466 -0300
@@ -0,0 +1,106 @@
+.Dd September 29, 2021
+.Dt S6-FDHOLDER-TRANSFERDUMP 8
+.Os
+.Sh NAME
+.Nm s6-fdholder-transferdump
+.Nd connect to two separate
+.Xr s6-fdholderd 8
+daemons and transfer the content of the first one to the second one
+.Sh SYNOPSIS
+.Nm
+.\" '-T lint' reports "WARNING: skipping no-space macro",
+.\" but the rendered output is correct.
+.Op Fl t Ar timeoutfrom : Ns Ar timeoutto
+.Ar pathfrom
+.Ar pathto
+.Sh DESCRIPTION
+.Nm
+connects to an
+.Xr s6-fdholderd 8
+server process listening on
+.Ar pathfrom
+and gets the whole set of file descriptors from this server, with
+their identifiers and (when relevant) expiration dates.
+.Pp
+It then connects to a different instance of
+.Xr s6-fdholderd 8 ,
+listening on
+.Ar pathto ,
+and stores the set of file descriptors in it.
+The set is added to the second server, which keeps the descriptors it
+was already holding.
+.Pp
+Dumping the entire state of
+.Xr s6-fdholderd 8
+requires special authorizations.
+Make sure the
+.Xr s6-fdholderd 8
+instances are configured to accept dump-getting and dump-setting
+requests from your client.
+Refer to
+.Xr s6-fdholderd 8
+for details.
+.Pp
+A typical use case of
+.Nm
+is when the main fd-holding daemon needs to upgrade, or restart for
+some reason.
+Transferring the file descriptors into another, temporary, fd-holding
+daemon instance allows it to restart without losing the descriptors.
+.Sh OPTIONS
+.Bl -tag -width x
+.\" '-T lint' reports "WARNING: skipping no-space macro",
+.\" but the rendered output is correct.
+.It Fl t Ar timeoutfrom : Ns Ar timeoutto
+If the operations cannot be processed in
+.Ar timeoutfrom
+.Po
+for the connection to
+.Ar pathfrom
+.Pc
+or
+.Ar timeoutto
+.Po
+for the connection to
+.Ar pathto
+.Pc
+milliseconds, then fail with an error message.
+Communications with the servers should be near-instant, so this option
+is only here to protect users against programming errors (connecting
+to the wrong socket, for instance).
+.El
+.Sh EXIT STATUS
+.Bl -tag -width x
+.It 0
+Success.
+.It 1
+The source server denied the operation.
+The meanings of the error messages are explained in
+.Xr s6-fdholder-error-codes 7 .
+.It 2
+The destination server denied the operation.
+The meanings of the error messages are explained in
+.Xr s6-fdholder-error-codes 7 .
+.It 100
+Wrong usage.
+.It 111
+System call failed - this includes attempting to connect to a
+nonexistent socket, or one where no
+.Xr s6-fdholderd 8
+daemon is listening.
+.El
+.Sh SEE ALSO
+.Xr s6-fdholder-daemon 8 ,
+.Xr s6-fdholder-delete 8 ,
+.Xr s6-fdholder-getdump 8 ,
+.Xr s6-fdholder-list 8 ,
+.Xr s6-fdholder-retrieve 8 ,
+.Xr s6-fdholder-setdump 8 ,
+.Xr s6-fdholder-store 8 ,
+.Xr s6-fdholderd 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-fdholder-transferdump.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-fdholderd.8 b/mdoc/man8/s6-fdholderd.8
--- a/mdoc/man8/s6-fdholderd.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-fdholderd.8	2023-04-16 04:52:39.117496466 -0300
@@ -0,0 +1,480 @@
+.Dd January 15, 2023
+.Dt S6-FDHOLDERD 8
+.Os
+.Sh NAME
+.Nm s6-fdholderd
+.Nd serving part of the
+.Xr s6-fdholder-daemon 8
+fd-holding server
+.Sh SYNOPSIS
+.Nm
+.Op Fl 1
+.Op Fl v Ar verbosity
+.Op Fl c Ar maxconn
+.Op Fl n Ar maxfds
+.Op Fl t Ar clienttimeout
+.Op Fl T Ar lameducktimeout
+.Op Fl i Ar rulesdir | Fl x Ar rulesfile
+.Sh DESCRIPTION
+.Nm
+assumes that its stdin is a bound and listening Unix domain socket; it
+accepts connections from clients connecting to that socket, and stores
+and retrieves file descriptors on their behalf.
+.Pp
+.Nm
+accepts connections from clients to an already bound and listening
+.Dv SOCK_STREAM
+Unix domain socket which is its standard input.
+.Pp
+Depending on the verbosity level, it logs what it does to stderr.
+.Pp
+It runs until killed by a signal (normally SIGTERM). When
+.Nm
+is killed, all the fds it is currently holding are lost; if they need
+to be preserved, the admin should make sure to transfer them
+beforehand with
+.Xr s6-fdholder-transferdump 8 .
+.Pp
+Client connections are short-lived.
+Clients generally perform one operation, then disconnect.
+.Pp
+Possible operations include:
+.Bl -bullet -width x
+.It
+Storing a file descriptor:
+.Xr s6-fdholder-store 8 .
+.It
+Retrieving a file descriptor:
+.Xr s6-fdholder-retrieve 8 .
+.It
+Deleting a file descriptor:
+.Xr s6-fdholder-delete 8 .
+.It
+Listing stored file descriptor identifiers:
+.Xr s6-fdholder-list 8 .
+.It
+Getting the whole server state:
+.Xr s6-fdholder-getdump 8 .
+.It
+Setting the whole server state, or more accurately adding a set of
+file descriptors to the already existing state:
+.Xr s6-fdholder-setdump 8 .
+.El
+.Pp
+.Nm
+is meant to be execve'd into by a program that gets the listening
+socket.
+That program is normally
+.Xr s6-ipcserver-socketbinder 8 ,
+which creates the socket itself; but it can be a different one if the
+socket is to be obtained by another means, for instance if it has been
+retrieved from another fd-holding daemon.
+.Pp
+.Nm
+will store any open file descriptor, without discriminating on its
+type.
+However, it makes more sense to store certain file descriptor types
+than others: for instance, Unix domain or INET domain sockets, or
+named pipes, are good candidates for fd-holding.
+On the other hand, it makes little sense to fd-hold regular files, and
+if done anyway, the results can be surprising, because the read/write
+file offset is stored with the descriptor, and no automatic rewind is
+performed by the daemon.
+.Pp
+Despite there being access control for listing, the security of the
+system should not depend on a client not knowing what identifier a
+certain descriptor is stored under.
+If you need to hold descriptors that only a few programs are supposed
+to access, you can always run a separate
+.Nm
+instance in a private directory with a configuration tailored to your
+needs - and you can even make the name of the listening socket
+private.
+.Nm
+is lightweight; you can start as many instances as you need, and you
+can run them as long as you need, then kill them with SIGTERM.
+.Pp
+.Nm
+pre-allocates its storage at start, in the stack.
+It uses a small amount of heap memory for communication with a client,
+but frees it as soon as the client disconnects.
+It should never run out of memory in normal usage, even if used
+intensively.
+.Ss Signals
+.Bl -tag -width x
+.It SIGTERM
+Enter lameduck mode, then exit when no more operation is pending.
+.It SIGHUP
+Reopen
+.Ar rulesfile ,
+if
+.Nm
+has been run with the
+.Fl x
+option.
+It is not necessary to send
+.Nm
+a SIGHUP when the
+.Fl i
+option is used instead: configuration changes in the filesystem are
+automatically picked up.
+.El
+.Ss Identifiers
+Every file descriptor is stored in the
+.Nm
+daemon via the
+.Xr s6-fdholder-store 8
+program, with an identifier.
+That identifier is a zero-terminated character string, containing 1 to
+255 characters.
+.Pp
+Any non-null character can be used in an identifier.
+Non-printable or special characters will be quoted when printed by
+.Xr s6-fdholder-list 8 .
+However, it is recommended to only use reasonable characters in
+identifiers: clients should be able to know at a glance what file
+descriptor is represented by an identifier.
+Identifiers have no special meaning to the server.
+.Pp
+A good convention is to use
+.\" '-T lint' reports "WARNING: skipping no-space macro",
+.\" but the rendered output is correct.
+.Ql unix: Ns Em path Ns / Ns Em to Ns / Ns Em socket
+for Unix domain sockets and
+.Ql Em protocol : Ns Em ip : Ns Em port
+for INET domain sockets.
+.Pp
+An identifier is chosen by the storing client, within the limits of
+what the server authorizes it to use.
+.Pp
+The retrieving client must know the exact identifier corresponding to
+a descriptor to be able to retrieve that descriptor.
+It must also be authorized by the server.
+.Pp
+When an identifier is in use, it cannot be used again to store another
+descriptor.
+However, once the descriptor has been deleted or has expired, it is
+possible to reuse the same identifier.
+.Ss Configuration
+Before running
+.Nm
+.Po
+or its wrapper
+.Xr s6-fdholder-daemon 8
+.Pc ,
+it is necessary to configure it.
+This is done by a series of rules, or
+.Em ruleset ,
+stored in either a
+.Em rulesfile
+in the CDB[1] format, or in a
+.Em rulesdir ,
+i.e. a directory in the filesystem following a certain format.
+.Nm
+will refuse to run if neither the
+.Fl i
+nor the
+.Fl x
+option has been provided.
+.Pp
+Rulesets can be converted between the
+.Em rulesdir
+and
+.Em rulesfile
+formats with the
+.Xr s6-accessrules-cdb-from-fs 8
+and
+.Xr s6-accessrules-fs-from-cdb 8
+conversion tools.
+.Ss Rules format
+The rules file, or rules directory, follows the
+.Xr s6-accessrules 7
+format for uid and gid checking.
+For every connecting client,
+.Nm s6-fdholderd
+matches the uid and gid of the client against the provided ruleset,
+and determines what the client is authorized to do.
+.Pp
+By default, no client is allowed to do anything - not even connect to
+the server.
+Even
+.Ql root ,
+the super-user, will be denied access.
+That is why it is essential to create a sensible ruleset prior to
+running the server in order to do anything useful.
+.Pp
+The various rights that a client can have are the following (using a
+rulesdir as an example, but a rulesfile works the same way):
+.Bl -bullet -width x
+.It
+Connect to the server.
+This is a prerequisite for doing anything.
+It will allow a client to perform
+.Dq public
+operations, ones that do not require specific access rights other than
+connecting.
+(There are no such operations for now, but it could change in the
+future; for now, when you allow a client to connect to the server,
+make sure to give him other rights too.)
+This right is given if an
+.Pa allow
+file is found in one of the subdirectories checked by
+.Fn s6_accessrules_keycheck_uidgid .
+For instance, to allow everyone to connect, touch
+.Pa rulesdir/uid/default/allow .
+.El
+.Pp
+The other rights are defined in the
+.Dq environment
+part of the ruleset:
+.Bl -bullet -width x
+.It
+File descriptor storage rights.
+This will be checked for storage and deletion of individual file
+descriptors.
+This right is given if a non-empty file named
+.Pa S6_FDHOLDER_STORE_REGEX
+is found in the
+.Pa env/
+subdirectory of one of the subdirectories checked by
+.Fn s6_accessrules_keycheck_uidgid .
+This file should contain a single line, which will be interpreted as
+an Extended Regular Expression[2] by
+.Nm ;
+the regular expression describes the set of identifiers that the
+client is allowed to use to store file descriptors.
+For instance,
+.Ql ^unix:/tmp/
+indicates that a client that matches this rule will be allowed to
+store or delete file descriptors using any identifier starting with
+.Ql unix:/tmp/ .
+.It
+File descriptor retrieval rights.
+This will be checked for retrieval of individual file
+descriptors.
+This right is given if a non-empty file named
+.Pa S6_FDHOLDER_RETRIEVE_REGEX
+is found in the
+.Pa env/
+subdirectory of one of the subdirectories checked by
+.Fn s6_accessrules_keycheck_uidgid .
+This file should contain a single line, which will be interpreted as
+an Extended Regular Expression[2] by
+.Nm ;
+the regular expression describes the set of identifiers that the
+client is allowed to use to retrieve file descriptors.
+For instance,
+.Ql ^unix:/tmp/
+indicates that a client that matches this rule will be allowed to
+retrieve file descriptors that are identified by strings starting with
+.Ql unix:/tmp/ .
+.It
+Listing rights.
+This will be checked for clients wanting to list the identifiers of
+the descriptors currently stored in the server.
+This right is given if a non-empty file named
+.Pa S6_FDHOLDER_LIST
+is found in the
+.Pa env/
+subdirectory of one of the subdirectories checked by
+.Fn s6_accessrules_keycheck_uidgid .
+.It
+Dump reading rights.
+This will be checked for clients wanting to copy the whole state of
+the server.
+This right is given if a non-empty file named
+.Pa S6_FDHOLDER_GETDUMP
+is found is the
+.Pa env/
+subdirectory of one of the subdirectories checked by
+.Fn s6_accessrules_keycheck_uidgid .
+This is very powerful: you should only give this right to
+.Ql root ,
+or to a dedicated uid that is only used to perform dump transfers.
+.It
+Dump writing rights.
+This will be checked for clients wanting to copy an entire set of file
+descriptors into the server.
+This right is given if a non-empty file named
+.Pa S6_FDHOLDER_SETDUMP
+is found is the
+.Pa env/
+subdirectory of one of the subdirectories checked by
+.Fn s6_accessrules_keycheck_uidgid .
+This is very powerful: you should only give this right to
+.Ql root ,
+or to a dedicated uid that is only used to perform dump transfers.
+.El
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl 1
+Write a newline to stdout, and close stdout, right before entering the
+client-accepting loop.
+If stdout is suitably redirected, this can be used by monitoring
+programs to check when the server is accepting connections.
+See
+.Xr s6-notifywhenup 7
+for more information on readiness notification.
+.It Fl v Ar verbosity
+Be more or less verbose.
+.Ar verbosity
+can be 0 (quiet), 1 (normal), or 2 or more (verbose).
+.It Fl c Ar maxconn
+Accept at most
+.Ar maxconn
+concurrent connections.
+Default is 16.
+It is impossible to set it higher than the value of the
+.Dv S6_FDHOLDER_MAX
+macro, i.e. 256.
+Client connections to this server are short-lived, so this number
+needs not be too high.
+Every client connection eats up one available file descriptor, so it
+is best for
+.Ar maxconn
+to be as small as possible.
+.It Fl n Ar maxfds
+Store at most
+.Ar maxfds
+file descriptors.
+Default is 1000.
+It is impossible to set it higher than the number of files that can be
+opened by the
+.Nm
+process, minus a few descriptors needed for correct operation.
+Before running
+.Nm ,
+make sure to use
+.Xr s6-softlimit 8
+to properly adjust the number of openable files[3] of the current
+process.
+.It Fl t Ar clienttimeout
+Disconnect a client if it's in the middle of an operation and it has
+not written or read any data in
+.Ar clienttimeout
+milliseconds.
+By default,
+.Ar clienttimeout
+is 0, which means infinite.
+.It Fl t Ar lameducktimeout
+Give clients
+.Ar lameducktimeout
+milliseconds to finish their current operation before exiting after
+receiving a SIGTERM.
+By default,
+.Ar lameducktimeout
+is 0, which means infinite.
+.It Fl x Ar rulesfile
+Read access rights configuration from CDB[1] file
+.Ar rulesfile .
+.It Fl i Ar rulesdir
+Read access rights configuration from the filesystem in directory
+.Ar rulesdir .
+.El
+.Sh EXAMPLES
+Assuming you want to run an
+.Nm
+daemon in the
+.Pa /service/fdholder
+directory with the
+.Fl i Ar rules
+option, you should:
+.Bl -bullet -width x
+.It
+Prepare the rules directory:
+.Bd -literal -offset indent
+mkdir /service/fdholder/rules
+cd /service/fdholder/rules
+mkdir uid gid
+.Ed
+.It
+Allow a few users, or everyone, to connect.
+To allow root to connect:
+.Bd -literal -offset indent
+mkdir uid/0
+touch uid/0/allow
+.Ed
+.Pp
+To allow everyone to connect:
+.Bd -literal -offset indent
+mkdir uid/default
+touch uid/default/allow
+.Ed
+.El
+.Pp
+Depending on your policy, you should now give certain rights to
+certain users or groups.
+For instance:
+.Bl -bullet -width x
+.It
+To allow user number 50 to perform dump transfers from and to this
+server:
+.Bd -literal -offset indent
+mkdir -p uid/50/env
+touch uid/50/allow
+echo > uid/50/env/S6_FDHOLDER_GETDUMP
+echo > uid/50/env/S6_FDHOLDER_SETDUMP
+.Ed
+.It
+To allow user number 72 to store a descriptor under the name
+.Ql foobar
+and
+.Em only
+this name:
+.Bd -literal -offset indent
+mkdir -p uid/72/env
+touch uid/72/allow
+echo '^foobar$' > uid/72/env/S6_FDHOLDER_STORE_REGEX
+.Ed
+.It
+To allow users having 23 as their primary group number to retrieve
+file descriptors with an identifier containing
+.Ql foo ,
+then one character, then
+.Ql bar :
+.Bd -literal -offset indent
+mkdir -p gid/23/env
+touch gid/23/allow
+echo foo.bar > gid/23/env/S6_FDHOLDER_RETRIEVE_REGEX
+.Ed
+.It
+To allow the same users to list all identifiers:
+.Bd -literal -offset indent
+echo > gid/23/env/S6_FDHOLDER_LIST
+.Ed
+.It
+To allow everyone to dump entire states into the server
+.Po
+.Sy never do this !
+it's only an example
+.Pc :
+.Bd -literal -offset indent
+mkdir -p uid/default/env
+touch uid/default/allow
+echo > uid/default/env/S6_FDHOLDER_SETDUMP
+.Ed
+.El
+.Sh SEE ALSO
+.Xr s6-fdholder-daemon 8 ,
+.Xr s6-fdholder-delete 8 ,
+.Xr s6-fdholder-getdump 8 ,
+.Xr s6-fdholder-list 8 ,
+.Xr s6-fdholder-retrieve 8 ,
+.Xr s6-fdholder-setdump 8 ,
+.Xr s6-fdholder-store 8 ,
+.Xr s6-fdholder-transferdump 8
+.Pp
+[1]
+.Lk https://en.wikipedia.org/wiki/Cdb_%28software%29
+.Pp
+[2]
+.Lk https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04
+.Pp
+[3]
+.Lk https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_resource.h.html
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-fdholderd.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-fghack.8 b/mdoc/man8/s6-fghack.8
--- a/mdoc/man8/s6-fghack.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-fghack.8	2023-04-16 04:52:39.117496466 -0300
@@ -0,0 +1,55 @@
+.Dd September 29, 2021
+.Dt S6-FGHACK 8
+.Os
+.Sh NAME
+.Nm s6-fghack
+.Nd an anti-backgrounding tool
+.Sh SYNOPSIS
+.Nm
+.Ar prog...
+.Sh DESCRIPTION
+.Nm
+opens a lot of file descriptors (all writing to a single pipe).
+.Pp
+Then it forks and executes
+.Ar prog... .
+.Pp
+If something gets written on one of those descriptors, it's a bug in
+.Ar prog .
+.Nm
+then complains and exits 102.
+.Pp
+Unless
+.Ar prog...
+goes out of its way to close descriptors it does not know about,
+.Nm
+is able to detect when
+.Ar prog...
+exits.
+It exits with the same exit code (or 111 if
+.Ar prog...
+has crashed).
+.Pp
+.Nm
+is what it says: a hack.
+Ideally, you should never have to use it.
+It is only useful when you want to supervise a daemon that does not
+provide a
+.Dq stay in the foreground
+option; and even then, the right thing is to report this as a bug to
+the daemon author and have it fixed.
+.Sh SEE ALSO
+.Xr s6-applyuidgid 8 ,
+.Xr s6-envdir 8 ,
+.Xr s6-envuidgid 8 ,
+.Xr s6-setsid 8 ,
+.Xr s6-setuidgid 8 ,
+.Xr s6-softlimit 8 ,
+.Xr s6-tai64n 8 ,
+.Xr s6-tai64nlocal 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-fghack.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-ftrig-listen.8 b/mdoc/man8/s6-ftrig-listen.8
--- a/mdoc/man8/s6-ftrig-listen.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-ftrig-listen.8	2023-04-16 04:52:39.118496466 -0300
@@ -0,0 +1,99 @@
+.Dd September 29, 2021
+.Dt S6-FTRIG-LISTEN 8
+.Os
+.Sh NAME
+.Nm s6-ftrig-listen
+.Nd subscribe to several
+.Xr s6-fifodir 7 Ns s ,
+spawn a program, then wait for pattern of events to occur on the
+fifodirs
+.Sh SYNOPSIS
+In an
+.Xr execlineb 1
+script:
+.Pp
+.Nm
+.Op Fl a | o
+.Op Fl t Ar timeout
+.Bro
+.Ar fifodir-1
+.Ar regexp-1
+.Ar fifodir-2
+.Ar regexp-2
+.Brc
+.Ar prog...
+.Sh DESCRIPTION
+.Nm
+subscribes to
+.Ar fifodir1
+with the regexp
+.Ar regexp1 ,
+to
+.Ar fifodir2
+with the regexp
+.Ar regexp2 ,
+and so on.
+.Pp
+It then forks and execs
+.Ar prog...
+with all its arguments.
+.Pp
+It waits for the series of events received on
+.Ar fifodir Ns - Ns Em i
+to match
+.Ar regexp Ns - Ns Em i .
+.Ar regexp Ns - Ns Em i
+must be Extended Regular Expressions[1].
+.Pp
+When the series of read events matches the regexps,
+.Nm
+exits 0.
+.Nm
+can be used outside of an execlineb script by using the internal argv
+syntax, but this syntax is an implementation detail and is not
+documented as stable.
+In a shell script, use
+.Ql execlineb -Pc 's6-ftrig-listen ...'
+to get the benefits of the execlineb brace syntax.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl t Ar timeout
+If the events on the fifodirs have not matched the regexps after
+.Ar timeout
+milliseconds, print an error message on stderr and exit 1.
+By default,
+.Nm
+waits indefinitely for a matching series of events.
+.It Fl a
+And (conjunction).
+.Nm
+will only exit when all the
+.Ar fifodir Ns - Ns Em i
+have been notified with events matching the corresponding
+.Ar regexp Ns - Ns Em i .
+This is the default.
+.It Fl o
+Or (disjunction).
+.Nm
+will exit as soon as one of the
+.Ar fifodir Ns - Ns Em i
+has been notified with events matching its
+.Ar regexp Ns - Ns Em i .
+.El
+.Sh SEE ALSO
+.Xr execlineb 1 ,
+.Xr s6-cleanfifodir 8 ,
+.Xr s6-ftrig-listen1 8 ,
+.Xr s6-ftrig-notify 8 ,
+.Xr s6-ftrig-wait 8 ,
+.Xr s6-ftrigrd 8 ,
+.Xr s6-mkfifodir 8
+.Pp
+[1]
+.Lk https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-ftrig-listen.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-ftrig-listen1.8 b/mdoc/man8/s6-ftrig-listen1.8
--- a/mdoc/man8/s6-ftrig-listen1.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-ftrig-listen1.8	2023-04-16 04:52:39.118496466 -0300
@@ -0,0 +1,103 @@
+.Dd September 29, 2021
+.Dt S6-FTRIG-LISTEN1 8
+.Os
+.Sh NAME
+.Nm s6-ftrig-listen1
+.Nd subscribe to an
+.Xr s6-fifodir 7 ,
+then spawn a program, waiting for a pattern of events to occur on the
+fifodir
+.Sh SYNOPSIS
+.Nm
+.Op Fl t Ar timeout
+.Ar fifodir
+.Ar regexp
+.Ar prog...
+.Sh DESCRIPTION
+.Nm
+acts just as
+.Xr s6-ftrig-wait 8 ,
+except it can make sure that the process sending the notifications is
+actually started after there is a listener for those events.
+.Pp
+.Nm
+subscribes to
+.Ar fifodir .
+.Pp
+It then forks and execs
+.Ar prog...
+with all its arguments.
+.Pp
+It waits for the series of events received on
+.Ar fifodir
+to match
+.Ar regexp .
+.Ar regexp
+must be an Extended Regular Expression[1].
+.Pp
+When the series of read events matches
+.Ar regexp ,
+.Nm
+prints the last event it received to stdout (one byte followed by a newline),
+then exits 0.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl t Ar timeout
+If the events on
+.Ar fifodir
+have not matched
+.Ar regexp
+after
+.Ar timeout
+milliseconds, print an error message on stderr and exit 1.
+By default,
+.Nm
+waits indefinitely for a matching series of events.
+.El
+.Sh EXAMPLES
+The following sequence of shell commands has a race condition.
+.Pp
+In terminal 1:
+.Bd -literal -offset indent
+s6-mkfifodir /tmp/toto
+s6-ftrig-wait /tmp/toto "message"
+.Ed
+.Pp
+Then in terminal 2:
+.Bd -literal -offset indent
+s6-ftrig-notify /tmp/toto message
+.Ed
+.Pp
+Depending on the operating system's scheduler, there is the
+possibility that the
+.Xr s6-ftrig-notify 8
+process starts sending
+.Dq message
+.Em before
+the
+.Xr s6-ftrig-wait 8
+process has actually subscribed to
+.Pa /tmp/toto ,
+in which case the notification will be missed.
+The following sequence of shell commands accomplishes the same goal in
+a reliable way, without the race condition:
+.Bd -literal -offset indent
+s6-mkfifodir /tmp/toto
+s6-ftrig-listen1 /tmp/toto "message" s6-ftrig-notify /tmp/toto message
+.Ed
+.Sh SEE ALSO
+.Xr s6-cleanfifodir 8 ,
+.Xr s6-ftrig-listen 8 ,
+.Xr s6-ftrig-notify 8 ,
+.Xr s6-ftrig-wait 8 ,
+.Xr s6-ftrigrd 8 ,
+.Xr s6-mkfifodir 8
+.Pp
+[1]
+.Lk https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-ftrig-listen1.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-ftrig-notify.8 b/mdoc/man8/s6-ftrig-notify.8
--- a/mdoc/man8/s6-ftrig-notify.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-ftrig-notify.8	2023-04-16 04:52:39.118496466 -0300
@@ -0,0 +1,37 @@
+.Dd September 29, 2021
+.Dt S6-FTRIG-NOTIFY 8
+.Os
+.Sh NAME
+.Nm s6-ftrig-notify
+.Nd send a series of events to an
+.Xr s6-fifodir 7
+.Sh SYNOPSIS
+.Nm
+.Ar fifodir
+.Ar message
+.Sh DESCRIPTION
+.Nm
+notifies all the current listeners in
+.Ar fifodir
+with all the characters in
+.Ar message .
+.Pp
+.Nm
+cannot be used to send the null character (event 0x00).
+If you need to send the null character, use the C API:
+.Fn ftrigw_notify . Refer to
+.Xr s6-ftrigw 7
+for details.
+.Sh SEE ALSO
+.Xr s6-cleanfifodir 8 ,
+.Xr s6-ftrig-listen 8 ,
+.Xr s6-ftrig-listen1 8 ,
+.Xr s6-ftrig-wait 8 ,
+.Xr s6-ftrigrd 8 ,
+.Xr s6-mkfifodir 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-ftrig-notify.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-ftrig-wait.8 b/mdoc/man8/s6-ftrig-wait.8
--- a/mdoc/man8/s6-ftrig-wait.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-ftrig-wait.8	2023-04-16 04:52:39.118496466 -0300
@@ -0,0 +1,60 @@
+.Dd September 29, 2021
+.Dt S6-FTRIG-WAIT 8
+.Os
+.Sh NAME
+.Nm s6-ftrig-wait
+.Nd subscribe to an
+.Xr s6-fifodir 7
+and wait for a pattern of events to occur on this fifodir
+.Sh SYNOPSIS
+.Nm
+.Op Fl t Ar timeout
+.Ar fifodir
+.Ar regexp
+.Sh DESCRIPTION
+.Nm
+subscribes to
+.Ar fifodir .
+.Pp
+It waits for the series of events received on
+.Ar fifodir
+to match
+.Ar regexp .
+.Ar regexp
+must be an Extended Regular Expression[1].
+.Pp
+When the series of read events matches
+.Ar regexp ,
+.Nm
+prints the last event it received to stdout (one byte followed by a newline),
+then exits 0.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl t Ar timeout
+If the events on
+.Ar fifodir
+have not matched
+.Ar regexp
+after
+.Ar timeout
+milliseconds, print an error message on stderr and exit 1.
+By default,
+.Nm
+waits indefinitely for a matching series of events.
+.El
+.Sh SEE ALSO
+.Xr s6-cleanfifodir 8 ,
+.Xr s6-ftrig-listen 8 ,
+.Xr s6-ftrig-listen1 8 ,
+.Xr s6-ftrig-notify 8 ,
+.Xr s6-ftrigrd 8 ,
+.Xr s6-mkfifodir 8
+.Pp
+[1]
+.Lk https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-ftrig-wait.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-ftrigrd.8 b/mdoc/man8/s6-ftrigrd.8
--- a/mdoc/man8/s6-ftrigrd.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-ftrigrd.8	2023-04-16 04:52:39.118496466 -0300
@@ -0,0 +1,102 @@
+.Dd September 29, 2021
+.Dt S6-FTRIGRD 8
+.Os
+.Sh NAME
+.Nm s6-ftrigrd
+.Nd helper program that manages a set of subscriptions to
+.Xr s6-fifodir 7 Ns s
+as well as regular expressions on events
+.Sh SYNOPSIS
+.Nm
+.Sh DESCRIPTION
+.Nm
+takes orders from its client program that controls it via
+.Xr s6-ftrigr 7 ,
+and notifies it when desired events happen.
+.Nm
+is not meant to be called directly.
+.Bl -bullet -width x
+.It
+If the client program uses
+.Fn ftrigr_startf ,
+it spawns an instance of
+.Nm
+as a child.
+.Nm s6-ftrigrd Ap
+s stdin is a pipe reading from the client; its stdout is a pipe
+writing to the client; its stderr is the same as the client's; and
+there's an additional pipe from
+.Nm
+to the client, used for asynchronous notifications.
+.It
+If the client program uses
+.Fn ftrigr_start ,
+then it tries to connect to a Unix domain socket.
+An
+.Nm
+local service should be listening to that socket, i.e. a Unix domain
+super-server such as
+.Xr s6-ipcserver 8
+spawning an
+.Nm
+program on every connection.
+Then an
+.Nm
+instance is created for the client.
+.It
+When the client uses
+.Fn ftrigr_end , or closes
+.Nm s6-ftrigrd Ap
+s stdin in any way,
+.Nm
+exits 0.
+.El
+.Pp
+.Nm
+handles the grunt work of creating fifos in a fifodir for a
+subscriber.
+It also wakes up on every event, and compares the chain of events it
+received on a given fifodir with the client-provided regexp.
+If the chain of events matches the regexp, it notifies the client.
+.Pp
+The connection management between the client and
+.Nm
+is entirely done by the textclient library from skalibs[1].
+.Pp
+.Nm
+is entirely asynchronous.
+It stores unread notifications into heap memory; it can grow in size
+if there are a lot of events and the client fails to read them.
+To avoid uncontrolled growth, make sure your client calls
+.Fn ftrigr_update
+as soon as
+.Fn ftrigr_fd
+becomes readable.
+.Pp
+An
+.Nm
+instance can only handle up to
+.Dv FTRIGRD_MAX
+.Po
+defined in
+.Pa s6/ftrigr.h
+.Pc
+subscriptions at once.
+By default, this number is 1000, which is more than enough for any
+reasonable system.
+.Sh SEE ALSO
+.Xr s6-cleanfifodir 8 ,
+.Xr s6-ftrig-listen 8 ,
+.Xr s6-ftrig-listen1 8 ,
+.Xr s6-ftrig-notify 8 ,
+.Xr s6-ftrig-wait 8 ,
+.Xr s6-mkfifodir 8
+.Pp
+[1]
+.Lk https://skarnet.org/software/skalibs/
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/libs6/s6-ftrigrd.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-instance-control.8 b/mdoc/man8/s6-instance-control.8
--- a/mdoc/man8/s6-instance-control.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-instance-control.8	2023-04-16 04:52:39.118496466 -0300
@@ -0,0 +1,67 @@
+.Dd January 11, 2023
+.Dt S6-INSTANCE-CONTROL 8
+.Os
+.Sh NAME
+.Nm s6-instance-control
+.Nd send commands to a running instance of an
+.Xr s6-instanced-service 7
+.Sh SYNOPSIS
+.Nm
+.Op Fl wu | Fl wU | Fl wd | Fl wD | Fl wr | Fl wR ]
+.Op Fl T Ar timeout
+.Op Fl abqhkti12pcyroduDUxO
+.Ar servicedir
+.Ar name
+</pre>
+.Sh DESCRIPTION
+.Nm
+expects a running, supervised
+.Xr s6-instanced-service 7
+in
+.Ar servicedir ,
+as well as an existing instance of this service named
+.Ar name .
+.Pp
+It sends the given series of commands to the supervisor monitoring the
+.Ar name
+instance.
+.Pp
+It exits 0.
+.Sh OPTIONS
+The options, and the commands they represent, are exactly the same as
+the ones understood by
+.Xr s6-svc 8 .
+.Pp
+In fact,
+.Nm
+is nothing more than a call to
+.Xr s6-svc 8
+on the service directory representing the
+.Ar name
+instance.
+It is syntactic sugar so the user does not have to depend on the
+internal representation of instances and the location of instances'
+service directories.
+.Sh EXIT STATUS
+.Bl -tag -width x
+.It 0
+Success.
+.It 99
+With one of the
+.Fl w
+options, timed out while waiting for the command to complete.
+.It 100
+Wrong usage.
+.It 111
+System call failed.
+.El
+.Sh SEE ALSO
+.Xr s6-instanced-service 7 ,
+.Xr s6-instance-create 8 ,
+.Xr s6-instance-delete 8 ,
+.Xr s6-instance-list 8 ,
+.Xr s6-instance-maker 8 ,
+.Xr s6-instance-status 8
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-instance-create.8 b/mdoc/man8/s6-instance-create.8
--- a/mdoc/man8/s6-instance-create.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-instance-create.8	2023-04-16 04:52:39.119496466 -0300
@@ -0,0 +1,137 @@
+.Dd January 11, 2023
+.Dt S6-INSTANCE-CREATE 8
+.Os
+.Sh NAME
+.Nm s6-instance-create
+.Nd create a new instance of a currently supervised
+.Xr s6-instanced-service 7
+.Sh SYNOPSIS
+.Nm
+.Op Fl d | Fl D
+.Op Fl P
+.Op Fl f
+.Op Fl t Ar timeout
+.Ar servicedir
+.Ar name
+.Sh DESCRIPTION
+.Nm
+expects a running, supervised
+.Xr s6-instanced-service 7
+in
+.Ar servicedir .
+This service typically has been created by linking the result of an
+.Xr s6-instance-maker 8
+invocation into an existing
+.Xr s6-scan-directory 7 .
+.Pp
+.Nm
+creates a new instance of that service, named
+.Ar name .
+Depending on the given options, it may start it immediately, or keep
+it down until a later
+.Xr s6-instance-control 8
+invocation.
+.Pp
+It waits for the new instance to be ready to take commands from
+.Xr s6-instance-control 8
+.Pp
+It exits 0.
+.Pp
+.Nm
+is similar to
+.Xr s6-svlink 8 ,
+because it uses the same underlying library functions.
+Under the hood, an instance is a regular service running on a
+supervision tree that is specific to the instanced service, and
+.Nm
+adds a service directory to that tree and ensures it gets
+supervised.
+.Pp
+If the template for the service is logged, then
+.Nm
+will wait until supervisors have been spawned for both the instance
+and its logger.
+.Pp
+.Nm
+and
+.Xr s6-instance-delete 8
+are relatively expensive operations, because they have to recursively
+copy or delete directories and use the
+.Xr s6-ftrigr 7
+synchronization mechanism with the instance supervisor, compared to
+.Xr s6-instance-control 8
+which only has to send commands to already existing supervisors.
+If you are going to turn instances on and off on a regular basis, it
+is more efficient to keep the instance existing and control it with
+.Xr s6-instance-control 8
+than it is to repeatedly create and delete it.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl d
+Down.
+The instance supervisor will be started, but the instance
+itself will remain down.
+Any
+.Pa down
+file for the instance will be deleted.
+By default, if neither the
+.Fl d
+nor
+.Fl D
+options have been given, the supervisor auto-starts the instance as
+soon as it runs.
+.It Fl D
+Down, and stay down.
+The instance supervisor will be started, but the instance itself will
+remain down.
+A
+.Pa down
+file will be created for the instance.
+By default, if neither the
+.Fl d
+nor
+.Fl D
+options have been given, the supervisor auto-starts the instance as
+soon as it runs.
+.It Fl P
+Public.
+Everyone will be able to subscribe to the instance supervisor's
+notification.
+By default, only processes running with the same gid as the instanced
+service can subscribe to it.
+.It Fl f
+Force permissions.
+You should never need to use this option, it is only there for testing
+purposes.
+.It Fl t Ar timeout
+If the
+instance supervisor has not started after
+.Ar timeout
+milliseconds,
+.Nm
+will print a message to stderr and exit 99.
+By default,
+.Ar timeout
+is 0, which means no time limit.
+.El
+.Sh EXIT STATUS
+.Bl -tag -width -x
+.It 0
+Success.
+.It 99
+Timeout while waiting for the instance supervisor to start.
+.It 100
+Wrong usage.
+.It 111
+System call failed.
+.El
+.Sh SEE ALSO
+.Xr s6-instanced-service 7 ,
+.Xr s6-instance-control 8 ,
+.Xr s6-instance-delete 8 ,
+.Xr s6-instance-list 8 ,
+.Xr s6-instance-maker 8 ,
+.Xr s6-instance-status 8
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-instance-delete.8 b/mdoc/man8/s6-instance-delete.8
--- a/mdoc/man8/s6-instance-delete.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-instance-delete.8	2023-04-16 04:52:39.119496466 -0300
@@ -0,0 +1,91 @@
+.Dd January 11, 2023
+.Dt S6-INSTANCE-DELETE 8
+.Os
+.Sh NAME
+.Nm s6-instance-delete
+.Nd delete an existing instance of a currently supervised
+.Xr s6-instanced-service 7
+.Sh SYNOPSIS
+.Nm
+.Op Fl X
+.Op Fl t Ar timeout
+.Ar servicedir
+.Ar name
+.Sh DESCRIPTION
+.Nm
+expects a running, supervised
+.Xr s6-instanced-service 7
+in
+.Ar servicedir ,
+as well as an existing instance of this service named
+.Ar name
+(it doesn't matter if the instance is up or down).
+.Pp
+It deletes the
+.Ar name
+instance.
+.Pp
+It exits 0.
+.Pp
+.Nm
+is similar to
+.Xr s6-svunlink 8 ,
+because it uses the same underlying library functions.
+Under the hood, an instance is a regular service running on a
+supervision tree that is specific to the instanced service, and
+.Nm
+removes a service directory from that tree.
+.Pp
+If the template for the service is logged, then
+.Nm
+will delete both the instance and its logger.
+.Pp
+.Nm
+and
+.Xr s6-instance-create 8
+are relatively expensive operations, because they have to recursively
+copy or delete directories and use the
+.Xr s6-ftrigr 7
+synchronization mechanism with the instance supervisor, compared to
+.Xr s6-instance-control 8
+which only has to send commands to already existing supervisors.
+If you are going to turn instances on and off on a regular basis, it
+is more efficient to keep the instance existing and control it with
+.Xr s6-instance-control 8
+than it is to repeatedly create and delete it.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl X
+Don't wait.
+.Nm
+will exit right away, without waiting for the instance (and its
+supervisor) to properly disappear.
+.It Fl t Ar timeout
+If the instance supervisor has not exited after
+.Ar timeout
+milliseconds,
+.Nm
+will still exit.
+By default,
+.Ar timeout
+is 0, which means no time limit.
+.El
+.Sh EXIT STATUS
+.Bl -tag -width x
+.It 0
+Success.
+.It 100
+Wrong usage.
+.It 111
+System call failed.
+.El
+.Sh SEE ALSO
+.Xr s6-instanced-service 7 ,
+.Xr s6-instance-control 8 ,
+.Xr s6-instance-create 8 ,
+.Xr s6-instance-list 8 ,
+.Xr s6-instance-maker 8 ,
+.Xr s6-instance-status 8
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-instance-list.8 b/mdoc/man8/s6-instance-list.8
--- a/mdoc/man8/s6-instance-list.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-instance-list.8	2023-04-16 04:52:39.119496466 -0300
@@ -0,0 +1,54 @@
+.Dd January 15, 2023
+.Dt S6-INSTANCE-LIST 8
+.Os
+.Sh NAME
+.Nm s6-instance-list
+.Nd give a list of all currently created instances of an
+.Xr s6-instanced-service 7
+.Sh SYNOPSIS
+.Nm
+.Ar servicedir
+.Sh DESCRIPTION
+.Nm
+expects a running, supervised
+.Xr s6-instanced-service 7
+in
+.Ar servicedir ,
+as well as an existing instance of this service named
+.Ar name .
+.Pp
+It prints to stdout, one per line, the names of all existing instances of
+.Ar servicedir ,
+i.e. the ones that have been created and not deleted.
+It does not matter if the instances are up or down; if they've been
+created and not deleted, they're printed.
+.Pp
+It exits 0.
+.Pp
+The list is unsorted, the instance names are printed in an unspecified order.
+.Pp
+You can use
+.Nm
+to script commands that handle sets of instances.
+For example, to get the status of all the instances of a given
+service, you could write:
+.Ql for i in `s6-instance-list Ar service Ns ` ; do printf "%s: " $i ; s6-instance-status Ar service $i ; done
+.Sh EXIT STATUS
+.Bl -tag -width x
+.It 0
+Success.
+.It 100
+Wrong usage.
+.It 111
+System call failed.
+.El
+.Sh SEE ALSO
+.Xr s6-instanced-service 7 ,
+.Xr s6-instance-control 8 ,
+.Xr s6-instance-create 8 ,
+.Xr s6-instance-delete 8 ,
+.Xr s6-instance-maker 8 ,
+.Xr s6-instance-status 8
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-instance-maker.8 b/mdoc/man8/s6-instance-maker.8
--- a/mdoc/man8/s6-instance-maker.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-instance-maker.8	2023-04-16 04:52:39.119496466 -0300
@@ -0,0 +1,300 @@
+.Dd January 15, 2023
+.Dt S6-INSTANCE-MAKER 8
+.Os
+.Sh NAME
+.Nm s6-instance-maker
+.Nd create an
+.Xr s6-service-directory 7
+implementing an
+.Xr s6-instanced-service 7
+.Sh SYNOPSIS
+.Nm
+.Op Fl c Ar maxinstances
+.Op Fl r Ar service Ns Op / Ns Ar logger Ns Op / Ns Ar pipeline
+.Op Fl u Ar user
+.Op Fl l Ar loguser
+.Op Fl L Ar logdir
+.Op Fl t Ar stamptype
+.Op Fl n Ar nfiles
+.Op Fl s Ar filesize
+.Op Fl S Ar maxsize
+.Op Fl P Ar prefix
+.Ar template
+.Ar dir
+.Sh DESCRIPTION
+Give
+.Nm
+a templated service directory describing how to run an instance of a
+service, and it will create a different service directory that can
+launch and manage several instances; each of these instances will be
+running a copy of the service directory you gave.
+.Pp
+Alternatively,
+.Nm
+can create source definition directories for the s6-rc service manager[1].
+.Pp
+.Nm
+creates a service directory in
+.Ar dir
+(which must not already exist).
+The created service will be a supervisor for a set of instances \(em
+initially empty \(em each running a copy of the service directory
+given in
+.Ar template .
+.Pp
+.Nm
+is an
+.Em offline
+tool: it is run before you need instances.
+Once the created service directory is live, i.e. there is a supervisor
+running on it, then you can create and delete individual instances via
+the
+.Xr s6-instance-create 8
+and
+.Xr s6-instance-delete 8
+.Em online
+tools, that work with active services.
+.Pp
+.Nm
+makes use of the fact that execline[2] scripts are much easier to
+generate programmatically and to harden than shell scripts, so it is
+only built if s6 is built with execline support - i.e. the
+.Ql --disable-execline
+switch has
+.Em not
+been given to configure.
+.Pp
+If
+.Nm
+encounters failure (and exits 111), it does not clean up the
+directories it created.
+Make sure to always test
+.Nm Ap
+s return code and clean up after it if needed.
+.Ss The templated service directory
+.Ar template
+should be a directory that looks exactly like a service directory.
+It will not be live, i.e. at no point will
+.Ar template
+itself be supervised; instead, a copy of it is stored under
+.Ar dir
+.Po
+and a copy of that copy will be used for every instance of the
+service
+.Pc .
+You can safely move or delete
+.Ar template
+after running
+.Nm .
+.Pp
+To differentiate between instances, the
+.Pa run
+and
+.Pa finish
+script in
+.Ar template
+should take one additional argument
+.Po
+the first argument for
+.Pa run
+and the third argument for
+.Pa finish
+.Pc .
+This argument will be the name of the instance, as provided by the
+.Xr s6-instance-create 8
+invocation.
+.Ss Logging
+The service is logged: its stderr and stdout are piped to an
+.Xr s6-log 8
+process running as
+.Ar loguser
+and writing to the
+.Ar logdir
+directory.
+This logger is the catch-all logger for all the instances and the
+supervision tree hosting them.
+If
+.Ar user
+and
+.Ar loguser
+are provided, it is recommended to make them distinct from each other.
+.Pp
+Additionally, if
+.Ar template
+has a
+.Ar log
+subdirectory, then each instance will have its own dedicated logger.
+The
+.Pa run
+and
+.Pa finish
+scripts for the logger of an instance named
+.Ar name
+will be called with an additional argument of
+.Ar name Ns /log .
+They should make use of this, to ensure loggers are properly
+differentiated between instances: for instance, it is not possible to
+run several
+.Xr s6-log 8
+processes on the same log directory, so an instance logger script
+containing an invocation of
+.Xr s6-log 8
+on a fixed logdir will fail as soon as there are 2 instances.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl c Ar max
+Plan for a maximum of
+.Ar max
+instances.
+Default is
+.Em 500 .
+You can't set it lower than 2 or higher than 90000.
+If your template service directory is logged, it's unadvisable to set
+this above the default.
+.It Fl r Ar service Ns Op / Ns Ar logger Ns Op / Ns Ar pipeline
+Create s6-rc[1] source definition directories.
+When this option is given,
+.Ar dir
+is not created as a service directory, but as a directory containing
+at least one service:
+.Pa "" Ns Ar dir Ns / Ns Ar service .
+.Ar dir
+is suitable as a source argument to s6-rc-compile[3].
+If a
+.Ar logger
+part is given, then a second service,
+.Pa "" Ns Ar dir Ns /logger ,
+is also created, as a consumer for
+.Pa "" Ns Ar dir Ns / Ns Ar service ,
+and the
+.Fl L
+option must also be used, to provide a directory to store the logs into.
+If the
+.Pa "" Ns / Ns Ar pipeline
+part is also given,
+.Ar pipeline
+is used as a name for a bundle containing both
+.Ar service
+and
+.Pa logger .
+When the
+.Fl r
+option is not given at all,
+.Pa "" Ns Ar dir
+is a regular service directory for direct inclusion (or linking) in a host
+.Xr s6-scan-directory 7 ,
+and if the
+.Fl L
+option is given then the logger for the instance supervisor and all
+its instances is declared in
+.Pa "" Ns Ar dir Ns /log .
+.It Fl u Ar user
+Run the instance supervisor, and all of the instances, as user
+.Ar user .
+This option should only be used when the supervision tree that will
+host the instanced service is run as root.
+The default is that the service runs as the same user as the host
+supervision tree.
+.It Fl l Ar loguser
+Run the logger of the instance supervisor, if any
+.Po
+see
+.Fl L
+below
+.Pc
+as user
+.Ar loguser .
+This option should only be used when the supervision tree that will
+host the instanced service is run as root.
+The default is that the logger runs as the same user as the host
+supervision tree.
+.It Fl L Ar logdir
+Make the service logged via
+.Xr s6-log 8 ,
+and ensure its log messages go into
+.Ar logdir .
+Error messages from the instance supervisor as well as from every
+instance will be logged to
+.Ar logdir .
+If this option is not given, these error messages will fall through to
+the host supervision tree's catch-all logger, if any, or standard
+error otherwise.
+The options listed below are only used to configured the logger and
+are meaningless if
+.Fl L
+is not given.
+.It Fl t Ar stamptype
+How logs are timestamped in
+.Ar logdir .
+0 means no timestamp, 1 means external TAI64N format[4], 2 means ISO
+8601 format[5], and 3 means both.
+Default is
+.Em 1 .
+.It Fl n Ar nfiles
+Maximum number of archive files in
+.Ar logdir .
+Default is
+.Em 10 .
+.It Fl s Ar filesize
+Maximum size of the
+.Pa current
+file
+.Po
+and archive files
+.Pc
+in
+.Ar logdir .
+Default is
+.Em 1000000 .
+.It Fl S Ar maxsize
+Maximum total size of the archives in
+.Ar logdir .
+Default is
+.Em 0 ,
+meaning no limits apart from those enforced by the
+.Fl n
+and
+.Fl s
+options.
+.It Fl P Ar prefix
+when logging to
+.Ar logdir ,
+prefix logged lines with the
+.Ar prefix
+string.
+Default is no prefix.
+.El
+.Sh EXIT STATUS
+.Bl -tag -width x
+.It 0
+Success.
+.It 100
+Wrong usage.
+.It 111
+System call failed.
+.El
+.Sh SEE ALSO
+.Xr s6-instanced-service 7 ,
+.Xr s6-instance-control 8 ,
+.Xr s6-instance-create 8 ,
+.Xr s6-instance-delete 8 ,
+.Xr s6-instance-list 8 ,
+.Xr s6-instance-status 8
+.Pp
+[1]
+.Lk https://skarnet.org/software/s6-rc/
+.Pp
+[2]
+.Lk https://skarnet.org/software/execline/
+.Pp
+[3]
+.Lk https://skarnet.org/software/s6-rc/s6-rc-compile.html
+.Pp
+[4]
+.Lk https://cr.yp.to/libtai/tai64.html
+.Pp
+[5]
+.Lk https://www.iso.org/iso/home/standards/iso8601.htm
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-instance-status.8 b/mdoc/man8/s6-instance-status.8
--- a/mdoc/man8/s6-instance-status.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-instance-status.8	2023-04-16 04:52:39.119496466 -0300
@@ -0,0 +1,60 @@
+.Dd January 11, 2023
+.Dt S6-INSTANCE-STATUS 8
+.Os
+.Sh NAME
+.Nm s6-instance-status
+.Nd give the status of a running instance of an
+.Xr s6-instanced-service 7 ,
+as a short human-readable summary or programmatically parsable output
+.Sh SYNOPSIS
+.Nm
+.Op Fl uwNrpest | Fl o No up,wantedup,normallyup,ready,paused,pid,exitcode,signal,signum,updownsince,readysince,updownfor,readyfor
+.Op Fl n
+.Ar servicedir
+.Ar name
+.Sh DESCRIPTION
+.Nm
+expects a running, supervised
+.Xr s6-instanced-service 7
+in
+.Ar servicedir ,
+as well as an existing instance of this service named
+.Ar name .
+.Pp
+It prints information to stdout about the monitored instance of
+.Ar servicedir
+named
+.Ar name .
+.Pp
+It exits 0.
+.Sh OPTIONS
+The options are exactly the same as the ones understood by
+.Xr s6-svstat 8 .
+.Pp
+In fact, s6-instance-status is nothing more than a call to
+.Xr s6-svstat 8
+on the service directory representing the
+.Ar name
+instance.
+It is syntactic sugar so the user does not have to depend on the
+internal representation of instances and the location of instances'
+service directories.
+.Sh EXIT STATUS
+.Bl -tag -width x
+.It 0
+Success.
+.It 100
+Wrong usage.
+.It 111
+System call failed.
+.El
+.Sh SEE ALSO
+.Xr s6-instanced-service 7 ,
+.Xr s6-instance-control 8 ,
+.Xr s6-instance-create 8 ,
+.Xr s6-instance-delete 8 ,
+.Xr s6-instance-list 8 ,
+.Xr s6-instance-maker 8
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-ioconnect.8 b/mdoc/man8/s6-ioconnect.8
--- a/mdoc/man8/s6-ioconnect.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-ioconnect.8	2023-04-16 04:52:39.119496466 -0300
@@ -0,0 +1,118 @@
+.Dd February 19, 2023
+.Dt S6-IOCONNECT 8
+.Os
+.Sh NAME
+.Nm s6-ioconnect
+.Nd perform full-duplex data transmission between two sets of open file descriptors
+.Sh SYNOPSIS
+.Nm
+.Op Fl t Ar millisecs
+.Op Fl r Ar fdr
+.Op Fl w Ar fdw
+.Sh DESCRIPTION
+.Nm
+reads data from its stdin and writes it as-is to file descriptor 7,
+which is assumed to be open.
+.Pp
+It also reads data from its file descriptor 6, which is assumed to be
+open, and writes it as-is to its stdout.
+.Pp
+When both sides have transmitted EOF and
+.Nm
+has flushed its buffers, it exits 0.
+.Pp
+The point of
+.Nm
+is to be used together with
+s6-tcpclient
+or
+.Xr s6-ipcclient 8
+to establish a full-duplex connection between the client and the
+server, for instance for testing purposes.
+.Nm
+is to
+s6-tcpclient
+as
+.Xr cat 1
+is to
+s6-tcpserver:
+a program that will just echo what it gets.
+.Pp
+The
+.Nm
+utility was once part of the s6-networking suite, which is why the
+examples here involve TCP.
+Nevertheless, it can be used with connections across Unix domain
+sockets as well, and has its place in the s6 package.
+.Pp
+If one of the endpoints is a socket,
+.Nm
+will call
+.Xr shutdown 2
+on it (for reading or writing, depending on the endpoint) when it
+needs to transmit EOF.
+This is a necessary workaround to a misdesign[1] of the socket API,
+but it could have unintended consequences when the socket is shared
+among several processes that expect a persistent connection.
+Most of the time, however, it is a mistake to share a data socket
+between processes, so
+.Nm Ap s
+behaviour is suited to an overwhelming majority of cases, and the
+exceptions are specialized enough that they won't need to use
+.Nm .
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl t Ar millisecs
+If no activity on either side happens for
+.Ar millisecs
+milliseconds,
+.Nm
+closes the connection on both ends and exits 1.
+By default,
+.Ar millisecs
+is 0, which means no such timeout.
+.It Fl r Ar fdr
+Use fd
+.Ar fdr
+for
+.Dq remote
+reading instead of fd 6.
+.It Fl w Ar fdw
+Use fd
+.Ar fdw
+for
+.Dq remote
+writing instead of fd 7.
+.El
+.Pp
+The
+.Fl 0 ,
+.Fl 1 ,
+.Fl 6
+and
+.Fl 7
+options are still recognized for compatibility, but do nothing; they
+are deprecated.
+They were previously used to tell
+.Nm
+that the local reading, local writing, remote reading and remote
+writing endpoints, respectively, were sockets \(em but this is now
+autodetected.
+.Sh SEE ALSO
+.Xr s6-accessrules-cdb-from-fs 8 ,
+.Xr s6-accessrules-fs-from-cdb 8 ,
+.Xr s6-connlimit 8 ,
+.Xr s6-ipcclient 8 ,
+.Xr s6-ipcserver 8 ,
+.Xr s6-ipcserver-access 8 ,
+.Xr s6-ipcserver-socketbinder 8 ,
+.Xr s6-ipcserverd 8
+.Pp
+[1]
+.Lk https://cr.yp.to/tcpip/twofd.html
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-ioconnect.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-ipcclient.8 b/mdoc/man8/s6-ipcclient.8
--- a/mdoc/man8/s6-ipcclient.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-ipcclient.8	2023-04-16 04:52:39.120496466 -0300
@@ -0,0 +1,79 @@
+.Dd September 29, 2021
+.Dt S6-IPCCLIENT 8
+.Os
+.Sh NAME
+.Nm s6-ipcclient
+.Nd UCSPI client tool[1] for Unix domain sockets: connect to a socket, then execute into a program
+.Sh SYNOPSIS
+.Nm
+.Op Fl q | Q | v
+.Op Fl p Ar localpath
+.Op Fl l Ar localname
+.Ar path
+.Ar prog...
+.Sh DESCRIPTION
+.Nm
+connects to a Unix domain socket on
+.Ar path .
+.Pp
+It executes into
+.Ar prog...
+with descriptor 6 reading from the socket and descriptor 7 writing to
+it.
+.Pp
+.Nm
+is mostly used to connect a client to an
+.Xr s6-local-service 7
+without having to implement networking in the client.
+For instance, the
+.Xr s6-sudo 8
+program does this.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl q
+Be quiet.
+.It Fl Q
+Be normally verbose.
+This is the default.
+.It Fl v
+Be verbose.
+.It Fl p Ar localpath
+Bind the local socket to
+.Ar localpath
+before connecting to
+.Ar path .
+.It Fl l Ar localname
+Use
+.Ar localname
+as the value of the
+.Ev IPCLOCALPATH
+environment variable.
+.El
+.Sh ENVIRONMENT
+.Ar prog...
+is run with the following variables set:
+.Bl -tag -width x
+.It PROTO
+Always set to IPC.
+.It IPCLOCALPATH
+Set to the path associated with the local socket, if any.
+Be aware that it may contain arbitrary characters.
+.El
+.Sh SEE ALSO
+.Xr s6-accessrules-cdb-from-fs 8 ,
+.Xr s6-accessrules-fs-from-cdb 8 ,
+.Xr s6-connlimit 8 ,
+.Xr s6-ioconnect 8 ,
+.Xr s6-ipcserver 8 ,
+.Xr s6-ipcserver-access 8 ,
+.Xr s6-ipcserver-socketbinder 8 ,
+.Xr s6-ipcserverd 8
+.Pp
+[1]
+.Lk https://cr.yp.to/proto/ucspi.txt
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-ipcclient.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-ipcserver-access.8 b/mdoc/man8/s6-ipcserver-access.8
--- a/mdoc/man8/s6-ipcserver-access.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-ipcserver-access.8	2023-04-16 04:52:39.120496466 -0300
@@ -0,0 +1,249 @@
+.Dd September 29, 2021
+.Dt S6-IPCSERVER-ACCESS 8
+.Os
+.Sh NAME
+.Nm s6-ipcserver-access
+.Nd control tool for Unix domain sockets on systems where the
+.Fn getpeereid
+system call can be implemented
+.Sh SYNOPSIS
+.Nm
+.Op Fl v Ar verbosity
+.Op Fl E | e
+.Op Fl l Ar localname
+.Op Fl i Ar rulesdir | Fl x Ar rulesfile
+.Ar prog...
+.Sh DESCRIPTION
+.Nm
+is meant to be run after
+.Xr s6-ipcserverd 8
+and before the application program on the
+.Xr s6-ipcserver 8
+command line.
+.Pp
+.Nm
+checks it is run under a UCSPI server tool such as
+.Xr s6-ipcserver 8 .
+.Pp
+It checks that the remote end of the connection fits the accepted
+criteria defined by the database contained in
+.Ar rulesdir
+or
+.Ar rulesfile .
+If the database tells it to reject the connection, the program exits
+1.
+.Pp
+It sets up a few additional environment variables.
+.Pp
+It executes into
+.Ar prog... ,
+unless the first matching rule in the rule database includes
+instructions to override
+.Ar prog... .
+.Ss Access rule checking
+.Nm
+checks its client connection against a ruleset.
+This ruleset can be implemented:
+.Bl -bullet -width x
+.It
+either in the filesystem as an arborescence of directories and files,
+if the
+.Fl i
+option has been given.
+This option is the most flexible one: the directory format is simple
+enough for scripts to understand and modify it, and the ruleset can be
+changed dynamically.
+This is practical, for instance, for roaming users.
+.It
+or in a CDB[1] file, if the
+.Fl x
+option has been given.
+This option is the most efficient one if the ruleset is static enough:
+a lot less system calls are needed to perform searches in a CDB than
+in the filesystem.
+.El
+.Pp
+The exact format of the ruleset is described in the
+.Xr s6-accessrules-cdb-from-fs 8
+page.
+.Pp
+.Nm
+first reads the client UID
+.Em uid
+and GID
+.Em gid
+from the
+.Ev ${PROTO}REMOTEEUID
+and
+.Ev ${PROTO}REMOTEEGID
+environment variables, and checks them with the
+.Fn s6_accessrules_keycheck_uidgid
+function - refer to
+.Xr s6-accessrules 7 .
+In other words, it tries to match:
+.Bl -bullet -width x
+.It
+(if the client's effective uid is the same as
+.Sm off
+.Nm Ap
+.Sm on
+effective uid)
+.Pa uid/self
+.It
+.Sm off
+.Pa uid/
+.Em uid
+.Sm on
+.It
+(if the client's effective gid is the same as
+.Sm off
+.Nm Ap
+.Sm on
+effective gid)
+.Pa gid/self
+.It
+.Sm off
+.Pa gid/
+.Em gid
+.Sm on
+.It
+.Pa uid/default
+.El
+.Pp
+in that order.
+If no
+.Dv S6_ACCESSRULES_ALLOW
+result can be obtained, the connection is denied.
+.Ss Environment and executable modifications
+.Nm
+interprets non-empty
+.Pa env
+subdirectories and
+.Pa exec
+files it finds in the first matching rule of the ruleset, as explained
+in the
+.Xr s6-accessrules-cdb-from-fs 8
+page.
+.Bl -bullet -width x
+.It
+An
+.Pa env
+subdirectory is interpreted as if the
+.Xr s6-envdir 8
+command had been called before executing
+.Ar prog :
+the environment is modified according to the contents of
+.Pa env .
+.It
+An
+.Pa exec
+file containing
+.Em newprog
+completely bypasses the rest of
+.Sm off
+.Nm Ap
+.Sm on
+command line.
+After environment modifications, if any,
+.Nm
+execs into
+.Ql execlineb -c newprog .
+Please be aware that the
+.Pa exec
+file functionality is only supported when s6 has been built with
+execline support.
+Otherwise, a warning message is printed and executable diversion is
+not performed.
+.El
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl v Ar verbosity
+Be more or less verbose, i.e. print more or less information to stderr:
+.Bl -tag -width x
+.It 0
+Only log error messages.
+.It 1
+Only log error and warning messages, and accepted connections.
+This is the default.
+.It 2
+Also log rejected connections and more warning messages.
+.El
+.It Fl E
+No environment.
+All environment variables potentially set by
+.Nm ,
+as well as those set by
+.Xr s6-ipcserver 8 ,
+will be unset instead.
+.It Fl e
+Set up environment variables normally.
+This is the default.
+.It Fl l Ar localname
+Use
+.Ar localname
+as the value for the
+.Ev ${PROTO}LOCALPATH
+environment variable, instead of looking it up via
+.Xr getsockname 2 .
+.It Fl i Ar rulesdir
+Check client credentials against a filesystem-based database in the
+.Ar rulesdir
+directory.
+.It Fl x Ar rulesfile
+Check client credentials against a CDB[1] database in the
+.Ar rulesfile
+file.
+.Fl i
+and
+.Fl x
+are mutually exclusive.
+If none of those options is given, no credential checking will be
+performed, and a warning will be emitted on every connection if
+.Ar verbosity
+is 2 or more.
+.El
+.Sh ENVIRONMENT
+.Nm
+expects to inherit some environment variables from its parent:
+.Bl -tag -width x
+.It PROTO
+Normally IPC, but could be anything else, like UNIX.
+.It ${PROTO}REMOTEEUID
+The effective UID of the client program connecting to the socket.
+.It ${PROTO}REMOTEEGID
+The effective GID of the client program connecting to the socket.
+.El
+.Pp
+Additionally, it exports the following variable before executing into
+.Ar prog... :
+.Bl -tag -width x
+.It ${PROTO}LOCALPATH
+Set to the local
+.Dq address
+of the socket, as reported by the
+.Xr getsockname 2
+system call, truncated to 99 characters max.
+.El
+.Pp
+Also, the access rules database can instruct
+.Nm
+to set up, or unset, more environment variables, depending on the
+client address.
+.Sh SEE ALSO
+.Xr s6-accessrules-cdb-from-fs 8 ,
+.Xr s6-accessrules-fs-from-cdb 8 ,
+.Xr s6-connlimit 8 ,
+.Xr s6-ioconnect 8 ,
+.Xr s6-ipcclient 8 ,
+.Xr s6-ipcserver 8 ,
+.Xr s6-ipcserver-socketbinder 8 ,
+.Xr s6-ipcserverd 8
+.Pp
+[1]
+.Lk https://en.wikipedia.org/wiki/Cdb_(software)
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-ipcserver-access.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-ipcserver-socketbinder.8 b/mdoc/man8/s6-ipcserver-socketbinder.8
--- a/mdoc/man8/s6-ipcserver-socketbinder.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-ipcserver-socketbinder.8	2023-04-16 04:52:39.120496466 -0300
@@ -0,0 +1,117 @@
+.Dd September 29, 2021
+.Dt S6-IPCSERVER-SOCKETBINDER 8
+.Os
+.Sh NAME
+.Nm s6-ipcserver-socketbinder
+.Nd bind a Unix domain socket, then execute a program
+.Sh SYNOPSIS
+.Nm
+.Op Fl d | D
+.Op Fl b Ar backlog
+.Op Fl M | m
+.Op Fl a Ar perms
+.Op Fl B
+.Ar path
+.Ar prog...
+.Sh DESCRIPTION
+.Nm
+creates a Unix domain socket and binds it to
+.Ar path .
+It prepares the socket to accept connections by calling
+.Xr listen 2 .
+.Pp
+It then execs into
+.Ar prog...
+with the open socket as its standard input.
+.Pp
+The socket is provided
+.Sy non-blocking by default .
+.Pp
+.Nm
+is part of a set of basic blocks used to build a flexible Unix
+super-server.
+It normally should be given a command line crafted to make it execute
+into
+.Xr s6-ipcserverd 8
+to accept connections from clients, or into a program such as
+.Xr s6-applyuidgid 8
+to drop privileges before doing so.
+.Pp
+The
+.Xr s6-ipcserver 8
+program does exactly this.
+It implements a full Unix super-server by building a command line
+starting with
+.Nm
+and ending with
+.Xr s6-ipcserverd 8
+followed by the application program, and executing into it.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl d
+Allow instant rebinding to the same path even if it has been used not
+long ago - this is the
+.Dv SO_REUSEADDR
+flag to
+.Xr setsockopt 2
+and is generally used with server programs.
+This is the default.
+Note that
+.Ar path
+will be deleted if it already exists at program start time.
+.It Fl D
+Disallow instant rebinding to the same path.
+.It Fl b Ar backlog
+Set a maximum of
+.Ar backlog
+backlog connections on the socket - extra connection attempts will
+rejected by the kernel.
+The default is
+.Dv SOMAXCONN ,
+i.e. the maximum number allowed by the system.
+If backlog is 0, then the socket will be created, but it
+.Sy will not be listening .
+.It Fl M
+The type of the socket will be
+.Dv SOCK_STREAM .
+This is the default.
+.It Fl m
+The type of the socket will be
+.Dv SOCK_DGRAM .
+Note that by default
+.Dv SOCK_DGRAM
+sockets are not connection-mode, and
+.Xr listen 2
+will fail - so you should always give the
+.Fl b0
+option to
+.Nm
+along with
+.Fl m .
+.It Fl a Ar perms
+Create the socket with permissions
+.Ar perms ,
+which is an octal number from 0000 to 0777.
+Default is 0777, meaning everyone can connect to it.
+0700 means only processes having the same uid as the
+.Nm
+process can connect to it.
+.It Fl B
+The socket will be blocking.
+The default is nonblocking.
+.El
+.Sh SEE ALSO
+.Xr s6-accessrules-cdb-from-fs 8 ,
+.Xr s6-accessrules-fs-from-cdb 8 ,
+.Xr s6-connlimit 8 ,
+.Xr s6-ioconnect 8 ,
+.Xr s6-ipcclient 8 ,
+.Xr s6-ipcserver 8 ,
+.Xr s6-ipcserver-access 8 ,
+.Xr s6-ipcserverd 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-ipcserver-socketbinder.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-ipcserver.8 b/mdoc/man8/s6-ipcserver.8
--- a/mdoc/man8/s6-ipcserver.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-ipcserver.8	2023-04-16 04:52:39.120496466 -0300
@@ -0,0 +1,225 @@
+.Dd September 29, 2021
+.Dt S6-IPCSERVER 8
+.Os
+.Sh NAME
+.Nm s6-ipcserver
+.Nd UCSPI server tool[1] for Unix domain sockets, i.e. a super-server: accept connections from clients, and fork a program to handle each connection
+.Sh SYNOPSIS
+.Nm
+.Op Fl 1
+.Op Fl q | Q | v
+.Op Fl d | D
+.Op Fl P | p
+.Op Fl a Ar perms
+.Op Fl c Ar maxconn
+.Op Fl C Ar localmaxconn
+.Op Fl b Ar backlog
+.Op Fl G Ar gidlist
+.Op Fl g Ar gid
+.Op Fl u Ar uid
+.Op Fl U
+.Ar path
+.Ar prog...
+.Sh DESCRIPTION
+.Nm
+binds a Unix domain socket to
+.Ar path .
+.Pp
+It can drop its root privileges.
+.Pp
+It closes its stdin and stdout.
+.Pp
+For every client connection to this socket, it forks.
+The child sets some environment variables, then executes
+.Ar prog...
+with stdin reading from the socket and stdout writing to it.
+.Pp
+Depending on the verbosity level, it logs what it does to stderr.
+.Pp
+It runs until killed by a signal.
+Depending on the received signal, it may kill its children before
+exiting.
+.Pp
+.Nm
+actually doesn't do any of this itself.
+It is a wrapper, rewriting the command line and executing into a chain
+of programs that perform those duties.
+.Pp
+Previous versions of
+.Nm
+were monolithic: it did the work of
+.Xr s6-ipcserver-socketbinder 8 ,
+.Xr s6-applyuidgid 8
+and
+.Xr s6-ipcserverd 8
+itself.
+The functionality has now been split into several different programs
+because some service startup schemes require the daemon to get its
+socket from an external program instead of creating and binding it
+itself.
+The most obvious application of this is upgrading a long-lived
+process without losing existing connections.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl 1
+Write a newline to stdout, before closing it, right after binding and
+listening to the Unix socket.
+If stdout is suitably redirected, this can be used by monitoring
+programs to check when the server is ready to accept connections.
+.It Fl q
+Be quiet.
+.It Fl Q
+Be normally verbose.
+This is the default.
+.It Fl v
+Be verbose.
+.It Fl d
+Allow instant rebinding to the same path even if it has been used not
+long ago - this is the
+.Dv SO_REUSEADDR
+flag to
+.Xr setsockopt 2
+and is generally used with server programs.
+This is the default.
+Note that
+.Ar path
+will be deleted if it already exists at program start time.
+.It Fl D
+Disallow instant rebinding to the same path.
+.It Fl P
+Disable client credentials lookups.
+The
+.Ev IPCREMOTEEUID
+and
+.Ev IPCREMOTEEGID
+environment variables will be unset in every instance of
+.Ar prog... .
+This is the portable option, because not every system supports
+credential lookup across Unix domain sockets; but it is not as secure.
+.It Fl p
+Enable client credentials lookups.
+This is the default; it works at least on Linux, Solaris, and *BSD
+systems.
+On systems that do not support it, every connection attempt will fail
+with a warning message.
+.It Fl c Ar maxconn
+Accept at most
+.Ar maxconn
+concurrent connections.
+Default is 40.
+It is impossible to set it higher than 1000.
+.It Fl C Ar localmaxconn
+Accept at most
+.Ar localmaxconn
+connections from the same user ID.
+Default is 40.
+It is impossible to set it higher than
+.Ar maxconn .
+.It Fl b Ar backlog
+Set a maximum of
+.Ar backlog
+backlog connections on the socket.
+Extra connection attempts will rejected by the kernel.
+.It Fl a Ar perms
+Create the socket with permissions
+.Ar perms ,
+which is an octal number from 0000 to 0777.
+Default is 0777, meaning everyone can connect to it.
+0700 means only processes having the same uid as the
+.Nm
+process can connect to it.
+.It Fl G Ar gidlist
+Change
+.Nm Ap
+s supplementary group list to
+.Ar gidlist
+after binding the socket.
+This is only valid when run as root.
+.Ar gidlist
+must be a comma-separated list of numerical group IDs.
+.It Fl g Ar gid
+Change
+.Nm Ap
+s groupid to
+.Ar gid
+after binding the socket.
+This is only valid when run as root.
+.It Fl u Ar uid
+Change
+.Nm Ap
+s userid to
+.Ar uid
+after binding the socket.
+This is only valid when run as root.
+.It Fl U
+Change
+.Nm Ap
+s user id, group id and supplementary group list according to the
+values of the
+.Ev UID ,
+.Ev GID
+and
+.Ev GIDLIST
+environment variables after binding the socket.
+This is only valid when run as root.
+This can be used with the
+.Xr s6-envuidgid 8
+program to easily script a service that binds to a privileged socket
+then drops its privileges to those of a named non-root account.
+.El
+.Sh IMPLEMENTATION NOTES
+.Nm
+parses the options and arguments it is given, and builds a new command
+line with them.
+It then executes into that new command line.
+.Pp
+The first program
+.Nm s6-ipcserver
+executes into is
+.Xr s6-ipcserver-socketbinder 8 .
+It will create and bind a Unix domain socket to
+.Ar path ,
+then execute into the rest of the command line.
+.Pp
+If a privilege-dropping operation has been requested, the program that
+.Xr s6-ipcserver-socketbinder 8
+executes into is
+.Xr s6-applyuidgid 8 .
+It will drop the root privileges, then execute into the rest of the
+command line.
+.Pp
+The next program in the chain is
+.Xr s6-ipcserverd 8 .
+It is executed into by
+.Xr s6-applyuidgid 8 ,
+or directly by
+.Xr s6-ipcserver-socketbinder 8
+if no privilege-dropping operation has been requested.
+.Xr s6-ipcserverd 8
+is the long-lived process, the
+.Dq daemon
+itself, accepting connections from clients.
+.Pp
+For every client,
+.Xr s6-ipcserverd 8
+will spawn an instance of
+.Ar prog... ,
+the remainder of the command line.
+.Sh SEE ALSO
+.Xr s6-accessrules-cdb-from-fs 8 ,
+.Xr s6-accessrules-fs-from-cdb 8 ,
+.Xr s6-connlimit 8 ,
+.Xr s6-ioconnect 8 ,
+.Xr s6-ipcclient 8 ,
+.Xr s6-ipcserver-access 8 ,
+.Xr s6-ipcserver-socketbinder 8 ,
+.Xr s6-ipcserverd 8
+.Pp
+[1]
+.Lk https://cr.yp.to/proto/ucspi.txt
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-ipcserver.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-ipcserverd.8 b/mdoc/man8/s6-ipcserverd.8
--- a/mdoc/man8/s6-ipcserverd.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-ipcserverd.8	2023-04-16 04:52:39.121496466 -0300
@@ -0,0 +1,157 @@
+.Dd September 29, 2021
+.Dt S6-IPCSERVERD 8
+.Os
+.Sh NAME
+.Nm s6-ipcserverd
+.Nd serving part of the
+.Xr s6-ipcserver 8
+super-server
+.Sh SYNOPSIS
+.Nm
+.Op Fl 1
+.Op Fl v Ar verbosity
+.Op Fl P | p
+.Op Fl c Ar maxconn
+.Op Fl C Ar localmaxconn
+.Ar prog...
+.Sh DESCRIPTION
+.Nm
+assumes that its stdin is a bound and listening Unix domain socket,
+and it accepts connections from clients connecting to it, forking a
+program to handle each connection.
+.Pp
+.Nm
+accepts connections from clients to an already bound and listening
+.Dv SOCK_STREAM
+Unix domain socket which is its standard input.
+.Pp
+For every client connection to this socket, it forks.
+The child sets some environment variables, then executes
+.Ar prog...
+with stdin reading from the socket and stdout writing to it.
+.Pp
+Depending on the verbosity level, it logs what it does to stderr.
+.Pp
+It runs until killed by a signal.
+Depending on the received signal, it may kill its children before
+exiting.
+.Pp
+Unlike his close cousin ipcserver,
+.Nm
+does not perform operations such as access control.
+Those are delegated to the
+.Xr s6-ipcserver-access 8
+program.
+.Pp
+.Nm
+can be used to set up
+.Xr s6-local-service 7 Ns s .
+.Pp
+.Nm
+is meant to be execve'd into by a program that gets the listening
+socket.
+That program is normally
+.Xr s6-ipcserver-socketbinder 8 ,
+which creates the socket itself; but it can be a different one if the
+socket is to be retrieved by another means, for instance by fd-passing
+from an fd-holding daemon
+.Po
+some people call this
+.Dq socket activation
+.Pc .
+.Ss Signals
+.Bl -tag -width x
+.It SIGTERM
+Exit.
+.It SIGHUP
+Send a SIGTERM and a SIGCONT to all children.
+.It SIGQUIT
+Send a SIGTERM and a SIGCONT to all children, then exit.
+.It SIGABRT
+Send a SIGKILL to all children, then exit.
+.El
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl 1
+Write a newline to stdout, and close stdout, right before entering the
+client-accepting loop.
+If stdout is suitably redirected, this can be used by monitoring
+programs to check when the server is accepting connections.
+See
+.Xr s6-notifywhenup 7
+for more information on readiness notification.
+.It Fl v Ar verbosity
+Be more or less verbose.
+.Ar verbosity
+can be 0 (quiet), 1 (normal), or 2 (verbose).
+.It Fl P
+Disable client credentials lookups.
+The
+.Ev IPCREMOTEEUID
+and
+.Ev IPCREMOTEEGID
+environment variables will be unset in every instance of
+.Ar prog... .
+This is the portable option, because not every system supports
+credential lookup across Unix domain sockets; but it is not as secure.
+.It Fl p
+Enable client credentials lookups.
+This is the default; it works at least on Linux, Solaris, and *BSD
+systems.
+On systems that do not support it, every connection attempt will fail
+with a warning message.
+.It Fl c Ar maxconn
+Accept at most
+.Ar maxconn
+concurrent connections.
+Default is 40.
+It is impossible to set it higher than 1000.
+.It Fl C Ar localmaxconn
+Accept at most
+.Ar localmaxconn
+connections from the same user ID.
+Default is 40.
+It is impossible to set it higher than
+.Ar maxconn .
+.El
+.Sh ENVIRONMENT
+For each connection, an instance of
+.Ar prog...
+is spawned with the following variables set:
+.Bl -tag -width x
+.It PROTO
+Always set to IPC.
+.It IPCREMOTEEUID
+Set to the effective UID of the client, unless credentials lookups
+have been disabled.
+.It IPCREMOTEEGID
+Set to the effective GID of the client, unless credentials lookups
+have been disabled.
+.It IPCREMOTEPATH
+Set to the path associated with the remote socket, if any.
+Be aware that it may contain arbitrary characters.
+.It IPCCONNNUM
+Set to the number of connections originating from the same user
+(i.e. same uid).
+.El
+.Pp
+If client credentials lookup has been disabled,
+.Ev IPCREMOTEEUID
+and
+.Ev IPCREMOTEEGID
+will be set, but empty.
+.Sh SEE ALSO
+.Xr s6-accessrules-cdb-from-fs 8 ,
+.Xr s6-accessrules-fs-from-cdb 8 ,
+.Xr s6-connlimit 8 ,
+.Xr s6-ioconnect 8 ,
+.Xr s6-ipcclient 8 ,
+.Xr s6-ipcserver 8 ,
+.Xr s6-ipcserver-access 8 ,
+.Xr s6-ipcserver-socketbinder 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-ipcserverd.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-log.8 b/mdoc/man8/s6-log.8
--- a/mdoc/man8/s6-log.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-log.8	2023-04-16 04:52:39.121496466 -0300
@@ -0,0 +1,868 @@
+.Dd January 15, 2023
+.Dt S6-LOG 8
+.Os
+.Sh NAME
+.Nm s6-log
+.Nd reliable logging program with automated log rotation, similar to daemontools' multilog[1], with full POSIX regular expression support
+.Sh SYNOPSIS
+.Nm
+.Op Fl d Ar notif
+.Op Fl q | Fl v
+.Op Fl b
+.Op Fl p
+.Op Fl l Ar linelimit
+.Op --
+.Ar logging script
+.Sh DESCRIPTION
+.Nm
+reads and compiles
+.Ar logging script
+to an internal form.
+Then it reads its standard input, line by line, and performs actions
+on it, following the script it is given.
+It does its best to ensure there is
+.Em never any log loss .
+It exits cleanly when stdin closes or when it receives a SIGTERM or a
+SIGHUP.
+.Ss logdirs
+A
+.Em logdir
+.Po
+.Em logging directory
+.Pc
+is a place where logs are stored.
+.Nm
+can be scripted to write into one or more logdirs.
+.Pp
+A logdir may contain the following files:
+.Bl -tag -width x
+.It Pa lock
+This file is locked by
+.Nm
+at start, to make sure only one instance is running at the same time.
+.It Pa current
+The file where selected log lines are appended.
+If
+.Pa current
+has the executable-by-user flag, it means that no
+.Nm
+process is currently writing to it and the previous
+.Nm
+process managed to cleanly finalize it.
+If it does not, either an
+.Nm
+process is writing to it or the previous one has been interrupted
+without finalizing it.
+.It Pa state
+Last processor's output, see below.
+.It Pa previous
+A rotation is happening in that logdir.
+.It Pa processed, newstate
+A rotation is happening in that logdir and the processor script is running.
+.It timestamped files
+Those files are
+.Sm off
+@
+.Em timestamp .
+s or @
+.Em timestamp .
+u
+.Sm on
+and are old log files that have been processed and rotated
+.Po
+if they're ending in
+.Ql .s
+.Pc
+or that were the
+.Pa current
+file when
+.Nm
+got interrupted
+.Po
+if they're ending in
+.Ql .u
+.Pc ,
+in which case they have not been processed.
+.El
+.Pp
+.Sy Rotation
+.Pp
+In a logdir, selected lines are appended to the
+.Pa current
+file.
+When
+.Pa current
+becomes too big, a rotation happens.
+The
+.Pa current
+file will be possibly processed, then it will become an archived log
+file named
+.Sm off
+@
+.Em timestamp .
+s,
+.Sm on
+where
+.Em timestamp ,
+a TAI64N[2] timestamp, is the absolute time of the rotation.
+If there are too many archived log files in the logdir, the older ones
+are then deleted.
+Logging then resumes, to a brand new
+.Pa current
+file.
+.Pp
+You can use this mechanism to ensure that your logs never fill up the
+available disk space, for instance: something that neither syslogd,
+nor syslog-ng, nor rsyslog offers.
+.Pp
+.Sy Processors
+.Pp
+A
+.Em processor
+script can be set for every logdir.
+When a rotation occurs,
+.Pa current
+.Po
+which has then been renamed
+.Pa previous
+.Pc
+is fed to
+.Em processor Ap
+s stdin, and
+.Em processor Ap
+s stdout is saved and archived.
+.Em processor
+can also read the
+.Pa state
+file on its fd 4; what it writes to its fd 5 will be saved as the next
+.Pa state
+file, for the next rotation.
+A processor script runs with the logdir as its working directory.
+.Pp
+Processors should not background themselves:
+.Nm s6-log
+considers the processing done when its
+.Em processor
+direct child dies.
+Processors should exit 0 on success and nonzero on failure; if a
+processor fails,
+.Nm s6-log
+will try it again after some
+.Em cooldown
+time.
+.Pp
+Processors make
+.Nm
+Turing-complete by allowing you to use any external program to handle
+log files that are going to be archived.
+.Ss Logging script syntax
+When starting up,
+.Nm
+reads its arguments one by one; this argument sequence, or directive
+sequence, forms a logging script which tells
+.Nm
+what to log, where, and how.
+.Pp
+Every directive can be a
+.Em selection
+directive, a
+.Em control
+directive or an
+.Em action
+directive.
+A valid logging script always contains at least one action directive;
+every action directive can be preceded by zero or more selection or
+control directives.
+.Nm
+will exit 100 if the script is invalid.
+If it can process the script but the last directive is not an action
+directive,
+.Nm
+will emit a warning.
+.Pp
+.Sy Selection directives
+.Pp
+These directives tell
+.Nm
+whether to select or deselect lines it reads from stdin; actions will
+only happen on selected lines.
+By default, every line is selected.
+.Bl -tag -width x
+.Sm off
+.It + Ar regexp
+.Sm on
+Select yet-unselected lines that match
+.Ar regexp ,
+which must be a POSIX Extended Regular Expression[3].
+.Sm off
+.It - Ar regexp
+.Sm on
+Deselect yet-selected lines that match
+.Ar regexp ,
+which must be a POSIX Extended Regular Expression[3].
+.It f
+Select exactly lines that have not yet been acted upon (i.e. that were
+always deselected when the script encountered an action directive).
+.El
+.Pp
+.Sy Control directives
+.Pp
+These directives tune
+.Nm s6-log Ap
+s behaviour for the next actions.
+.Bl -tag -width x
+.Sm off
+.It n Ar number
+.Sm on
+Next logdirs will contain up to
+.Ar number
+archived log files.
+If there are more, the oldest archived log files will be deleted, only
+the latest number will be kept.
+By default,
+.Ar number
+is 10.
+.Sm off
+.It s Ar filesize
+.Sm on
+Next rotations will occur when
+.Pa current
+log files approach
+.Ar filesize
+bytes.
+By default,
+.Ar filesize
+is 99999; it cannot be set lower than 4096 or higher than 268435455.
+.Sm off
+.It S Ar totalsize
+.Sm on
+Next logdirs will contain up to
+.Ar totalsize
+bytes of archived (and maybe processed) log files.
+If archived log files take more space than that, the older ones are
+deleted until the total size fits.
+A
+.Ar totalsize
+of zero means no such limit; use
+.Ql n0
+instead if you don't want any archived log files.
+By default,
+.Ar totalsize
+is 0 (unlimited).
+.Sm off
+.It l Ar tolerance
+.Sm on
+Next rotations will be triggered when the size of
+.Pa current
+goes higher than
+.Ar filesize
+minus
+.Ar tolerance .
+.Ar tolerance
+cannot be more than half of
+.Ar filesize .
+By default,
+.Ar tolerance
+is 2000.
+.Sm off
+.It r Ar cooldown
+.Sm on
+If an error occurs during operations on the next logdirs, retry every
+.Ar cooldown
+milliseconds.
+By default,
+.Ar cooldown
+is 2000; it's strongly discouraged to set it to a value under 50.
+.Sm off
+.It E Ar alertsize
+.Sm on
+Only the first
+.Ar alertsize
+bytes of the selected lines will be used in the next alerts.
+An
+.Ar alertsize
+of 0 means no limit.
+By default,
+.Ar alertsize
+is 200.
+.Sm off
+.It ^ Ar statussize
+.Sm on
+Only the first
+.Ar statussize
+bytes of the selected lines will be used in the next status file
+updates.
+If a line is shorter than
+.Ar statussize
+bytes, the status file will be padded with newlines so it is always
+.Ar statussize
+bytes long. 0 means an unpadded, unlimited status file.
+By default,
+.Ar statussize
+is 1001.
+.Sm off
+.It p Ns Ar prefix
+Set
+.Ar prefix
+as a prefix to be printed on every output line.
+For instance, a
+.Ql pfoobar:\&
+directive means that the next action directives should prepend every
+line with
+.Ql foobar:\&
+.Po
+plus a space
+.Pc
+before outputting it.
+Note that a prefix is always printed
+.Em after
+the timestamps, if any.
+To remove a prefix for the next action directives, use a standalone
+.Ql p .
+.It ! Ar processor
+.Sm on
+Registers
+.Ql execlineb -Pc Ar processor
+as a processor for the next logdirs;
+.Ql execlineb
+must be found in
+.Nm Ap
+s
+.Ev PATH .
+This directive is only supported if s6 has been built with execline
+support; otherwise, it yields a syntax error at starting time.
+If
+.Ar processor
+is empty, no processor will be set for the next logdirs.
+By default, no processor is set.
+.Sm off
+.It ? Ar processor
+.Sm on
+Registers
+.Ql /bin/sh -c Ar processor
+as a processor for the next logdirs.
+It is just like the
+.Ql \&!
+directive, except that the processor string is interpreted by
+.Pa /bin/sh ,
+not execlineb.
+It is useful for people who want to build s6 without execline support.
+.It t
+The logged line will be prepended with a TAI64N[2] timestamp (and a
+space) before being processed by the next action directive.
+Giving the
+.Ql t
+directive several times before an action directive has no effect.
+.It T
+The selected line will be prepended with a ISO 8601[4] timestamp for
+combined date and time representing local time according to the
+system's timezone, with a space (not a 'T') between the date and the
+time and two spaces after the time, before being processed by the next
+action directive.
+Giving the
+.Ql T
+directive several times before an action directive has no effect.
+.El
+.Pp
+Note that unlike the other control directives, the
+.Ql t
+and
+.Ql T
+directives are
+.Em not sticky :
+their effect will disappear after the next action directive, and they
+need to be reapplied if necessary.
+If both a
+.Ql t
+and a
+.Ql T
+directives are given before an action directive, the TAI64N[2] timestamp
+will always appear before the ISO 8601 timestamp.
+.Ss Action directives
+These directives determine what
+.Nm
+actually does with the selected lines.
+.Bl -tag -width x
+.It 2
+Alert.
+.Nm
+will print
+.Dq s6-log: alert: ,
+possibly prepended with a timestamp, followed by the first
+.Ar alertsize
+bytes of the line, to its standard error.
+.It 1
+Forward to stdout.
+.Nm
+will print the selected line to its stdout.
+If any error occurs, e.g. if stdout was a pipe and the reading end
+closed, this directive will be ignored for the rest of
+.Nm Ap
+s lifetime.
+.Sm off
+.It = Ar statusfile
+.Sm on
+Status.
+.Nm
+will atomically update the
+.Ar statusfile
+file with the first
+.Ar statussize
+bytes of the line, and pad it with newlines.
+.Nm
+must have the right to write to
+.Ar statusfile
+and to
+.Ar statusfile Ap
+s directory.
+.It dir
+logdir.
+Must start with
+.Ql /
+or
+.Ql \&. .
+.
+.Nm
+will log the line into the logdir
+.Ar dir .
+.Nm
+must have the right to write to
+.Ar dir .
+.El
+.Ss Signals
+.Bl -tag -width x
+.It SIGTERM
+If
+.Nm
+has been run with the
+.Fl p
+option, does nothing.
+Without this option, SIGTERM instructs
+.Nm
+to stop reading stdin after the next newline and exit after logging
+the last line.
+.It SIGALRM
+Triggers a rotation on every logdir
+.Nm
+is monitoring, as if the
+.Pa current
+file in those logdirs had reached the size limit.
+.El
+.Ss Why use execlineb to interpret the Do processor Dc string?
+Because it is exactly what
+.Xr execlineb 1
+is for.
+.Bl -bullet -width x
+.It
+Directly executing
+.Ar processor
+is not flexible enough.
+We want to be able to run a complete command line, with an executable
+name and its arguments.
+.It
+We could interpret the processor string via
+.Pa /bin/sh .
+This is what multilog[1] does.
+However,
+.Pa /bin/sh ,
+despite being the traditional Unix interpreter, is overpowered for
+this.
+We don't need a complete shell script interpreter: most processor
+commands will be very simple, with only two or three words, and we
+only need a way to turn a string into an
+.Em argv ,
+i.e. a command line.
+.It
+.Xr execlineb 1
+was designed just for this: to turn simple strings into command lines.
+It is a very fast and lightweight script launcher, that does not do
+any heavy startup initialization like
+.Pa /bin/sh
+does.
+It happens to be the perfect tool for the job.
+.It
+To be perfectly honest: I also did this on purpose so people have a
+reason to use the execline[5] language.
+But seriously, it really is the perfect tool for the job.
+.El
+.Ss Why have another logging mechanism?
+Because the syslog mechanism and all its implementations (save one)
+suck.
+I'm not being judgmental; I'm just stating the obvious.
+.Pp
+.Sy The syslog design is flawed from the start
+.Pp
+When asked why he started rsyslog[6], Rainer Gerhards came up with a lot
+of hand-waving and not a single word about technical points.
+There is a reason for that: rsyslog is forked from sysklogd!
+So, no matter how many bells and whistles are added to it, it still
+suffers from the same basic flaws.
+.Pp
+The problem with syslogd does not come from such or such
+implementation.
+The problem comes from syslog's
+.Em design
+in the first place.
+.Bl -bullet -width x
+.It
+syslog makes you send
+.Em all
+your logs to the same place.
+The logs from a zillion processes are read by a single syslogd
+server.
+The server checks log lines against system-wide regular expressions to
+decide where to write them.
+This raises the following issues:
+.Bl -bullet -width x
+.It
+Unless the client explicitly mentions its name in every log line,
+there is no way for log readers to know what process generated a given
+line.
+Some syslogd implementations can log the pid of the client; big deal.
+.It
+Log lines from every client have to run through the same regular
+expression matching.
+This requires huge regular expression sets, and an obvious performance
+impact, to do anything meaningful.
+And as a matter of fact, standard syslogd configurations don't do
+anything meaningful: they separate the logs into a few streams such as
+.Pa /var/log/messages ,
+.Pa /var/log/auth.log ,
+.Pa /var/log/daemon.log
+or
+.Pa /var/log/syslog
+with very vague semantics.
+All of syslogd's line processing power remains unused, because making
+real use of it would be too complex.
+.El
+.It
+syslogd logs to
+.Em files .
+This is wrong, because files grow and disks fill up.
+Sure, there are utilities such as
+.Pa logrotate
+to perform cleaning up, but as long as logging and log rotation are
+kept separate, there is a race condition: a log file can grow and fill
+up a disk before a rotation occurs.
+I am all for separating tasks that can be separated, but there is no
+choice here:
+.Em logging and log rotation management must be done
+.Sy by the same tool .
+Only a few non-mainstream implementations of syslogd do this,
+including the Busybox[7] one - and that is a feature added by the Busybox
+developers who are aware of the problem but want to maintain
+compatibility with the historical syslogd.
+Neither syslogd (-ng or not) nor rsyslogd manages its log files:
+that's a flaw that no amount of external tools is going to fix.
+.It
+syslogd is a complex process that runs as root.
+We all know what complex processes running as root mean: bugs turning
+into security holes.
+.It
+syslog requires a syslogd service, and fails otherwise.
+A syslogd service may not be present, it may fail... or it may want to
+log stuff.
+Who's going to take care of syslogd's error messages?
+.El
+.Pp
+syslog is slow, it's unsafe, and it's incomplete.
+The only reason people use it is because it's historical, it exists,
+and there hasn't been any serious alternative yet, except maybe
+multilog[1], which
+.Nm
+improves upon.
+.Pp
+.Sy A not-so-modest proposal: the logging chain
+.Pp
+Unix distributions already do this to some extent, but it's at best
+unclear where the logs go for any given program.
+.Bl -bullet -width x
+.It
+Every program, without exception, should send its logs (be it error
+messages, warning messages, or anything) to its
+.Em standard error descriptor ,
+i.e. fd 2.
+.Em This is why it's open for .
+.It
+When process 1 starts, the logging chain is rooted to the
+.Em machine console :
+anything process 1 sends to its stderr appears, without modification,
+on the machine console, which should at any time remain the last
+resort place where logs are sent.
+.It
+Process 1 should spawn and supervise a
+.Em catch-all logging mechanism
+that handles logs from every service that does not take care of its
+own logging.
+Error messages from this logging mechanism naturally go to the machine
+console.
+.It
+Process 1's own error messages can go to the machine console, or dirty
+tricks can be used[8] so they go to the catch-all logging mechanism.
+.It
+Services that are spawned by process 1 should come with their own
+logger service; the supervision mechanism offered by
+.Xr s6-svscan 8
+makes it easy.
+Error messages from the loggers themselves naturally go to the
+catch-all mechanism.
+.It
+User login mechanisms such as
+.Pa getty ,
+.Pa xdm
+or
+.Pa sshd
+are services: they should be started with their own loggers.
+Of course, when a user gets a terminal and a shell, the shell's stderr
+should be redirected to the terminal: interactive programs break the
+automatic logging chain and delegate responsibility to the user.
+.It
+A syslogd service
+.Em may
+exist, to catch logs sent via
+.Fn syslog
+by legacy programs.
+But it is a normal service, and logs caught by this syslogd service
+are not part of the logging chain.
+It is probably overkill to provide the syslogd service with its own
+logger; error messages from syslogd can default to the catch-all
+logger.
+The s6 package, including the
+.Xr ucspilogd 8
+program, provides enough tools to easily implement a complete syslogd
+system, for a small fraction of the resource needs and the complexity
+of native syslogd implementations.
+.El
+.Pp
+So, given a program, where are its logs sent?
+.Bl -bullet -width x
+.It
+Logs sent via
+.Fn syslog
+will be handled by the syslogd service as usual.
+Smart administrators will make sure that those ones are as few as
+possible.
+The rest of this analysis is about logs sent to stderr.
+.It
+If the program is descended from a user's interactive program, its
+logs are sent to the user's terminal or the user's choice redirection
+target.
+.It
+If the program is descended from a logged service, its logs are
+naturally sent to the service's logger.
+.It
+Else the logs are sent to the catch-all logger.
+.It
+Only the catch-all logger's error messages, the kernel's fatal error
+messages, and maybe process 1's error messages, are sent to the system
+console.
+.El
+.Pp
+.Sy What does s6-log have to do with all this?
+.Pp
+In a
+.Em logging chain
+situation, every service must have its own logger.
+To avoid syslogd's design mistakes, one logger process per service
+must be run.
+.Nm
+fits that role.
+Using
+.Nm
+as your one-stop logger offers the following benefits:
+.Bl -bullet -width x
+.It
+Every instance of
+.Nm
+can run as a different user, so it's easy to give different access
+rights to different logs.
+It is also more secure not to have any logger process running as root.
+.It
+.Nm
+consumes very little memory per instance (unless it accumulates
+unflushed log lines, which you can avoid with the
+.Fl b
+option).
+So, launching a lot of
+.Nm
+processes does not waste resources.
+.It
+.Nm
+is vastly configurable via logging scripts; every instance is as
+powerful as a traditional syslogd.
+.It
+.Nm
+can log to a RAM filesystem and thus is suitable as a catch-all
+logger.
+Clever tricks like Upstart's logd or daemontools' readproctitle[9] are
+just that: tricks.
+.Nm
+gives a unified interface to all of your system's loggers.
+.El
+.Pp
+.Sy You're wrong about being as powerful as syslogd: s6-log does not do remote logging.
+.Pp
+You mean you want to send,
+.Em live ,
+every
+.Em log line
+over the network via
+.Em UDP ?
+You can't be serious.
+.Pp
+Do yourself a favor and use
+.Nm
+to write log lines to a logdir, with a processor script that sends
+files-being-archived to the network, possibly after compressing
+them.
+More reliability, less log lines lost, less network traffic, better
+engineering.
+If you have no disk to even write the
+.Pa current
+files to, write to a small RAM filesystem.
+.Pp
+If you
+.Em have
+to log stuff
+.Em live
+via the network, you do not need any local logging software.
+You don't even need syslogd.
+Just filter your stderr via some
+.Ql grep
+that selects lines for you, then sends them to a network socket.
+A trivial shell script, or execline script, can do that for you.
+.Pp
+Do not insist on using syslogd.
+It does nothing magical, and nothing that can't be done in a simpler
+way using simpler tools.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl d Ar notif
+Readiness notification.
+With this option,
+.Nm
+writes a newline character to file descriptor
+.Ar notif
+when it is ready, i.e. when it has successfully parsed its logging
+script and initialized all its necessary resources such as the logdirs
+defined in the script, and is now listening to stdin in order to
+process log lines.
+.It Fl b
+Blocking mode.
+With this option,
+.Nm
+stops reading its standard input while it has unflushed buffers.
+This ensures that every log line has been fully processed before
+reading the next one; this is also multilog[1]'s behaviour.
+By default,
+.Nm
+keeps reading from stdin even if its buffers still contain data.
+.Fl b
+is safer, but may slow down your service; the default is faster, but
+may lead to unbound memory use if you have a lot of output to write to
+a slow file system.
+.It Fl p
+Protect against SIGTERM.
+Do not exit on receipt of a SIGTERM; only exit on a SIGHUP or when
+reading EOF on stdin.
+This is useful for a logger that you really do not want to lose even
+if automated administration (e.g. the downing of a supervision tree)
+would kill it.
+.It Fl q | v
+Quiet | verbose.
+Decreases | increases
+.Nm Ap
+s verbosity, i.e. which messages are sent to stderr.
+The default verbosity is 1.
+Currently supported verbosity levels:
+.Bl -tag -width x
+.It 0
+Only write alerts and fatal errors.
+.It 1
+Write alerts, warnings and fatal errors.
+.El
+.It Fl l Ar linelimit
+If a log line is longer than
+.Ar linelimit
+bytes, split it by inserting a newline after the
+.Ar linelimit Ns
+th byte.
+After the split, the remainder of the line will also be processed, so
+it will go through the selection process, timestamping, etc.
+.Ar linelimit
+cannot be less than 48, unless it is 0 (which means infinite).
+The default is 8192 bytes.
+Setting
+.Ar linelimit
+to 0 ensures that lines will never be split; this may cause important
+memory consumption by
+.Nm
+if it is fed extremely long lines, so use with caution.
+.El
+.Sh EXAMPLES
+.Dl s6-log -b n20 s1000000 t /var/log/services/stuff
+.Pp
+Logs all of stdin, prepending every line with a TAI64N[2] timestamp, into
+the
+.Pa /var/log/services/stuff
+logdir, with a maximum archive of 20 log files of 1 MB each; makes
+sure every line has been written before reading the next one.
+.Pp
+.Dl s6-log n30 E500 - +fatal: 2 - +^STAT =/var/log/foobard/status f s10000000 S15000000 T !"gzip -nq9" /var/log/foobard
+.Bl -bullet -width x
+.It
+Sends alerts to stderr with the 500 first bytes of lines containing
+.Dq fatal: .
+.It
+Maintains the
+.Pa /var/log/foobard/status
+file at 1001 bytes, updating it when it finds a log line starting with
+.Dq STAT .
+.It
+Logs all other lines to logdir
+.Pa /var/log/foobard ,
+prepending them with an ISO 8601 timestamp.
+When
+.Pa current
+reaches at least 9998 kB (i.e. 10 MB filesise minus 2kB tolerance),
+pipe it through
+.Ql gzip -nq9
+and save the result into a timestamped archive file, with a maximum of
+30 such files or a total of 15 MB of compressed archive files.
+.El
+.Sh SEE ALSO
+.Xr execlineb 1 ,
+.Xr ucspilogd 8
+.Pp
+[1]
+.Lk https://cr.yp.to/daemontools/multilog.html
+.Pp
+[2]
+.Lk https://skarnet.org/software/skalibs/libstddjb/tai.html
+.Pp
+[3]
+.Lk https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04
+.Pp
+[4]
+.Lk https://en.wikipedia.org/wiki/ISO_8601
+.Pp
+[5]
+.Lk https://skarnet.org/software/execline/
+.Pp
+[6]
+.Lk https://blog.gerhards.net/2007/08/why-doesworld-need-another-syslogd.html
+.Pp
+[7]
+.Lk https://busybox.net/
+.Pp
+[8]
+.Lk https://skarnet.org/software/s6/s6-svscan-1.html#log
+.Pp
+[9]
+.Lk https://cr.yp.to/daemontools/readproctitle.html
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-log.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-mkfifodir.8 b/mdoc/man8/s6-mkfifodir.8
--- a/mdoc/man8/s6-mkfifodir.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-mkfifodir.8	2023-04-16 04:52:39.121496466 -0300
@@ -0,0 +1,53 @@
+.Dd September 29, 2021
+.Dt S6-MKFIFODIR 8
+.Os
+.Sh NAME
+.Nm s6-mkfifodir
+.Nd create an
+.Xr s6-fifodir 7
+.Sh SYNOPSIS
+.Nm
+.Op Fl f
+.Op Fl g Ar gid
+.Ar fifodir
+.Sh DESCRIPTION
+.Nm
+creates
+.Ar fifodir ,
+belonging to the current user.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl f
+Force permissions.
+If
+.Ar fifodir
+already exists, change its permissions according to the
+.Fl g
+options.
+By default, if
+.Ar fifodir
+exists,
+.Nm
+does nothing.
+.It Fl g Ar gid
+Make
+.Ar fifodir
+only listenable by members of group
+.Ar gid .
+If this option is not given, the
+.Ar fifodir
+is made publically listenable.
+.El
+.Sh SEE ALSO
+.Xr s6-cleanfifodir 8 ,
+.Xr s6-ftrig-listen 8 ,
+.Xr s6-ftrig-listen1 8 ,
+.Xr s6-ftrig-notify 8 ,
+.Xr s6-ftrig-wait 8 ,
+.Xr s6-ftrigrd 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-mkfifodir.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-notifyoncheck.8 b/mdoc/man8/s6-notifyoncheck.8
--- a/mdoc/man8/s6-notifyoncheck.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-notifyoncheck.8	2023-04-16 04:52:39.122496466 -0300
@@ -0,0 +1,255 @@
+.Dd September 29, 2021
+.Dt S6-NOTIFYONCHECK 8
+.Os
+.Sh NAME
+.Nm s6-notifyoncheck
+.Nd implement a policy of running a user-provided executable in the background that polls the service currently being launched, in order to check when it becomes ready, and feed the result of this check into the s6 notification mechanism
+.Sh SYNOPSIS
+.Nm
+.Op Fl d
+.Op Fl 3 Ar notiffd
+.Op Fl s Ar initialsleep
+.Op Fl T Ar globaltimeout
+.Op Fl t Ar localtimeout
+.Op Fl w Ar waitingtime
+.Op Fl n Ar n
+.Op Fl c Ar checkprog
+.Ar prog...
+.Sh DESCRIPTION
+.Nm
+is a chain-loading program meant to be used in run scripts, in a
+service that has been declared to honor readiness notification.
+.Pp
+.Nm
+should
+.Sy only
+be used with daemons that can be polled from the outside to check
+readiness, and that
+.Sy do not implement readiness notification themselves .
+.Pp
+.Nm
+forks and runs as the child; the parent immediately execs into
+.Ar prog... ,
+the daemon that must be checked for readiness.
+.Pp
+.Nm
+first waits for a little time, then it spawns the
+.Pa ./data/check
+executable and waits for it to exit.
+If
+.Pa ./data/check
+exits 0, then
+.Nm
+reports that the service is ready, then exits.
+If
+.Pa ./data/check
+exits anything else,
+.Nm
+sleeps for a little time, then spawns
+.Pa ./data/check
+again.
+It loops until
+.Pa ./data/check
+succeeds, or 7 attempts fail, or a certain amount of time elapses.
+.Pp
+.Nm
+is designed to make it possible for services to use the s6
+notification mechanism
+.Po
+cf.
+.Xr s6-notifywhenup 7
+.Pc
+even with daemons that do not natively implement the mechanism of
+writing a newline to a file descriptor of their choice when they're
+ready.
+.Pp
+Polling[1] is evil.
+Please make sure you really have no other choice before writing a
+.Pa ./data/check
+program and using
+.Nm
+in your run script.
+If you have access to the source code of the daemon you want to check
+for readiness, consider patching it to add readiness notification
+support, which is extremely simple and does not require linking
+against any s6 library.
+.Pp
+If using a
+.Pa ./data/check
+program is your only option:
+.Bl -bullet -width x
+.It
+Make sure the
+.Pa ./data
+subdirectory is readable and that
+.Pa ./data/check
+is executable, exits 0 if the daemon it checks is ready, and exits
+nonzero if the daemon is not ready.
+.It
+Add a
+.Pa ./notification-fd
+file to your service directory, which can contain any number that is
+not 0, 1 or 2, or anything else explicitly used in your run
+script.
+The daemon does not need to care about that file descriptor; from the
+daemon's point of view, nothing changes.
+.It
+In your run script, insert
+.Nm
+in the command line that will execute into your daemon.
+.It
+.Pa ./data/check
+will run as the same user as
+.Nm .
+If
+.Nm
+runs after the run script's process has lost its root privileges, make
+sure that
+.Pa ./data/check
+is accessible and runnable as that user.
+.It
+Note that
+.Nm
+should be used to check if
+.Em the current service itself
+is running.
+You cannot use it to poll for the readiness of another service.
+.El
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl d
+Doublefork.
+.Nm
+will run as the grandchild of
+.Ar prog...
+instead of its direct child.
+This is useful if
+.Ar prog...
+never reaps zombies it does not know it has.
+.It Fl 3 Ar notiffd
+Use
+.Ar notiffd
+as the file descriptor to send a readiness notification to.
+By default, this number is automatically read from the
+.Pa ./notification-fd
+file.
+.It Fl s Ar initialsleep
+Sleep for
+.Ar initialsleep
+milliseconds before starting to poll the service for readiness.
+Default is 10 milliseconds.
+.It Fl T Ar globaltimeout
+Give up (and leave the service up but not ready) if service readiness
+still has not been detected after
+.Ar globaltimeout
+milliseconds.
+Default is 0, meaning infinite:
+.Nm
+will keep polling until it succeeds.
+.It Fl t Ar localtimeout
+On every attempt, if
+.Pa ./data/check
+still has not exited after
+.Ar localtimeout
+milliseconds, kill it and declare that attempt failed.
+Default is 0, meaning infinite:
+.Nm
+will wait forever for
+.Pa ./data/check
+to exit.
+.It Fl w Ar waitingtime
+Sleep for
+.Ar waitingtime
+milliseconds between two invocations of
+.Pa ./data/check .
+This is basically the polling period.
+Default is 1000: the service will be polled every second.
+.It Fl n Ar n
+Give up after
+.Ar n
+unsuccessful invocations of
+.Pa ./data/check .
+0 means infinite, i.e. keep polling until it succeeds, or times out,
+or the service dies first.
+Default is 7.
+.It Fl c Ar checkprog...
+Invoke
+.Ar checkprog...
+instead of
+.Pa ./data/check .
+The
+.Ar checkprog
+string will be parsed by
+.Xr execlineb 1 ,
+so it can contain a full command line.
+This option is mainly useful is the program used to poll the service
+is very simple and can be inlined as a simple command line, to avoid
+needing to manage a whole script and a
+.Pa ./data/check
+file.
+This option is only supported if the execline[2] package is installed; if
+it is not, the
+.Fl c
+option cannot be used and the checking script must always be placed in
+.Pa ./data/check .
+.El
+.Sh EXIT STATUS
+.Nm
+can exit before executing into
+.Ar prog :
+.Bl -tag -width x
+.It 100
+Wrong usage.
+.It 111
+System call failed.
+.El
+.Pp
+After forking,
+.Nm
+(running as the child) can exit with the following exit codes, but
+those are meaningless because no process will, or should, check
+them.
+They are only differentiated for clarity in the code:
+.Bl -tag -width x
+.It 0
+Service readiness achieved and notification sent.
+.It 1
+Maximum number of attempts reached, all unsuccessful.
+.It 2
+.Ar prog
+died, so
+.Nm
+exited early.
+.It 3
+Timed out before readiness was achieved.
+.It 111
+System call failed.
+.El
+.Sh SEE ALSO
+.Xr execlineb 1 ,
+.Xr s6-permafailon 8 ,
+.Xr s6-supervise 8 ,
+.Xr s6-svc 8 ,
+.Xr s6-svdt 8 ,
+.Xr s6-svdt-clear 8 ,
+.Xr s6-svlisten 8 ,
+.Xr s6-svlisten1 8 ,
+.Xr s6-svok 8 ,
+.Xr s6-svscan 8 ,
+.Xr s6-svscanctl 8 ,
+.Xr s6-svstat 8 ,
+.Xr s6-svwait 8
+.Pp
+.Bk -words
+[1]
+.Lk https://skarnet.org/cgi-bin/archive.cgi?2:mss:1607:dfblejammjllfkggpcph
+.Ek
+.Pp
+[2]
+.Lk https://skarnet.org/software/execline/
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-notifyoncheck.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-permafailon.8 b/mdoc/man8/s6-permafailon.8
--- a/mdoc/man8/s6-permafailon.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-permafailon.8	2023-04-16 04:52:39.122496466 -0300
@@ -0,0 +1,138 @@
+.Dd September 29, 2021
+.Dt S6-PERMAFAILON 8
+.Os
+.Sh NAME
+.Nm s6-permafailon
+.Nd read and analyse the death tally of a service (i.e. the recent process death events that happened), and if the death tally matches a given pattern, cause
+.Em permanent failure
+of the service, i.e. tells the supervisor not to try and restart it
+.Sh SYNOPSIS
+.Nm
+.Ar secs
+.Ar deathcount
+.Ar events
+.Ar prog...
+.Sh DESCRIPTION
+.Nm
+is meant to be used in the
+.Pa ./finish
+script of a service directory supervised by
+.Xr s6-supervise 8 .
+.Pp
+.Nm
+must have the service directory of the tested service as its current
+directory.
+This is the default if it is called from the
+.Pa finish
+script of the service.
+.Pp
+It reads the death tally of the service, which is maintained by
+.Xr s6-supervise 8 .
+.Pp
+If the supervised process has died at least
+.Ar deathcount
+times in the last
+.Ar secs
+seconds with a cause listed in
+.Ar events ,
+then
+.Nm
+exits 125.
+Else
+.Nm
+execs into
+.Ar prog... .
+.Pp
+.Ar events
+is a comma-separated list of events.
+An event can be one of the following:
+.Bl -bullet -width x
+.It
+An exit code, which is an integer between 0 and 255.
+Example:
+.Ql 1 .
+.It
+An exit code interval, which is two exit codes separated by a
+dash.
+Example:
+.Ql 1-50 .
+.It
+A signal name, or a signal number preceded by
+.Sq SIG .
+Examples:
+.Ql SIGTERM ,
+.Ql sigabrt ,
+.Ql sig11 .
+.El
+.Xr s6-supervise 8
+detects when the
+.Pa ./finish
+script of its service exits 125, and stops respawning the service.
+So, if the
+.Pa ./finish
+script is a chain-loading command line starting with a
+.Nm
+invocation (or containing such an invocation), when
+.Nm
+exits 125, then the
+.Pa ./finish
+script also exits 125 (because it is the same process), and the
+service is then marked as failing permanently.
+.Pp
+The
+.Pa ./finish
+script is
+.Em naturally
+a chain-loading command line if it is written in the execline[1]
+language.
+It can also be made into a chain-loading command line from a shell
+script by using
+.Ql exec s6-permafailon secs deathcount events rest-of-chainloading-cmdline...
+.Pp
+Multiple invocations of
+.Nm
+can be chained, in order to test several death patterns.
+.Pp
+If a permanent failure is triggered and
+.Ar secs
+is high, it is possible that when the administrator manually launches
+the service again, the next death triggers a permanent failure
+again.
+If this is not wanted, the administrator should clear the death tally
+with the
+.Xr s6-svdt-clear 8
+command.
+.Pp
+The current death tally can be viewed via the
+.Xr s6-svdt 8
+command.
+.Sh EXAMPLES
+.Dl s6-permafailon 60 5 1,101-103,SIGSEGV,SIGBUS prog...
+.Pp
+will exit 125 if the service has died 5 times in the last 60 seconds
+with an exit code of 1, 101, 102 or 103, a SIGSEGV or a SIGBUS.
+Else it will chainload into the
+.Ql prog...
+command line.
+.Sh SEE ALSO
+.Xr s6-notifyoncheck 8 ,
+.Xr s6-supervise 8 ,
+.Xr s6-svc 8 ,
+.Xr s6-svdt 8 ,
+.Xr s6-svdt-clear 8 ,
+.Xr s6-svlisten 8 ,
+.Xr s6-svlisten1 8 ,
+.Xr s6-svok 8 ,
+.Xr s6-svscan 8 ,
+.Xr s6-svscanctl 8 ,
+.Xr s6-svstat 8 ,
+.Xr s6-svwait 8
+.Pp
+[1]
+.Lk https://skarnet.org/software/execline/
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-permafailon.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-setlock.8 b/mdoc/man8/s6-setlock.8
--- a/mdoc/man8/s6-setlock.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-setlock.8	2023-04-16 04:52:39.122496466 -0300
@@ -0,0 +1,82 @@
+.Dd September 29, 2021
+.Dt S6-SETLOCK 8
+.Os
+.Sh NAME
+.Nm s6-setlock
+.Nd take a lock on a file, then execute into another program
+.Sh SYNOPSIS
+.Nm
+.Op Fl n | N | t Ar timeout
+.Op Fl r | w
+.Ar file
+.Ar prog...
+.Sh DESCRIPTION
+.Nm
+creates
+.Ar file
+if it does not exist and opens it for writing.
+.Pp
+It locks
+.Ar file .
+If it cannot take the lock for any reason, it exits 1.
+.Pp
+It executes into
+.Ar prog... .
+.Pp
+.Nm
+leaks an open file descriptor into the
+.Ar prog
+execution.
+This is intended: the fd holds the lock, which is released when
+.Ar prog
+exits.
+.Ar prog
+must not touch fds it does not know about.
+.Pp
+If the timed lock option is chosen,
+.Nm
+does not acquire the lock itself.
+Instead, it spawns an
+.Xr s6lockd-helper 8
+process that acquires the lock while
+.Nm
+controls the timeout; the
+.Xr s6lockd-helper 8
+process then holds the lock and lives as long as
+.Ar prog .
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl n
+Nonblocking lock.
+If
+.Nm
+cannot acquire the lock, it will exit 1 immediately.
+.It Fl N
+Blocking lock.
+.Nm
+will wait until it can acquire the lock.
+This is the default.
+.It Fl t Ar timeout
+Timed lock.
+If
+.Nm
+cannot acquire the lock after
+.Ar timeout
+milliseconds, it will exit 1.
+.It Fl r
+Shared lock.
+Other shared locks on the same file will not prevent the lock from
+being acquired (but an exclusive lock will).
+.It Fl w
+Exclusive lock.
+This is the default.
+.El
+.Sh SEE ALSO
+.Xr s6lockd 8 ,
+.Xr s6lockd-helper 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-setlock.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-setsid.8 b/mdoc/man8/s6-setsid.8
--- a/mdoc/man8/s6-setsid.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-setsid.8	2023-04-16 04:52:39.122496466 -0300
@@ -0,0 +1,107 @@
+.Dd September 29, 2021
+.Dt S6-SETSID 8
+.Os
+.Sh NAME
+.Nm s6-setsid
+.Nd run a program as a new session leader, or in a new foreground or background process group
+.Sh SYNOPSIS
+.Nm
+.Op Fl s | b | f | g
+.Op Fl i | I | q
+.Op Fl d Ar ctty
+.Ar prog...
+.Sh DESCRIPTION
+.Nm
+creates a new session, or a new process group, and may make that
+process group the foreground process group, depending on the options
+it is run with.
+.Pp
+As session leader or process group leader,
+.Nm
+then executes into
+.Ar prog... .
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl s
+Session.
+.Nm
+will try and execute
+.Ar prog
+as a session leader.
+This is the default.
+.It Fl b
+Background process group.
+.Nm
+will not create a new session, but will create a new process group,
+and try and execute
+.Ar prog
+as the new process group leader.
+.It Fl f
+Foreground process group.
+.Nm
+will not create a new session, but will create a new process group and
+attach its session's controlling terminal to the new process group
+before executing
+.Ar prog .
+However, the new process group will likely be stopped, waiting for the
+former foreground process group to relinquish the controlling
+terminal, and will need to be sent a SIGCONT to resume.
+To avoid that, use the next option.
+.It Fl g
+Grab terminal.
+.Nm
+will not create a new session, but will create a new process group and
+attach its session's controlling terminal to the new process group
+before executing
+.Ar prog .
+It will forcefully grab the controlling terminal from the former
+foreground process group: a process belonging to that former
+foreground process group will be stopped if it attempts to read from
+or write to that terminal.
+.It Fl i
+Strict.
+If
+.Nm
+cannot perform the operations it needs, it will exit 111 with an error
+message.
+.It Fl I
+Loose.
+If
+.Nm
+cannot perform the operations, it will print a warning message, but
+exec into
+.Ar prog
+nonetheless.
+This is the default.
+.It Fl q
+Silent.
+.Nm
+will not print any warning message; it will exec into
+.Ar prog
+even if it cannot perform the operations.
+.It Fl d Ar ctty
+Assume file descriptor number
+.Ar ctty
+is the controlling terminal for the current session.
+Default is 0.
+This is only useful when used with the
+.Fl f
+or
+.Fl g
+options.
+.El
+.Sh SEE ALSO
+.Xr s6-applyuidgid 8 ,
+.Xr s6-envdir 8 ,
+.Xr s6-envuidgid 8 ,
+.Xr s6-fghack 8 ,
+.Xr s6-setuidgid 8 ,
+.Xr s6-softlimit 8 ,
+.Xr s6-tai64n 8 ,
+.Xr s6-tai64nlocal 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-setsid.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-setuidgid.8 b/mdoc/man8/s6-setuidgid.8
--- a/mdoc/man8/s6-setuidgid.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-setuidgid.8	2023-04-16 04:52:39.122496466 -0300
@@ -0,0 +1,68 @@
+.Dd January 15, 2023
+.Dt S6-SETUIDGID 8
+.Os
+.Sh NAME
+.Nm s6-setuidgid
+.Nd execute a program as another user
+.Sh SYNOPSIS
+.Nm
+.Ar account
+.Ar prog...
+.Sh DESCRIPTION
+If
+.Ar account
+is the empty string, then
+.Nm
+directly
+.Xr exec 3 Ns
+s into
+.Ar prog...
+without any state changes.
+If
+.Ar account
+contains a colon, it is interpreted as
+.Sm off
+.So
+.Em uid :
+.Em gid
+.Sc
+.Sm on ,
+else it is interpreted as a username and looked up by name in the
+account database.
+.Pp
+If
+.Ar account
+is unknown,
+.Nm
+exits 1.
+.Nm
+sets its (real and effective) uid and gid to those of
+.Ar account .
+It also sets the list of supplementary groups to the correct one for
+.Ar account
+according to the group database.
+.Pp
+Then it executes into
+.Ar prog... .
+.Pp
+Unless
+.Ar account
+is empty,
+.Nm
+can only be run as root.
+Its main use is to drop root privileges before starting a daemon.
+.Sh SEE ALSO
+.Xr s6-applyuidgid 8 ,
+.Xr s6-envdir 8 ,
+.Xr s6-envuidgid 8 ,
+.Xr s6-fghack 8 ,
+.Xr s6-setsid 8 ,
+.Xr s6-softlimit 8 ,
+.Xr s6-tai64n 8 ,
+.Xr s6-tai64nlocal 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-setuidgid.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-socklog.8 b/mdoc/man8/s6-socklog.8
--- a/mdoc/man8/s6-socklog.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-socklog.8	2023-04-16 04:52:39.122496466 -0300
@@ -0,0 +1,247 @@
+.Dd September 29, 2021
+.Dt S6-SOCKLOG 8
+.Os
+.Sh NAME
+.Nm s6-socklog
+.Nd minimal syslog daemon
+.Sh SYNOPSIS
+.Nm
+.Op Fl d Ar notif
+.Op Fl r
+.Op Fl U | Fl u Ar uid Fl g Ar gid Fl G Ar gidlist
+.Op Fl l Ar linelen
+.Op Fl t Ar lameducktimeout
+.Op Fl x Ar unixsocket | Fl i Ar ipport
+.Sh DESCRIPTION
+.Nm
+is a reimplementation of the
+.Xr socklog 8
+program with a few more features.
+.Pp
+.Nm
+reads datagrams from the
+.Pa /dev/log
+Unix domain socket, or from a Unix domain or Internet domain socket of
+the user's choice, converts the encoded syslog facility and priority
+names to their human-readable equivalents, and prints the logs to its
+stdout.
+.Bl -bullet -width x
+.It
+.Nm
+binds to
+.Pa /dev/log .
+.It
+It drops its root privileges.
+.It
+For every datagram it reads, it turns its content into a log line:
+.Bl -bullet -width x
+.It
+Messages are truncated to 1024 characters.
+.It
+Trailing nulls or newlines are removed.
+.It
+Embedded nulls or newlines are converted to
+.Ql ~
+characters (tildes).
+.It
+A
+.Ql syslogcode
+at the beginning of the line is converted to
+.Ql facility.priority:\ \& .
+.El
+.It
+It prints the log line to its stdout, terminated by a newline.
+.It
+It exits 0 on a SIGTERM.
+.El
+.Ss Signals
+.Nm
+reacts to the following signals:
+.Bl -tag -width x
+.It SIGTERM
+Exit as soon as possible.
+.El
+.Ss Typical use
+.Nm
+can be paired with
+.Xr s6-log 8
+to implement
+.Ql syslogd
+functionality.
+.Nm
+acts as the
+.Em frontend :
+it reads the log lines and processes them, then pipes them
+to an
+.Xr s6-log 8
+instance that acts as the
+.Em backend ,
+i.e. sorts the log lines depending on regular expressions that
+typically involve the facility and priority names, then stores them
+into the filesystem.
+.Pp
+The pipe between
+.Nm
+and
+.Xr s6-log 8
+is typically a
+.Em logging pipe
+automatically provided by
+.Xr s6-svscan 8
+when the
+.Xr s6-log 8
+instance is declared as a logger service for the
+.Nm
+instance.
+.Pp
+The
+.Pa examples/
+subdirectory of the s6 package contains a turnkey
+.Ql syslogd
+service that implements this pattern.
+.Pp
+.Nm
+cannot be used under
+.Xr s6-ipcserver 8
+or another super-server.
+It does not implement the
+.Sq socklog ucspi functionality ,
+which is provided by the
+.Xr ucspilogd 8
+program instead.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl r
+Raw logging.
+.Ql <syslogcode>
+codes will not be converted to facility/priority names.
+.It Fl d Ar notif
+When ready (actually bound to its socket), write a newline to file
+descriptor
+.Ar notif
+then close it.
+This allows
+.Nm
+to use the
+.Xr s6-notifywhenup 7
+mechanism to notify readiness.
+.Ar notif
+cannot be less than 3.
+If this option is not given, no readiness notification is sent.
+.It Fl u Ar uid
+Drop user id to
+.Ar id .
+.It Fl g Ar gid
+Drop group id to
+.Ar gid .
+.It Fl G Ar gidlist
+Set supplementary group list to
+.Ar gidlist ,
+which must be given as a comma-separated list of numeric gids, without
+spaces.
+.It Fl U
+Set user id, group id and supplementary group list to the values of
+the
+.Ev UID ,
+.Ev GID
+and
+.Ev GIDLIST
+environment variables.
+If a
+.Fl u ,
+.Fl g
+or
+.Fl G
+option is given after
+.Fl U ,
+the command line value overrides the environment variable.
+.It Fl l Ar linelen
+Set the maximum datagram size to
+.Ar linelen .
+Default is 1024.
+It cannot be set to less than 80 or more than 1048576.
+If a datagram is bigger than
+.Ar linelen ,
+it will be truncated to
+.Ar linelen
+characters, and the logged line will end with a
+.Ql ...
+ellipsis to show the truncation.
+.It Fl t Ar lameducktimeout
+On receipt of a
+.Dv SIGTERM ,
+give
+.Nm
+a grace period of
+.Ar lameducktimeout
+milliseconds to flush any log lines that are still in its buffer.
+Default is 0, which means infinite: the program will only exit when
+its buffer is empty, and may wait forever.
+If
+.Ar lameducktimeout
+is nonzero and the timeout expires, the program will exit 99.
+.It Fl x Ar unixsocket
+Bind to a Unix domain socket at
+.Ar unixsocket .
+Default is
+.Pa /dev/log .
+.It Fl i Ar ipport
+Bind to a UDP socket.
+.Ar ipport
+is a combination of
+.Ar ip ,
+which must be an IPv4 or IPv6 address, and
+.Ar port ,
+which must be an integer.
+.Ar port
+may be omitted, in which case it defaults to 514.
+If
+.Ar port
+is given,
+.Ar ip
+and
+.Ar port
+must be separated by a
+.Ql _
+character (an underscore).
+If
+.Ar ip
+is IPv4, a
+.Ql \&:
+(colon) can be used instead of an underscore.
+When this option is used,
+.Nm
+will prepend every log line with
+.Sq Ar clientip Ns _  Ns Ar clientport:\ \& ,
+.Ar clientip
+and
+.Ar clientport
+being the IP address and port of the client that sent the log
+datagram.
+.El
+.Sh EXIT STATUS
+.Bl -tag -width x
+.It 0
+.Dv SIGTERM
+received, clean exit.
+.It 99
+.Dv SIGTERM
+received but the buffer could not be flushed in time, some logs may be
+lost.
+.It 100
+Wrong usage.
+.It 111
+System call failed.
+.El
+.Sh SEE ALSO
+.Xr s6-ipcserver 8 ,
+.Xr s6-log 8 ,
+.Xr s6-svscan 8 ,
+.Xr socklog 8 ,
+.Xr ucspilogd 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-socklog.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-softlimit.8 b/mdoc/man8/s6-softlimit.8
--- a/mdoc/man8/s6-softlimit.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-softlimit.8	2023-04-16 04:52:39.123496466 -0300
@@ -0,0 +1,96 @@
+.Dd September 29, 2021
+.Dt S6-SOFTLIMIT 8
+.Os
+.Sh NAME
+.Nm s6-softlimit
+.Nd change process limits, then execute into another program
+.Sh SYNOPSIS
+.Nm
+.Op Fl a Ar allmem
+.Op Fl c Ar core
+.Op Fl d Ar data
+.Op Fl f Ar fsize
+.Op Fl l Ar lock
+.Op Fl m Ar mem
+.Op Fl o Ar ofiles
+.Op Fl p Ar proc
+.Op Fl r Ar res
+.Op Fl s Ar stack
+.Op Fl t Ar cpusecs
+.Ar prog...
+.Sh DESCRIPTION
+.Nm
+parses its options and sets process (soft) resource limits accordingly.
+.Pp
+A value of
+.Ql =
+for any option means
+.Dq set that limit to the hard limit .
+.Pp
+Depending on your operating system, an option may do nothing.
+.Pp
+When
+.Nm
+has modified all the limits successfully, it executes into
+.Ar prog... .
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl a Ar allmem
+Limit the total available memory to
+.Ar allmem
+bytes.
+.It Fl c Ar core
+Limit the core file size to
+.Ar core
+bytes.
+.It Fl d Ar data
+Limit the available heap memory to
+.Ar data
+bytes.
+.It Fl f Ar fsize
+Limit the file size to
+.Ar fsize
+bytes.
+.It Fl l Ar lock
+Limit the available locked memory to
+.Ar lock
+bytes.
+.It Fl m Ar mem
+Limit all types of memory to
+.Ar mem
+bytes.
+.It Fl o Ar ofiles
+Limit the number of open fds to
+.Ar ofiles .
+.It Fl p Ar proc
+Limit the number of processes to
+.Ar proc
+(per user).
+.It Fl r Ar res
+Limit the available physical memory to
+.Ar res
+bytes.
+.It Fl s Ar stack
+Limit the available stack memory to
+.Ar stack
+bytes.
+.It Fl t Ar cpusecs
+Limit the available CPU time to
+.Ar cpusecs
+seconds.
+.El
+.Sh SEE ALSO
+.Xr s6-applyuidgid 8 ,
+.Xr s6-envdir 8 ,
+.Xr s6-envuidgid 8 ,
+.Xr s6-fghack 8 ,
+.Xr s6-setsid 8 ,
+.Xr s6-setuidgid 8 ,
+.Xr s6-tai64n 8 ,
+.Xr s6-tai64nlocal 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-softlimit.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-sudo.8 b/mdoc/man8/s6-sudo.8
--- a/mdoc/man8/s6-sudo.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-sudo.8	2023-04-16 04:52:39.123496466 -0300
@@ -0,0 +1,70 @@
+.Dd September 29, 2021
+.Dt S6-SUDO 8
+.Os
+.Sh NAME
+.Nm s6-sudo
+.Nd connect to a Unix domain socket and pass its standard file descriptors, command-line arguments and environment to a program running on the server side, potentially with different privileges
+.Sh SYNOPSIS
+.Nm
+.Op Fl q | Q | v
+.Op Fl p Ar bindpath
+.Op Fl l Ar localname
+.Op Fl e
+.Op Fl t Ar timeoutconn
+.Op Fl T Ar timeoutrun
+.Ar path
+.Op Ar args...
+.Sh DESCRIPTION
+.Nm
+executes into
+.Xr s6-ipcclient 8
+.Ar path
+.Xr s6-sudoc 8
+.Ar args... .
+It does nothing else: it is just a convenience program.
+The
+.Xr s6-ipcclient 8
+program connects to a Unix socket at
+.Ar path ,
+and the
+.Xr s6-sudoc 8
+program transmits the desired elements over the socket.
+.Pp
+It should be used to connect to an
+.Xr s6-local-service 7
+running the
+.Xr s6-sudod 8
+program, which will run a server program on the client's behalf.
+.Sh OPTIONS
+The
+.Fl q ,
+.Fl Q ,
+.Fl v ,
+.Fl p
+and
+.Fl l
+options are passed to
+.Xr s6-ipcclient 8 .
+.Pp
+The
+.Fl e ,
+.Fl t
+and
+.Fl T
+options are passed to
+.Xr s6-sudoc 8 .
+.Pp
+Command-line arguments, if any, are also passed to
+.Xr s6-sudoc 8 ,
+which will transmit them to
+.Xr s6-sudod 8
+over the socket.
+.Sh SEE ALSO
+.Xr s6-sudoc 8 ,
+.Xr s6-sudod 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-sudo.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-sudoc.8 b/mdoc/man8/s6-sudoc.8
--- a/mdoc/man8/s6-sudoc.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-sudoc.8	2023-04-16 04:52:39.123496466 -0300
@@ -0,0 +1,108 @@
+.Dd September 29, 2021
+.Dt S6-SUDOC 8
+.Os
+.Sh NAME
+.Nm s6-sudoc
+.Nd talk to a peer
+.Xr s6-sudod 8
+program over a Unix socket, passing it command-line arguments,
+environment variables and standard descriptors
+.Sh SYNOPSIS
+.Nm
+.Op Fl e
+.Op Fl t Ar timeoutconn
+.Op Fl T Ar timeoutrun
+.Op Ar args...
+.Sh DESCRIPTION
+.Nm
+transmits its standard input, standard output and standard error via
+fd-passing over a Unix socket that must be open on its descriptors 6
+and 7.
+It expects an
+.Xr s6-sudod 8
+process to be receiving them on the other side.
+.Pp
+It also transmits its command-line arguments
+.Ar args... ,
+and also its environment by default.
+Note that
+.Xr s6-sudod 8
+will not necessarily accept all the environment variables that
+.Nm
+tries to transmit.
+.Pp
+.Nm
+waits for the server program run by
+.Xr s6-sudod 8
+to finish.
+It exits the same exit code as the server program.
+If the server program is killed by a signal,
+.Nm
+kills itself with the same signal.
+.Pp
+If
+.Nm
+is killed, or exits after
+.Ar timeoutrun
+milliseconds, while the server program is still running,
+.Xr s6-sudod 8
+will send a SIGTERM and a SIGCONT to the server program - but this
+does not guarantee that it will die.
+If the server program keeps running, it might still read from the file
+that was
+.Nm Ap
+s stdin, or write to the files that were
+.Nm Ap
+s stdout or stderr.
+.Sy This is a potential security risk.
+Administrators should audit their server programs to make sure this
+does not happen.
+.Pp
+More generally, anything using signals or terminals will not be
+handled transparently by the
+.Nm
++
+.Xr s6-sudod 8
+mechanism.
+The mechanism was designed to allow programs to gain privileges in
+specific situations: short-lived, simple, noninteractive processes.
+It was not designed to emulate the full suid functionality and will
+not go out of its way to do so.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl e
+Do not attempt to transmit any environment variables to
+.Xr s6-sudod 8 .
+.It Fl t Ar timeoutconn
+If
+.Xr s6-sudod 8
+has not managed to process the given information and start the server
+program after
+.Ar timeoutconn
+milliseconds, give up.
+By default,
+.Ar timeoutconn
+is 0, meaning infinite.
+Note that there is no reason to set up a nonzero
+.Ar timeoutconn
+with a large value:
+.Xr s6-sudod 8
+is not supposed to block.
+The option is only there to protect against ill-written services.
+.It Fl T Ar timeoutrun
+If the server program has not exited after
+.Ar timeoutrun
+milliseconds, give up.
+By default,
+.Ar timeoutrun
+is 0, meaning infinite.
+.El
+.Sh SEE ALSO
+.Xr s6-sudo 8 ,
+.Xr s6-sudod 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-sudoc.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-sudod.8 b/mdoc/man8/s6-sudod.8
--- a/mdoc/man8/s6-sudod.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-sudod.8	2023-04-16 04:52:39.123496466 -0300
@@ -0,0 +1,333 @@
+.Dd September 29, 2021
+.Dt S6-SUDOD 8
+.Os
+.Sh NAME
+.Nm s6-sudod
+.Nd receive command-line arguments, environment variables and standard descriptors from a peer
+.Xr s6-sudoc 8
+program over a Unix socket, then fork another program
+.Sh SYNOPSIS
+.Nm
+.Op Fl 0
+.Op Fl 1
+.Op Fl 2
+.Op Fl d
+.Op Fl t Ar timeout
+.Op Ar sargv...
+.Sh DESCRIPTION
+.Nm
+gets 3 file descriptors via fd-passing over a Unix socket that must be
+open on its descriptors 0 and 1.
+(The received descriptors will be the stdin, stdout and stderr of the
+server program.)
+It expects an
+.Xr s6-sudoc 8
+process to be sending them on the client side.
+.Pp
+It also receives a list of command-line arguments
+.Ar cargv... ,
+and an environment
+.Ar clientenv .
+.Nm
+forks and executes
+.Ar sargv... cargv... .
+The client command line is appended to the server command line.
+.Nm
+waits for its child to exit and transmits its exit code to the peer
+.Xr s6-sudoc 8
+process.
+It then exits 0.
+.Pp
+If the
+.Fl d
+option to
+.Nm
+has not been given, and
+.Xr s6-sudoc 8
+is killed (or exits after
+.Ar timeoutrun
+milliseconds) while the server program is still running,
+.Nm
+will send a SIGTERM and a SIGCONT to its child, then exit 1.
+However, sending a SIGTERM to the child does not guarantee that it
+will die; and if it keeps running, it might still read from the file
+that was
+.Xr s6-sudoc 8 Ap
+s stdin, or write to the files that were
+.Xr s6-sudoc 8 Ap
+s stdout or stderr.
+.Sy This is a potential security risk.
+Administrators should audit their server programs to make sure this
+does not happen.
+.Pp
+More generally, anything using signals or terminals will not be
+handled transparently by the
+.Xr s6-sudoc 8
++
+.Nm
+mechanism.
+The mechanism was designed to allow programs to gain privileges in
+specific situations: short-lived, simple, noninteractive processes.
+It was not designed to emulate the full suid functionality and will
+not go out of its way to do so.
+.Pp
+Administrators should also make sure that it's not a problem if
+.Nm Ap
+s child keeps running after the
+.Xr s6-sudoc 8
+client exits, if they have given the
+.Fl d
+option to
+.Nm .
+In particular, they should study what happens if another connection to
+the same service occurs while an instance is still running.
+.Pp
+.Ar sargv
+may be empty.
+In that case, the client is in complete control of the command line
+executed as
+.Va serveruser .
+This setup is permitted by
+.Nm ,
+but it is very dangerous, and extreme attention should be paid to the
+construction of the
+.Xr s6-ipcserver-access 8
+rules.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl 0
+Do not inherit stdin from
+.Xr s6-sudoc 8 .
+The child will be run with its stdin pointing to
+.Pa /dev/null
+instead.
+.It Fl 1
+Do not inherit stdout from
+.Xr s6-sudoc 8 .
+The child will be run with its stdout pointing to
+.Pa /dev/null
+instead.
+.It Fl 2
+Do not inherit stderr from
+.Xr s6-sudoc 8 .
+The child will be run with its stderr being a copy of
+.Nm Ap
+s stderr instead.
+(This is useful to still log the child's error messages without
+sending them to the client.)
+.It Fl d
+Detach.
+The child will keep running until it naturally exits, even if the
+client disconnects.
+Setting this option also enforces
+.Fl 0 ,
+.Fl 1
+and
+.Fl 2 .
+Bear in mind that this option relinquishes a lot of control over the
+child, and administrators should make sure it is appropriately
+short-lived.
+.It Fl t Ar timeout
+If
+.Nm
+has not received all the needed data from the client after
+.Ar timeout
+milliseconds, it will exit without spawning a child.
+By default,
+.Ar timeout
+is 0, meaning infinite.
+This mechanism exists to protect the server from malicious or buggy
+clients that would uselessly consume resources.
+.El
+.Sh ENVIRONMENT
+.Nm
+transmits its own environment to its child, plus the environment sent
+by
+.Xr s6-sudoc 8 ,
+filtered in the following manner: for every variable sent by
+.Xr s6-sudoc 8 ,
+if the variable is
+.Sy present but empty
+in
+.Nm Ap
+s environment, then its value is overridden by the value given by
+.Xr s6-sudoc 8 .
+A variable that is already nonempty, or that doesn't exist, in
+.Nm Ap
+s environment, will not be transmitted to the child.
+In other words:
+.Bl -bullet -width x
+.It
+If there's no variable
+.Va X
+in
+.Nm Ap
+s environment, the child will have no variable
+.Va X
+defined.
+.It
+If there's a non-empty variable
+.Va X
+in
+.Nm Ap
+s environment, the child will inherit that variable, with its value,
+from
+.Nm .
+.It
+If there's an empty variable
+.Va X
+in
+.Nm Ap
+s environment, and
+.Xr s6-sudoc 8
+transmits variable
+.Va X ,
+then the child will inherit that variable with the value from
+.Xr s6-sudoc 8 .
+(If
+.Xr s6-sudoc 8
+does not transmit
+.Va X ,
+the variable will be present, but empty, in the child's environment.)
+.El
+.Sh EXAMPLES
+The typical use of
+.Nm
+is in a local service with a
+.Xr s6-ipcserver 8
+process listening on a Unix socket, an
+.Xr s6-ipcserver-access 8
+process performing client authentication and access control, and
+possibly an
+.Xr s6-envdir 8
+process setting up the environment variables that will be accepted by
+.Nm .
+The following script, meant to be a run script in a service directory,
+will set up a privileged program:
+.Bd -literal -offset indent
+#!/command/execlineb -P
+fdmove -c 2 1
+fdmove 1 3
+s6-envuidgid serveruser
+s6-ipcserver -U -1 -- serversocket
+s6-ipcserver-access -v2 -l0 -i rules --
+exec -c
+s6-envdir env
+s6-sudod
+sargv
+.Ed
+.Bl -bullet -width x
+.It
+.Xr execlineb 1
+executes the script.
+.It
+.Xr fdmove 1
+makes sure the script's error messages are sent to the service's
+logger.
+.It
+.Xr fdmove 1
+redirects the script's stdout to file descriptor 3. This is useful if
+the service directory contains a
+.Pa notification-fd
+file containing 3, so the daemon can perform readiness notification
+.Po
+cf.
+.Xr s6-notifywhenup 7
+.Pc
+by writing a newline to its stdout.
+(The
+.Fl 1
+option to
+.Xr s6-ipcserver 8
+tells it to do this.)
+.It
+.Xr s6-envuidgid 8
+sets the
+.Ev UID ,
+.Ev GID
+and
+.Ev GIDLIST
+environment variables for
+.Xr s6-ipcserver 8
+to interpret.
+.It
+.Xr s6-ipcserver 8
+binds to
+.Va serversocket ,
+drops its privileges to those of
+.Va serveruser ,
+and announces its readiness.
+Then, for every client connecting to
+.Va serversocket :
+.Bl -bullet -width x
+.It
+.Xr s6-ipcserver-access 8
+checks the client's credentials according to the rules in directory
+.Va rules .
+.It
+.Ql exec -c
+.Po
+cf.\&
+.Xr exec 1
+.Pc
+clears the environment.
+.It
+.Xr s6-envdir 8
+sets environment variables according to the directory
+.Va env .
+You can make sure that a variable
+.Va VAR
+will be present but empty by performing
+.Ql echo > env/ Ns Va VAR .
+(A single newline is interpreted by
+.Xr s6-envdir 8
+as an empty variable; whereas if
+.Pa env/VAR
+is totally empty, then the
+.Va VAR
+variable will be removed from the environment.)
+.It
+.Nm
+reads a command line
+.Ar cargv ,
+a client environment and file descriptors over the socket.
+.It
+.Nm
+spawns
+.Ar sargv cargv .
+.El
+.Pp
+(Actually,
+.Xr s6-ipcserver 8
+does not do this itself: it executes into other programs that each do
+one of the tasks.
+But for our example, it does not matter.)
+.El
+.Pp
+This means that user
+.Va clientuser
+running
+.Ql s6-sudo Va serversocket Ar cargv
+will be able, if authorized by the configuration in
+.Va rules ,
+to run
+.Ar sargv cargv
+as user
+.Va serveruser ,
+with stdin, stdout, stderr and the environment variables properly
+listed in
+.Va env
+transmitted to
+.Ar sargv .
+.Sh SEE ALSO
+.Xr exec 1 ,
+.Xr execlineb 1 ,
+.Xr fdmove 1 ,
+.Xr s6-sudo 8 ,
+.Xr s6-sudoc 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-sudod.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-supervise.8 b/mdoc/man8/s6-supervise.8
--- a/mdoc/man8/s6-supervise.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-supervise.8	2023-04-16 04:52:39.123496466 -0300
@@ -0,0 +1,509 @@
+.Dd February 19, 2023
+.Dt S6-SUPERVISE 8
+.Os
+.Sh NAME
+.Nm s6-supervise
+.Nd monitor a long-lived process
+.Po
+or
+.Em service
+.Pc ,
+making sure it stays alive, sending notifications to registered
+processes when it dies, and providing an interface to control its
+state
+.Sh SYNOPSIS
+.Nm
+.Ar servicedir
+.Sh DESCRIPTION
+.Nm
+is designed to be the last non-leaf branch of a
+.Em supervision tree ,
+the supervised process being a leaf.
+.Nm Ap
+s behaviour is approximately the following:
+.Bl -bullet -width x
+.It
+.Nm
+changes its current directory to
+.Ar servicedir .
+.It
+It exits 100 if another
+.Nm
+process is already monitoring this service.
+.It
+It forks and executes the
+.Pa ./run
+file in the service directory.
+.It
+.Pa ./run
+should be a long-lived process: it can chain load (i.e. exec into
+other binaries), but should not die.
+It's the daemon that
+.Nm
+monitors and manages.
+.It
+When
+.Pa ./run
+dies,
+.Nm
+spawns
+.Pa ./finish ,
+if it exists.
+This script should be short-lived: it's meant to clean up application
+state, if necessary, that has not been cleaned up by
+.Pa ./run
+itself before dying.
+.It
+When
+.Pa ./finish
+dies,
+.Nm
+spawns
+.Pa ./run
+again.
+.It
+.Nm
+operation can be controlled by the
+.Xr s6-svc 8
+program.
+It can be sent commands like
+.Dq restart the service ,
+.Dq bring the service down ,
+etc.
+.It
+.Nm
+normally runs forever.
+If told to exit by
+.Xr s6-svc 8 ,
+it waits for the service to go down one last time, then exits 0.
+.El
+.Pp
+For a precise description of
+.Nm Ap
+s behaviour, check the
+.Sx Detailed operation
+section below, as well as the
+.Xr s6-service-directory 7
+page:
+.Nm
+operation can be extensively configured by the presence of certain
+files in the service directory.
+.Ss Readiness notification support
+If the
+.Xr s6-service-directory 7
+contains a valid
+.Pa notification-fd
+file when the service is started, or restarted,
+.Nm
+creates and listens to an additional pipe from the service for
+readiness notification; refer to
+.Xr s6-notifywhenup 7 .
+When the notification occurs,
+.Nm
+updates the
+.Pa ./supervise/status
+file accordingly, then sends a
+.Sq U
+event to
+.Pa ./event .
+.Pp
+If the service is logged, i.e. if the service directory has a
+.Pa log
+subdirectory that is also a service directory, and the
+.Nm
+process has been launched by that is also
+.Xr s6-svscan 8 ,
+then by default the service's stdout goes into the logging pipe.
+If you set
+.Pa notification-fd
+to 1, the logging pipe will be overwritten by the notification pipe,
+which is probably not what you want.
+Instead, if your daemon writes a notification message to its stdout,
+you should set
+.Pa notification-fd
+to (for instance) 3, and redirect outputs in your run script.
+For instance, to redirect stderr to the logger and stdout to a
+.Pa notification-fd
+set to 3, you would start your daemon as
+.Ql fdmove -c 2 1 fdmove 1 3 prog...
+(in execline), or
+.Ql exec 2>&1 1>&3 3<&- prog...
+(in shell).
+.Ss Signals
+.Nm
+reacts to the following signals:
+.Bl -tag -width x
+.It Dv SIGTERM
+Bring down the service and exit, as if a
+.Ql s6-svc -xd
+command had been received.
+.It Dv SIGHUP
+Close its own stdin and stdout, and exit as soon as the service stops,
+as if an
+.Ql s6-svc -x
+command had been received.
+.It Dv SIGQUIT
+Exit immediately without touching the service in any way.
+.It Dv SIGINT
+Send a
+.Dv SIGINT
+to the process group of the service, then exit immediately. (The point
+here is to correctly forward
+.Dv SIGINT
+in the case where
+.Nm
+is running in a terminal and the user sent
+.Ql ^C
+to interrupt it.)
+.El
+.Ss Detailed operation
+.Bl -bullet -width x
+.It
+.Nm
+switches to the
+.Ar servicedir
+.Xr s6-service-directory 7 .
+.It
+It creates a
+.Pa supervise/
+subdirectory (if it doesn't exist yet) to store its internal data.
+.It
+It exits 100 if another
+.Nm
+process is already monitoring this service.
+.It
+If the
+.Pa ./event
+.Xr s6-fifodir 7
+does not exist,
+.Nm
+creates it and allows subscriptions to it from processes having the
+same effective group id as the
+.Nm
+process.
+If it already exists, it uses it as is, without modifying the
+subscription rights.
+.It
+It sends an
+.Sq s
+event to
+.Pa ./event .
+.Po
+Refer to
+.Xr s6-ftrigw 7
+.Pc
+.It
+If the default service state is up (i.e. there is no
+.Pa ./down
+file),
+.Nm
+spawns
+.Pa ./run .
+One argument is given to the
+.Pa ./run
+program:
+.Ar servicedir ,
+the name of the directory
+.Nm
+is being run on.
+It is given exactly as given to s6-supervise, without
+recanonicalization.
+In particular, if
+.Nm
+is being managed by
+.Xr s6-svscan 8 ,
+.Ar servicedir
+is always of the form
+.Pa "" Ns Ar foo
+or
+.Pa "" Ns Ar foo Ns /log ,
+and
+.Ar foo
+contains no slashes.
+.It
+.Nm
+sends a
+.Sq u
+event to
+.Pa ./event
+whenever it successfully spawns
+.Pa ./run .
+.It
+If there is a
+.Pa ./notification-fd
+file in the service directory and, at some point after the service has
+been spawned,
+.Nm
+is told that the service is ready, it sends a
+.Sq U
+event to
+.Pa ./event .
+There are several ways to tell
+.Nm
+that the service is ready:
+.Bl -bullet -width x
+.It
+the daemon may do so itself; refer to
+.Xr s6-notifywhenup 7 .
+.It
+the
+.Pa run
+script may have forked a
+.Xr s6-notifyoncheck 8
+process that polls the service for readiness.
+.El
+.It
+When
+.Pa ./run
+dies,
+.Nm
+sends a
+.Sq d
+event to
+.Pa ./event .
+It then spawns
+.Pa ./finish
+if it exists.
+.Pa ./finish
+will have
+.Pa ./run Ap
+s exit code as first argument, or 256 if
+.Pa ./run
+was signaled; it will have the number of the signal that killed
+.Pa ./run
+as second argument, or an undefined number if
+.Pa ./run
+was not signaled; and it will have
+.Ar servicedir
+as third argument.
+.It
+By default,
+.Pa ./finish
+must exit in less than 5 seconds.
+If it takes more than that,
+.Nm
+kills it with a SIGKILL.
+This can be configured via the
+.Pa ./timeout-finish
+file, see the description in
+.Xr s6-service-directory 7 .
+.It
+When
+.Pa ./finish
+dies (or is killed),
+.Nm
+sends a
+.Sq D
+event to
+.Pa ./event .
+Then it restarts
+.Pa ./run
+unless it has been told not to.
+.It
+If
+.Pa ./finish
+exits 125, then
+.Nm
+sends a
+.Sq O
+event to
+.Pa ./event
+before the
+.Sq D ,
+and it
+.Sy does not restart the service ,
+as if
+.Ql s6-svc -O
+had been called.
+This can be used to signify permanent failure to start the service.
+.It
+There is a minimum 1-second delay between two
+.Pa ./run
+spawns, to avoid busylooping if
+.Pa ./run
+exits too quickly.
+If the service has been
+.Em ready
+for more than one second, it will restart immediately, but if it is not
+.Em ready
+when it dies,
+.Nm
+will always pause for 1 second before spawning it again.
+.It
+When killed or asked to exit, it waits for the service to go down one
+last time, then sends a
+.Sq x
+event to
+.Pa ./event
+before exiting 0.
+.El
+.Pp
+Make sure to also check the
+.Xr s6-service-directory 7
+documentation page, for the full list of files that can be present in
+a service directory and impact
+.Nm Ap
+s behaviour in any way.
+.Pp
+.Nm
+is a long-lived process.
+It normally runs forever, from the system's boot scripts, until
+shutdown time; it should not be killed or told to exit.
+If you have no use for a service, just turn it off; the
+.Nm
+process does not hurt.
+.Pp
+Even in boot scripts,
+.Nm
+should normally not be run directly.
+It's better to have a collection of
+.Xr s6-service-directory 7 Ns s
+in a single
+.Xr s6-scan-directory 7 ,
+and just run
+.Xr s6-svscan 8
+on that scan directory.
+.Xr s6-svscan 8
+will spawn the necessary
+.Nm
+processes, and will also take care of logged services.
+.Pp
+.Nm
+always spawns its child in a new session, as a session leader.
+The goal is to protect the supervision tree from misbehaved services
+that would send signals to their whole process group.
+Nevertheless,
+.Nm Ap
+s handling of
+.Dv SIGINT
+ensures that its service is killed if you happen to run it in a
+terminal and send it a
+.Ql ^C .
+.Pp
+You can use
+.Xr s6-svc 8
+to send commands to the
+.Nm
+process; mostly to change the service state and send signals to the
+monitored process.
+.Pp
+You can use
+.Xr s6-svok 8
+to check whether
+.Nm
+is successfully running.
+.Pp
+You can use
+.Xr s6-svstat 8
+to check the status of a service.
+.Pp
+.Nm
+maintains internal information inside the
+.Pa ./supervise
+subdirectory of
+.Ar servicedir .
+.Ar servicedir
+itself can be read-only, but both
+.Sm off
+.Ar servicedir
+/supervise
+.Sm on
+and
+.Sm off
+.Ar servicedir
+/event
+.Sm on
+need to be read-write.
+.Pp
+If
+.Ar servicedir
+isn't writable by
+.Nm ,
+for any reason, then the
+.Xr s6-svc 8
+.Fl D
+and
+.Fl U
+commands will not work properly since
+.Nm
+will be unable to create or delete a
+.Pa "" Ns Ar servicedir Ns /down
+file; in this case
+.Nm
+will print a warning on stderr, and perform the equivalent of
+.Fl d
+or
+.Fl u
+instead
+\(em
+it will just be unable to change the permanent service configuration.
+.Sh OPTIONS
+.Nm
+does not support options, because it is normally not run manually via
+a command line; it is usually launched by its own supervisor,
+.Xr s6-svscan 8 .
+The way to tune
+.Nm Ap
+s behaviour is via files in the
+.Xr s6-service-directory 7 .
+.Sh IMPLEMENTATION NOTES
+.Nm
+tries its best to stay alive and running despite possible system call
+failures.
+It will write to its standard error everytime it encounters a
+problem.
+However, unlike
+.Xr s6-svscan 8 ,
+it will not go out of its way to stay alive; if it encounters an
+unsolvable situation, it will just die.
+.Pp
+Unlike other
+.Dq supervise
+implementations,
+.Nm
+is a fully asynchronous state machine.
+That means that it can read and process commands at any time, even
+when the machine is in trouble (full process table, for instance).
+.Pp
+.Nm
+.Em does not use
+.Xr malloc 3 .
+That means it will
+.Em never leak memory .
+However,
+.Nm s6-supervise
+uses
+.Xr opendir 3 ,
+and most
+.Xr opendir 3
+implementations internally use heap memory - so unfortunately, it's
+impossible to guarantee that
+.Nm
+does not use heap memory at all.
+.Pp
+.Nm
+has been carefully designed so every instance maintains as little data
+as possible, so it uses a very small amount of non-sharable memory.
+It is not a problem to have several dozens of
+.Nm
+processes, even on constrained systems: resource consumption will be
+negligible.
+.Sh SEE ALSO
+.Xr s6-notifyoncheck 8 ,
+.Xr s6-permafailon 8 ,
+.Xr s6-svc 8 ,
+.Xr s6-svdt 8 ,
+.Xr s6-svdt-clear 8 ,
+.Xr s6-svlisten 8 ,
+.Xr s6-svlisten1 8 ,
+.Xr s6-svok 8 ,
+.Xr s6-svscan 8 ,
+.Xr s6-svscanctl 8 ,
+.Xr s6-svstat 8 ,
+.Xr s6-svwait 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-supervise.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-svc.8 b/mdoc/man8/s6-svc.8
--- a/mdoc/man8/s6-svc.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-svc.8	2023-04-16 04:52:39.124496466 -0300
@@ -0,0 +1,343 @@
+.Dd February 19, 2023
+.Dt S6-SVC 8
+.Os
+.Sh NAME
+.Nm s6-svc
+.Nd send commands to a running
+.Xr s6-supervise 8
+process
+.Sh SYNOPSIS
+.Nm
+.Op Fl wu | wU | wd | wD | wr | wR
+.Op Fl T Ar timeout
+.Op Fl abqhkti12pcyroduDUxO
+.Ar servicedir
+.Sh DESCRIPTION
+.Nm
+is used to control a supervised process; among other benefits, it
+allows an administrator to send signals to daemons without knowing
+their PIDs, and without using horrible hacks such as .pid files.
+.Pp
+.Nm
+sends the given series of commands to the
+.Xr s6-supervise 8
+process monitoring the
+.Ar servicedir
+directory, then exits 0.
+It exits 111 if it cannot send a command, or
+100 if no
+.Xr s6-supervise 8
+process is running on
+.Ar servicedir .
+.Ss Notes
+The
+.Fl t
+and
+.Fl r
+options make
+.Xr s6-supervise 8
+send a signal to the service if it is up; but if the service is
+currently down, they do nothing, and in particular they do not
+instruct
+.Xr s6-supervise 8
+to bring the service up.
+Consequently,
+.Ql s6-svc -rwr Ar servicedir
+may wait forever for the service to be up, if it is currently wanted
+down.
+To avoid that, make sure your service is wanted up by using
+.Ql s6-svc -ruwr Ar servicedir
+instead.
+.Pp
+The
+.Ql U
+and
+.Ql D
+letters, which convey the same idea as
+.Ql u
+and
+.Ql d
+.Po
+.Em up
+and
+.Em down
+.Pc
+but with added emphasis, do not have the same meaning in the
+.Fl U
+/
+.Fl D
+and
+.Fl wU
+/
+.Fl wD
+options.
+In the
+.Fl U
+/
+.Fl D
+case, they mean
+.Do
+change the external service configuration to match what the supervisor
+has been instructed that the starting state of the service should be
+.Dc .
+In the
+.Fl wU
+/
+.Fl wD
+case, they mean
+.Do
+wait until the service has reached the wanted state
+.Em and also
+is ready
+.Dc
+.Po
+or
+.Do
+ready to be started again
+.Dc
+for
+.Fl wD
+.Pc .
+The thing to remember is
+.Do
+it's up/down, with something more
+.Dc ,
+but the
+.Dq something
+isn't the same.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl a
+Send a SIGALRM to the supervised process.
+.It Fl b
+Send a SIGABRT to the supervised process.
+.It Fl q
+Send a SIGQUIT to the supervised process.
+.It Fl h
+Send a SIGHUP to the supervised process.
+.It Fl k
+Send a SIGKILL to the supervised process.
+.It Fl t
+Send a SIGTERM to the supervised process.
+.It Fl i
+Send a SIGINT to the supervised process.
+.It Fl 1
+Send a SIGUSR1 to the supervised process.
+.It Fl 2
+Send a SIGUSR2 to the supervised process.
+.It Fl p
+Send a SIGSTOP to the supervised process.
+.It Fl c
+Send a SIGCONT to the supervised process.
+.It Fl y
+Send a SIGWINCH to the supervised process.
+.It Fl o
+Once.
+Equivalent to
+.Ql -uO .
+.It Fl d
+Down.
+If the supervised process is up, send it a SIGTERM (by default) then a
+SIGCONT (to make sure even stopped processes receive the signal aimed
+to kill them) and do not restart it.
+The SIGTERM default can be changed by editing the
+.Pa ./down-signal
+file in the
+.Xr s6-service-directory 7 .
+.It Fl D
+Down, and create a
+.Pa ./down
+file so the service does not restart automatically if the supervisor
+dies.
+This option is mostly used by automated systems working on top of s6;
+as a human user, you probably don't need it.
+.It Fl u
+Up.
+If the supervised process is down, start it.
+Automatically restart it when it dies.
+.It Fl U
+Up, and remove any
+.Pa ./down
+file that may exist, in order to make sure the service is
+automatically restarted even if the supervisor dies.
+This option is mostly used by automated systems working on top of s6;
+as a human user, you probably don't need it.
+.It Fl x
+Exit.
+When the service is asked to be down and the supervised process dies,
+.Xr s6-supervise 8
+will exit too.
+This command should normally never be used on a working system.
+Note that if this command is sent and a
+.Pa ./finish
+script exists for the service, the last
+.Pa ./finish
+invocation before
+.Xr s6-supervise 8
+exits will run with its stdin and stdout redirected to
+.Pa /dev/null .
+.It Fl O
+Mark the service to run once at most.
+iow: do not restart the supervised process when it dies.
+If it is down when the command is received, do not even start it.
+.It Fl Q
+Once at most, and create a
+.Pa ./down
+file.
+Like
+.Fl D ,
+but do not terminate the service if it is currently running.
+.It Fl r
+If the service is up, restart it, by sending it a signal to kill it
+and letting
+.Xr s6-supervise 8
+start it again.
+By default, the signal is a SIGTERM; this can be configured via the
+.Pa ./down-signal
+file in the
+.Xr s6-service-directory 7 .
+.It Fl T Ar timeout
+If the
+.Fl wstate
+option has been given,
+.Fl T
+specifies a timeout (in milliseconds) after which
+.Nm
+will exit 1 with an error message if the service still hasn't reached
+the desired state.
+By default, the timeout is 0, which means that
+.Nm
+will block indefinitely.
+.It Fl wd
+.Nm
+will not exit until the service is down, i.e. until the
+.Pa run
+process has died.
+.It Fl wD
+.Nm
+will not exit until the service is down and ready to be brought up,
+i.e. a possible
+.Pa finish
+script has exited.
+.It Fl wu
+.Nm
+will not exit until the service is up, i.e. there is a process running the
+.Pa run
+executable.
+.It Fl wU
+.Nm
+will not exit until the service is up
+.Em and
+ready
+.Po
+cf.
+.Xr s6-notifywhenup 7
+.Pc
+as notified by the daemon itself.
+If the
+.Xr s6-service-directory 7
+does not contain a
+.Pa notification-fd
+file to tell
+.Xr s6-supervise 8
+to accept readiness notification,
+.Nm
+will print a warning and act as if the
+.Fl wu
+option had been given instead.
+.It Fl wr
+.Nm
+will not exit until the service has been started or restarted.
+.It Fl wR
+.Nm
+will not exit until the service has been started or restarted and has
+notified readiness.
+.El
+.Sh IMPLEMENTATION NOTES
+.Nm
+writes control commands into the
+.Pa servicedir/supervise/control
+FIFO.
+An
+.Xr s6-supervise 8
+process running on
+.Pa servicedir
+will be listening to this FIFO, and will read and interpret those
+commands.
+.Pp
+When invoked with one of the
+.Fl w
+options,
+.Nm
+executes into
+.Xr s6-svlisten1 8 ,
+which will listen to service state changes and spawn another
+.Nm
+instance (without the
+.Fl w
+option) that will send the commands to the service.
+Any error message written during the waiting period will mention it is
+being written by
+.Xr s6-svlisten1 8 ;
+this is normal.
+.Sh EXAMPLES
+.Dl s6-svc -h /service/httpd
+.Pp
+Send a SIGHUP to the process represented by the
+.Pa /service/httpd
+service directory.
+Traditionally, this makes web servers reload their configuration file.
+.Pp
+.Dl s6-svc -r /service/sshd
+.Pp
+Kill (and automatically restart, if the wanted state of the service is
+up) the process represented by the
+.Pa /service/sshd
+service directory - typically the sshd server.
+.Pp
+.Dl s6-svc -wD -d /service/ftpd
+.Pp
+Take down the ftpd server and block until the process is down and the
+finish script has completed.
+.Pp
+.Dl s6-svc -wU -T 5000 -u /service/ftpd
+.Pp
+Bring up the ftpd server and block until it has sent notification that
+it is ready.
+Exit 1 if it is still not ready after 5 seconds.
+.Pp
+.Dl s6-svc -wR -t /service/ftpd
+.Pp
+Send a SIGTERM to the ftpd server; wait for
+.Xr s6-supervise 8
+to restart it, and block until it has notified that it is ready to
+serve again.
+Refer to the
+.Sx Notes
+subsection for a caveat.
+.Pp
+.Dl s6-svc -a /service/httpd/log
+.Pp
+Send a SIGALRM to the logger process for the httpd server.
+If this logger process is
+.Xr s6-log 8 ,
+this triggers a log rotation.
+.Sh SEE ALSO
+.Xr s6-notifyoncheck 8 ,
+.Xr s6-permafailon 8 ,
+.Xr s6-supervise 8 ,
+.Xr s6-svdt 8 ,
+.Xr s6-svdt-clear 8 ,
+.Xr s6-svlisten 8 ,
+.Xr s6-svlisten1 8 ,
+.Xr s6-svok 8 ,
+.Xr s6-svscan 8 ,
+.Xr s6-svscanctl 8 ,
+.Xr s6-svstat 8 ,
+.Xr s6-svwait 8 ,
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-svc.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-svdt-clear.8 b/mdoc/man8/s6-svdt-clear.8
--- a/mdoc/man8/s6-svdt-clear.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-svdt-clear.8	2023-04-16 04:52:39.124496466 -0300
@@ -0,0 +1,59 @@
+.Dd September 29, 2021
+.Dt S6-SVDT-CLEAR 8
+.Os
+.Sh NAME
+.Nm s6-svdt-clear
+.Nd clear the recorded death tally of a service
+.Sh SYNOPSIS
+.Nm
+.Ar servicedir
+.Sh DESCRIPTION
+.Nm
+clears the recorded death tally of the service being currently
+supervised at the
+.Ar servicedir
+.Xr s6-service-directory 7 .
+.Pp
+Use of
+.Nm
+impacts the listings obtained by the
+.Xr s6-svdt 8
+command.
+.Pp
+It also impacts the behaviour of the
+.Xr s6-permafailon 8
+command.
+This is the main reason to use
+.Nm :
+once a service has failed permanently due to an excessive number of
+deaths in a given time, it can be useful to erase that record of
+deaths before starting the service again, in order to avoid
+permanently failing again too fast.
+.Sh EXIT STATUS
+.Bl -tag -width x
+.It 0
+Success.
+.It 100
+Wrong usage.
+.It 111
+System call failed.
+.El
+.Sh SEE ALSO
+.Xr s6-notifyoncheck 8 ,
+.Xr s6-permafailon 8 ,
+.Xr s6-supervise 8 ,
+.Xr s6-svc 8 ,
+.Xr s6-svdt 8 ,
+.Xr s6-svlisten 8 ,
+.Xr s6-svlisten1 8 ,
+.Xr s6-svok 8 ,
+.Xr s6-svscan 8 ,
+.Xr s6-svscanctl 8 ,
+.Xr s6-svstat 8 ,
+.Xr s6-svwait 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-svdt-clear.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-svdt.8 b/mdoc/man8/s6-svdt.8
--- a/mdoc/man8/s6-svdt.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-svdt.8	2023-04-16 04:52:39.124496466 -0300
@@ -0,0 +1,93 @@
+.Dd September 29, 2021
+.Dt S6-SVDT 8
+.Os
+.Sh NAME
+.Nm s6-svdt
+.Nd print the recorded death tally of a service, i.e. a list of the times the process died, with the cause of death
+.Sh SYNOPSIS
+.Nm
+.Op Fl S | s
+.Op Fl n Ar maxlines
+.Ar servicedir
+.Sh DESCRIPTION
+.Nm
+prints the contents of the recorded death tally of the service being
+currently supervised at the
+.Ar servicedir
+.Xr s6-service-directory 7 ,
+then exits 0.
+.Pp
+For each recorded death,
+.Nm
+prints one line.
+This line contains the following fields, separated with spaces:
+.Bl -bullet -width x
+.It
+A TAI64N[1] timestamp.
+.It
+The word
+.Sq signal
+if the death was caused by a signal, or the word
+.Sq exitcode
+if the death was a normal exit.
+.It
+The name of the signal that caused the death, or the exit code of the
+process.
+.El
+.Pp
+To obtain human-readable local time or GMT time instead of TAI64N
+timestamps, simply pipe
+.Nm Ap
+s output into
+.Xr s6-tai64nlocal 8 .
+.Pp
+Process deaths are recorded up to a default maximum of 100.
+This default can be modified via the
+.Pa max-death-tally
+file in the
+.Xr s6-service-directory 7 .
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl S
+Print signal names.
+This is the default.
+.It Fl s
+Print signal numbers.
+The numerical value of the signal will be printed instead of the
+signal name.
+.It Fl n Ar maxlines
+Limit the output to at most the latest
+.Ar maxlines
+deaths.
+.El
+.Sh EXIT STATUS
+.Bl -tag -width x
+.It 0
+Success.
+.It 100
+Wrong usage.
+.It 111
+System call failed.
+.El
+.Sh SEE ALSO
+.Xr s6-notifyoncheck 8 ,
+.Xr s6-permafailon 8 ,
+.Xr s6-supervise 8 ,
+.Xr s6-svc 8 ,
+.Xr s6-svdt-clear 8 ,
+.Xr s6-svlisten 8 ,
+.Xr s6-svlisten1 8 ,
+.Xr s6-svok 8 ,
+.Xr s6-svscan 8 ,
+.Xr s6-svscanctl 8 ,
+.Xr s6-svstat 8 ,
+.Xr s6-svwait 8
+.Pp
+[1]
+.Lk https://cr.yp.to/daemontools/tai64n.html
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-svdt.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-svlink.8 b/mdoc/man8/s6-svlink.8
--- a/mdoc/man8/s6-svlink.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-svlink.8	2023-04-16 04:52:39.124496466 -0300
@@ -0,0 +1,194 @@
+.Dd September 29, 2021
+.Dt S6-SVLINK 8
+.Os
+.Sh NAME
+.Nm s6-svlink
+.Nd integrate service directories into an existing service manager sequence and eliminate race conditions
+.Sh SYNOPSIS
+.Nm
+.Op Fl d | Fl D
+.Op Fl P
+.Op Fl f
+.Op Fl t Ar timeout
+.Ar scandir
+.Ar servicedir
+.Op Ar name
+.Sh DESCRIPTION
+.Nm
+creates, in an
+.Xr s6-scan-directory 7 ,
+a symlink to an
+.Xr s6-service-directory 7 ,
+and notifies
+.Xr s6-svscan 8
+that a new service has been registered.
+It waits until an
+.Xr s6-supervise 8
+supervisor process has been spawned to manage the new service, then exits.
+.Bl -bullet -width x
+.It
+.Nm
+expects a running
+.Xr s6-svscan 8
+process on
+.Ar scandir
+and a fully functional, but unsupervised,
+.Xr s6-service-directory 7
+in
+.Ar servicedir .
+.It
+It symlinks
+.Ar servicedir
+into
+.Ar scandir .
+The symbolic link is named
+.Ar name ;
+if no
+.Ar name
+argument has been given, the name given to the symbolic link is the
+basename of
+.Ar servicedir .
+.It
+It sends a command to
+.Xr s6-svscan 8
+to signal it that a new service is available.
+.It
+It waits for an
+.Xr s6-supervise 8
+process to be spawned on
+.Ar servicedir .
+.It
+It exits 0.
+.El
+.Pp
+Using
+.Nm
+to start services is a suboptimal pattern: it requires precise
+manipulations involving use of
+.Xr s6-ftrigrd 8
+in order to avoid race conditions, so it is relatively expensive.
+The simpler, more efficient pattern is to have all the supervisors
+already started at boot time, so the existence of the supervisor can
+be relied on, and starting the service becomes a trival and instant
+operation - this is, for instance, how the s6-rc service manager[1]
+behaves.
+However, it can be difficult to implement this pattern with other
+services managers such as OpenRC; in those cases,
+.Nm ,
+which starts the supervisors one at a time, can be used instead.
+.Pp
+If
+.Ar servicedir
+is logged, i.e.\&
+.Ql Pa servicedir Ns /log
+is also a valid service directory, then
+.Nm
+will wait until supervisors have been spawned for both the service and
+its logger.
+.Pp
+.Nm
+sends an
+.Ql s6-svscanctl -a
+command to
+.Ar scandir ,
+which means that the system's view of services will be refreshed.
+Depending on what links exist in
+.Ar scandir ,
+other services than
+.Ar servicedir
+may also appear.
+.Pp
+The symmetrical program to
+.Nm
+is named
+.Xr s6-svunlink 8 .
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl d
+Down.
+The supervisor will be started, but the service itself will remain down.
+Any
+.Ql Pa servicedir Ns /down
+file will be deleted.
+By default, if neither the
+.Fl d
+nor
+.Fl D
+options have been given, the supervisor auto-starts the service as
+soon as it runs.
+.It Fl D
+Down, and stay down.
+The supervisor will be started, but the service itself will remain down.
+A
+.Ql Pa servicedir Ns /down
+file will be created.
+By default, if neither the
+.Fl d
+nor
+.Fl D
+options have been given, the supervisor auto-starts the service as
+soon as it runs.
+.It Fl P
+Public.
+If
+.Ql Pa servicedir Ns /event
+does not exist, it will be created as public, i.e. anyone will be able
+to subscribe to this
+.Xr s6-fifodir 7 .
+By default, it will be created as private, i.e. only processes running
+with the same gid as the
+.Xr s6-svscan 8
+process will be able to subscribe to it.
+.It Fl f
+Force permissions.
+The presence or absence of the
+.Fl P
+option (i.e. the public or private state of
+.Ql Pa servicedir Ns /event )
+will be enforced even if
+.Ql Pa servicedir Ns /event
+already exists.
+By default,
+.Nm
+exits with an error message if
+.Ql Pa servicedir Ns /event
+exists and its public/private state mismatches what is requested.
+.It Fl t Ar timeout
+If the supervisor has not started after
+.Ar timeout
+milliseconds,
+.Nm
+will print a message to stderr and exit 99.
+By default,
+.Ar timeout
+is 0, which means no time limit.
+.El
+.Sh EXIT STATUS
+.Bl -tag -width x
+.It 0
+Success.
+.It 99
+Timeout while waiting for the supervisor to start.
+.It 100
+Wrong usage.
+.It 111
+System call failed.
+.El
+.Sh SEE ALSO
+.Xr s6-fifodir 7 ,
+.Xr s6-scan-directory 7 ,
+.Xr s6-service-directory 7 ,
+.Xr s6-ftrigrd 8 ,
+.Xr s6-supervise 8 ,
+.Xr s6-svscan 8 ,
+.Xr s6-svscanctl 8 ,
+.Xr s6-svunlink 8
+.Pp
+[1]
+.Lk https://skarnet.org/software/s6-rc/
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-svlink.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-svlisten.8 b/mdoc/man8/s6-svlisten.8
--- a/mdoc/man8/s6-svlisten.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-svlisten.8	2023-04-16 04:52:39.125496466 -0300
@@ -0,0 +1,188 @@
+.Dd September 29, 2021
+.Dt S6-SVLISTEN 8
+.Os
+.Sh NAME
+.Nm s6-svlisten
+.Nd run a program while listening on notifications from a collection of supervised services, and block until they all go up, or down
+.Sh SYNOPSIS
+.Bl -bullet -width x
+.It
+In an execline[1] script:
+.Pp
+.Nm
+.Op Fl U | u | D | d | r | R
+.Op Fl a | o
+.Op Fl t Ar timeout
+.Bro
+.Ar servicedir servicedir...
+.Brc
+.Ar prog...
+.It
+Outside of an execline script:
+.Pp
+.Nm
+.Op Fl U | u | D | d | r | R
+.Op Fl a | o
+.Op Fl t Ar timeout
+.Ar servicedir servicedir...
+""
+.Ar prog...
+.El
+.Sh DESCRIPTION
+.Nm
+only waits for notifications; it never polls.
+.Pp
+.Nm
+checks the state of one or more
+.Xr s6-service-directory 7 Ns s
+given as arguments in the first block and monitors their state
+changes.
+.Pp
+It spawns
+.Ar prog...
+as a child right after getting the initial state of all the monitored
+services.
+.Pp
+It then blocks until the wanted state happens.
+.Pp
+.Nm
+is the service-specific version of
+.Xr s6-ftrig-listen 8 .
+The point of
+.Nm s6-svlisten
+is to use it to spawn a program such as
+.Xr s6-svc 8 ,
+in order to send signals to services while making sure to catch their
+state changes - thus avoiding the race condition that occurs when
+running
+.Xr s6-svc 8
+then
+.Xr s6-svwait 8
+sequentially.
+.Pp
+.Nm
+needs to handle a variable length list of service directories.
+For that, it uses an encoding provided by execline, so it's best to
+only use it in execline scripts (only the execline syntax is
+guaranteed not to change).
+There is a variant of
+.Nm
+that does not use execline syntax, but only handles one service
+directory:
+.Xr s6-svlisten1 8 .
+.Pp
+The
+.Fl R
+or
+.Fl r
+options imply the
+.Fl a
+option.
+It is not possible to wait for one of the listed services to restart.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl u
+Up.
+.Nm
+will wait until the services are up, as reported by
+.Xr s6-supervise 8 .
+This is the default; it is not reliable, but it does not depend on
+specific support in the service programs.
+See
+.Xr s6-notifywhenup 7
+for details.
+.It Fl U
+Really up.
+.Nm
+will wait until the services are up and ready as reported by the
+services themselves.
+This requires specific support in the service programs, and the use of
+the
+.Pa notification-fd
+file in the service directory.
+See the explanation in
+.Xr s6-notifywhenup 7 .
+.It Fl d
+Down.
+.Nm
+will wait until the services are down.
+.It Fl D
+Really down.
+.Nm
+will wait until the services are down and the cleanup scripts in
+.Sm off
+.Ar servicedir /
+.Pa finish
+.Sm on for every
+.Ar servicedir
+have finished executing (or have timed out and been killed).
+.It Fl r
+Restart.
+.Nm
+will wait until all the services have been started or restarted,
+i.e. they have been in the down state, then the up state.
+.It Fl R
+Restart and ready.
+.Nm
+will wait until all the services have been started or restarted and
+have notified readiness.
+.It Fl o
+Or.
+.Nm
+will wait until one of the given services comes up or down.
+.It Fl a
+And.
+.Nm
+will wait until all of the given services come up or down.
+This is the default.
+.It Fl t Ar timeout
+If the requested events have not happened after
+.Ar timeout
+milliseconds,
+.Nm
+will print a message to stderr and exit 99.
+By default,
+.Ar timeout
+is 0, which means no time limit.
+.El
+.Sh EXIT STATUS
+.Bl -tag -width x
+.It 0
+Success, the wanted state has been reached.
+.It 99
+Timed out.
+.It 100
+Wrong usage.
+.It 102
+The
+.Xr s6-supervise 8
+process monitoring the service died.
+.It 111
+System call failed.
+.It Em n
+Services were expected to come up, but
+.Em n
+of them reported permanent failure.
+.El
+.Sh SEE ALSO
+.Xr s6-notifyoncheck 8 ,
+.Xr s6-permafailon 8 ,
+.Xr s6-supervise 8 ,
+.Xr s6-svc 8 ,
+.Xr s6-svdt 8 ,
+.Xr s6-svdt-clear 8 ,
+.Xr s6-svlisten1 8 ,
+.Xr s6-svok 8 ,
+.Xr s6-svscan 8 ,
+.Xr s6-svscanctl 8 ,
+.Xr s6-svstat 8 ,
+.Xr s6-svwait 8
+.Pp
+[1]
+.Lk https://skarnet.org/software/execline/
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-svlisten.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-svlisten1.8 b/mdoc/man8/s6-svlisten1.8
--- a/mdoc/man8/s6-svlisten1.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-svlisten1.8	2023-04-16 04:52:39.125496466 -0300
@@ -0,0 +1,144 @@
+.Dd September 29, 2021
+.Dt S6-SVLISTEN1 8
+.Os
+.Sh NAME
+.Nm s6-svlisten1
+.Nd run a program while listening on notifications from a supervised service, and block until said service goes up, or down
+.Sh SYNOPSIS
+.Nm
+.Op Fl U | u | D | d | r | R
+.Op Fl t Ar timeout
+.Ar servicedir
+.Ar prog...
+.Sh DESCRIPTION
+.Nm
+only waits for notifications; it never polls.
+.Nm
+checks the state of the
+.Ar servicedir
+.Xr s6-service-directory 7
+and monitors its state changes.
+.Pp
+It spawns
+.Ar prog...
+as a child right after getting the initial state of the service.
+.Pp
+It then blocks until the wanted state happens.
+.Pp
+.Nm
+is the service-specific version of
+.Xr s6-ftrig-listen1 8 .
+The point of
+.Nm
+is to use it to spawn a program such as
+.Xr s6-svc 8 ,
+in order to send signals to a service while making sure to catch its
+state changes - thus avoiding the race condition that occurs when
+running
+.Xr s6-svc 8
+then
+.Xr s6-svwait 8
+sequentially.
+.Pp
+The
+.Xr s6-svlisten 8
+program is an extension of
+.Nm .
+It can watch the state of several services at once; however, its
+syntax makes it best used in execline[1] scripts only.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl u
+Up.
+.Nm
+will wait until the service is up, as reported by
+.Xr s6-supervise 8 .
+This is the default; it is not reliable, but it does not depend on
+specific support in the service programs.
+See
+.Xr s6-notifywhenup 7
+for details.
+.It Fl U
+Really up.
+.Nm
+will wait until the service is up and ready as reported by the daemon
+itself.
+This requires specific support in the service programs, and the use of
+the
+.Pa notification-fd
+file in the
+.Xr s6-service-directory 7 .
+See the explanation in
+.Xr s6-notifywhenup 7 .
+.It Fl d
+Down.
+.Nm
+will wait until the service is down.
+.It Fl D
+Really down.
+.Nm
+will wait until the service is down and the cleanup script in
+.Sm off
+.Ar servicedir /
+.Pa finish
+.Sm on
+has finished executing (or has timed out and been killed).
+.It Fl r
+Restart.
+.Nm
+will wait until the service has been started or restarted, i.e. they
+have been in the down state, then the up state.
+.It Fl R
+Restart and ready.
+.Nm
+will wait until the service has been started or restarted and has
+notified readiness.
+.It Fl t Ar timeout
+If the requested event has not happened after
+.Ar timeout
+milliseconds,
+.Nm
+will print a message to stderr and exit 99.
+By default,
+.Ar timeout
+is 0, which means no time limit.
+.El
+.Sh EXIT STATUS
+.Bl -tag -width x
+.It 0
+Success, the wanted state has been reached.
+.It 1
+The service was supposed to go up, but reported permanent failure.
+.It 99
+Timed out.
+.It 100
+Wrong usage.
+.It 102
+The
+.Xr s6-supervise 8
+process monitoring the service died.
+.It 111
+System call failed
+.El
+.Sh SEE ALSO
+.Xr s6-notifyoncheck 8 ,
+.Xr s6-permafailon 8 ,
+.Xr s6-supervise 8 ,
+.Xr s6-svc 8 ,
+.Xr s6-svdt 8 ,
+.Xr s6-svdt-clear 8 ,
+.Xr s6-svlisten 8 ,
+.Xr s6-svok 8 ,
+.Xr s6-svscan 8 ,
+.Xr s6-svscanctl 8 ,
+.Xr s6-svstat 8 ,
+.Xr s6-svwait 8
+.Pp
+[1]
+.Lk https://skarnet.org/software/execline/
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-svlisten1.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-svok.8 b/mdoc/man8/s6-svok.8
--- a/mdoc/man8/s6-svok.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-svok.8	2023-04-16 04:52:39.125496466 -0300
@@ -0,0 +1,37 @@
+.Dd September 29, 2021
+.Dt S6-SVOK 8
+.Os
+.Sh NAME
+.Nm s6-svok
+.Nd check whether an
+.Xr s6-service-directory 7
+is currently supervised
+.Sh SYNOPSIS
+.Nm
+.Ar servicedir
+.Sh DESCRIPTION
+.Nm
+checks whether an
+.Xr s6-supervise 8
+process is currently monitoring
+.Ar servicedir .
+It exits 0 if there is one, or 1 if there is none.
+.Sh SEE ALSO
+.Xr s6-notifyoncheck 8 ,
+.Xr s6-permafailon 8 ,
+.Xr s6-supervise 8 ,
+.Xr s6-svc 8 ,
+.Xr s6-svdt 8 ,
+.Xr s6-svdt-clear 8 ,
+.Xr s6-svlisten 8 ,
+.Xr s6-svlisten1 8 ,
+.Xr s6-svscan 8 ,
+.Xr s6-svscanctl 8 ,
+.Xr s6-svstat 8 ,
+.Xr s6-svwait 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-svok.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-svperms.8 b/mdoc/man8/s6-svperms.8
--- a/mdoc/man8/s6-svperms.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-svperms.8	2023-04-16 04:52:39.125496466 -0300
@@ -0,0 +1,183 @@
+.Dd September 29, 2021
+.Dt S6-SVPERMS 8
+.Os
+.Sh NAME
+.Nm s6-svperms
+.Nd allows the user to see, or modify, for a given
+list of services: who can read their states, who can send them control
+commands, and who can subscribe to up/down events for those services
+.Sh SYNOPSIS
+.Nm
+.Op Fl v
+.Op Fl u | Fl g Ar group | Fl G Ar group | Fl o | Fl O Ar group
+.Op Fl e | Fl E Ar group
+.Ar servicedirs...
+.Sh DESCRIPTION
+Without options, or with only the
+Fl v
+option,
+.Nm
+prints 3 lines to stdout for every service directory listed in
+.Ar servicedirs .
+Every line contains the name of the service directory, then the
+following information:
+.Bl -tag -width x
+.It status:
+Indicates who is allowed to read status information on the service,
+with commands such as
+.Xr s6-svstat 8
+or
+.Xr s6-svdt 8 .
+The values can be
+.Ql owner ,
+for only the owner of the service;
+.Ql group: Ns Ar name ,
+for the owner and members of group
+.Ar name ;
+or
+.Ql public ,
+for all users.
+.It control:
+Indicates who is allowed to send control commands to the service, with
+commands such as
+.Xr s6-svc 8 .
+The values can be
+.Ql owner ,
+for only the owner of the service; or
+.Ql group: Ns Ar name ,
+for the owner and members of group
+.Ar name .
+.It events:
+Indicates who is allowed to subscribed to events sent by
+.Xr s6-supervise 8
+for this service, with commands such as
+.Xr s6-svwait 8
+or
+.Xr s6-svlisten1 8 .
+The values can be
+.Ql group: Ns Ar name ,
+for the owner and members of group
+.Ar name ;
+or
+.Ql public ,
+for all users.
+.El
+.Pp
+If something goes wrong while reading a part of the configuration of a
+service directory,
+.Nm
+does not print the corresponding line to stdout; instead, it prints a
+warning message to stderr.
+.Pp
+When invoked with other options,
+.Nm
+modifies the permissions of the service directories listed in
+.Ar servicedirs...
+as specified by the options.
+The same permissions will be applied to all the services listed in
+.Ar servicedirs... .
+.Pp
+The default (restrictive) permissions are safe.
+.Pp
+Unless operation of a service is restricted information, it is also
+safe to make
+.Ql status\&:
+more permissive.
+.Pp
+Opening
+.Ql control\&:
+to a group can be useful for instance in a shared administration
+situation when individual administrators are not given full root
+powers.
+.Pp
+Making
+.Ql events\&:
+public bears a small risk of a local DoS attack preventing more
+subscriptions to events, so it is not recommended for supervision
+trees where such subscriptions are critical to operations - such as a
+set of root services managed by s6-rc[1].
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl v
+Re-read the permissions after writing them, and print them to stdout.
+.It Fl u
+Restrict the
+.Ql status\&:
+and
+.Ql control\&:
+permissions to
+.Ql owner :
+only the owner of a service directory will be able to read its state
+or control the service.
+This is the default when
+.Xr s6-supervise 8
+starts a service for the first time.
+.It Fl g Ar group
+Allow members of group
+.Ar group
+to read the status of the service, but not to control it - control
+will be restricted to the owner.
+.It Fl G Ar group
+Allow members of group
+.Ar group
+to read
+.Em and
+control the service.
+.It Fl o
+Allow everyone to read the status of the service, but restrict
+.Ql control\&:
+to the owner.
+.It Fl O Ar group
+Allow everyone to read the status, and allow members of group
+.Ar group
+to control the service.
+.It Fl e
+Allow everyone to subscribe to events.
+.It Fl E Ar group
+Only allow members of group
+.Ar group
+to subscribe to events.
+This is the default when
+.Xr s6-supervise 8
+starts a service for the first time, with
+.Ar group
+being the primary group of the
+.Xr s6-supervise 8
+process
+.Po
+most likely
+.Ql root
+.Pc .
+.El
+.Pp
+.Ar group
+is normally a group name that will be searched in the group
+database.
+But if it starts with a colon
+.Po
+.Ql \&:
+.Pc ,
+the rest of
+.Ar group
+will be interpreted as a numerical gid, and the group database will
+not be read.
+.Sh EXIT STATUS
+.Bl -tag -width x
+.It 0
+Success.
+.It 1
+Something went wrong when reading permissions in one of the service directories.
+.It 100
+Wrong usage.
+.It 111
+System call failed.
+.El
+.Sh SEE ALSO
+[1]
+.Lk https://skarnet.org/software/s6-rc/
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-svperms.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-svscan.8 b/mdoc/man8/s6-svscan.8
--- a/mdoc/man8/s6-svscan.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-svscan.8	2023-04-16 04:52:39.125496466 -0300
@@ -0,0 +1,426 @@
+.Dd January 15, 2023
+.Dt S6-SVSCAN 8
+.Os
+.Sh NAME
+.Nm s6-svscan
+.Nd start and monitor a collection of
+.Xr s6-supervise 8
+processes
+.Sh SYNOPSIS
+.Nm
+.Op Fl d Ar notif
+.Op Fl X Ar consoleholder
+.Op Fl c Ar max
+.Op Fl t Ar rescan
+.Op Ar scandir
+.Sh DESCRIPTION
+.Nm
+starts and monitors a collection of
+.Xr s6-supervise 8
+processes, each of these processes monitoring a single service.
+It is designed to be either the root or a branch of a
+.Em supervision tree .
+.Pp
+If given a
+.Ar scandir
+argument,
+.Nm
+switches to it.
+Else it uses its current directory as the
+.Xr s6-scan-directory 7 .
+.Pp
+It exits 100 if another
+.Nm s6-svscan
+process is already monitoring this
+.Xr s6-scan-directory 7 .
+.Pp
+If the
+.Pa ./.s6-svscan
+control directory does not exist,
+.Nm
+creates it.
+However, it is recommended to already have a
+.Pa .s6-svscan
+subdirectory in your scan directory, because
+it is used to configure
+.Nm
+operation, see below.
+.Pp
+From this point on,
+.Nm s6-svscan
+never dies.
+It tries its best to keep control of what's happening.
+In case of a major system call failure, which means that the kernel or
+hardware is broken in some fashion, it executes into the
+.Pa .s6-svscan/crash
+program. (But if that execution fails,
+.Nm
+exits 111.)
+.Pp
+.Nm
+performs an initial
+.Em scan
+of its scan directory.
+.Pp
+.Nm
+then occasionally runs
+.Em scans
+or
+.Em reaps ,
+see below.
+.Pp
+.Nm
+runs until it is told to stop via
+.Xr s6-svscanctl 8 ,
+or an appropriate signal (see below).
+Then it executes into the
+.Pa .s6-svscan/finish
+program, if present; if not, it exits 0.
+.Ss Signals
+.Nm
+has special handling for the following signals:
+.Bl -tag -width x
+.It Dv SIGCHLD
+.It Dv SIGALRM
+.It Dv SIGABRT
+.It Dv SIGHUP
+.It Dv SIGINT
+.It Dv SIGTERM
+.It Dv SIGQUIT
+.It Dv SIGUSR1
+.It Dv SIGUSR2
+.It Dv SIGPWR
+(on systems that support it)
+.It Dv SIGWINCH
+(on systems that support it)
+.El
+.Pp
+Signals that are not in the above list are not caught by
+.Nm
+and will have the system's default effect.
+.Pp
+The behaviour for the first three signals in the list is always fixed:
+.Bl -tag -width x
+.It Dv SIGCHLD
+trigger the reaper.
+.It Dv SIGALRM
+trigger the scanner.
+.It Dv SIBABRT
+immediately exec into
+.Pa .s6-svscan/finish
+(or exit 0 if that script does not exist), without waiting for any
+processes to die.
+.El
+.Pp
+The behaviour for the rest of the list is configurable: on receipt of a
+.Ql SIGFOO ,
+.Nm
+will try to run an executable
+.Pa .s6-svscan/SIGFOO
+file.
+For instance, an
+.Pa .s6-svscan/SIGTERM
+executable script will be run on receipt of a
+.Dv SIGTERM .
+If the file cannot be found, or cannot be executed for any reason, the
+default behaviour for the signal will be applied.
+Default behaviours are:
+.Bl -tag -width x
+.It Dv SIGHUP
+Rescan and prune the supervision tree, i.e. make sure that new service
+directories visible from the scan directory have an
+.Xr s6-supervise 8
+process running on them, and instruct
+.Xr s6-supervise 8
+processes running on service directories that have become invisible
+from the scan directory to stop their service and exit.
+This behaviour can also be achieved via the
+.Ql s6-svscanctl -an Ar scandir
+command.
+This is the closest that
+.Nm
+can get to the traditional
+.Dq reload your configuration
+behaviour.
+.It Dv SIGINT
+same as
+.Dv SIGTERM
+below.
+.It Dv SIGTERM
+Instruct all the
+.Xr s6-supervise 8
+processes to stop their service and exit; wait for the whole
+supervision tree to die, without losing any logs; then exec into
+.Pa .s6-svscan/finish
+or exit 0. This behaviour can also be achieved via the
+.Ql s6-svscanctl -t Ar scandir
+command.
+.It Dv SIGQUIT
+Same as
+.Dv SIGTERM
+above, except that if a service is logged (i.e. there is a
+.Pa foo
+service
+.Em and
+a
+.Pa foo/log
+service) then the logging service will also be killed, instead of
+being allowed to exit naturally after its producer has flushed its
+output and died.
+This can solve problems with badly written logging programs, but it
+can also cause loss of logs since the logger may die before the
+producer has finished flushing everything.
+The behaviour can also be achieved via the
+.Ql s6-svscanctl -q Ar scandir
+command; you should only use this if
+.Dv SIGTERM Ns / Ns Fl t
+fails to properly tear down the supervision tree.
+.It Others
+No effect if an appropriate executable file in
+.Pa .s6-svscan/
+cannot be run.
+.El
+.Ss The reaper
+Upon receipt of a SIGCHLD, or an
+.Ql s6-svscanctl -z
+command,
+.Nm
+runs a
+.Em reaper
+routine.
+.Pp
+The reaper acknowledges (via some
+.Fn wait
+function), without blocking, every terminated child of
+.Nm ,
+even ones it does not know it has.
+This is especially important when
+.Nm
+is run as process 1[1].
+.Pp
+If the dead child is an
+.Xr s6-supervise 8
+process watched by
+.Nm ,
+and the last scan flagged that process as active, then it is restarted
+one second later.
+.Ss The scanner
+Upon receipt of a SIGALRM or a
+.Ql s6-svscanctl -a
+command,
+.Nm
+runs a
+.Em scanner
+routine. (It also runs it every
+.Ar rescan
+milliseconds if the
+.Fl t
+option has been given.)
+.Pp
+The scanner scans the current directory for subdirectories (or
+symbolic links to directories), which must be service directories.
+It skips names starting with dots.
+It will not create services for more than
+.Ar max
+subdirectories.
+.Pp
+For every new subdirectory
+.Ar dir
+it finds, the scanner spawns an
+.Xr s6-supervise 8
+process on it.
+If
+.Sm off
+.Ar dir
+/log
+.Sm on
+exists, it spawns an
+.Xr s6-supervise 8
+process on both
+.Ar dir
+and
+.Sm off
+.Ar dir
+/log,
+.Sm on
+and maintains a never-closing pipe from the service's stdout to
+the logger's stdin.
+This is
+.Em starting the service ,
+with or without a corresponding logger.
+Every service the scanner finds is flagged as
+.Dq active .
+.Pp
+The scanner remembers the services it found.
+If a service has been started in an earlier scan, but the current scan
+can't find the corresponding directory, the service is then flagged as
+inactive.
+No command is sent to stop inactive
+.Xr s6-supervise 8
+processes (unless the administrator uses
+.Sm off
+.Ql s6-svscanctl -n
+or a
+.Dv SIGHUP
+.Sm on
+), but inactive
+.Xr s6-supervise 8
+processes will not be restarted if they die.
+.Ss Notes
+.Bl -bullet -width x
+.It
+.Nm
+is designed to run until the machine is shut down.
+It is also designed as a suitable candidate for process 1.
+So, it goes out of its way to stay alive, even in dire
+situations.
+When it encounters a fatal situation, something it really cannot
+handle, it executes into
+.Pa .s6-svscan/crash
+instead of dying; when it is told to exit, it executes into
+.Pa .s6-svscan/finish .
+Administrators should make sure to design appropriate crash and finish
+routines.
+.It
+.Nm
+is a fully asynchronous state machine.
+It will read and process commands at any time, even when the computer
+is in trouble.
+.It
+.Nm
+.Em does not use
+.Xr malloc 3 .
+That means it will
+.Em never leak memory .
+However,
+.Nm s6-svscan uses
+.Xr opendir 3 ,
+and most
+.Xr opendir 3
+implementations internally use heap memory - so unfortunately, it's
+impossible to guarantee that
+.Nm
+does not use heap memory at all.
+.It
+Unless run with a nonzero
+.Fl t
+option, which is only a legacy feature used to emulate other
+supervision suites such as daemontools or runit,
+.Nm
+.Em never polls ;
+it only wakes up on notifications.
+The s6 supervision tree can be used in energy-critical environments.
+.El
+.Sh OPTIONS
+.Bl -tag -width -x
+.It Fl d Ar notif
+Notify readiness on file descriptor
+.Ar notif .
+When
+.Nm
+is ready to accept commands from
+.Xr s6-svscanctl 8 ,
+it will write a newline to
+.Ar notif .
+.Ar notif
+cannot be lesser than 3.
+By default, no notification is sent.
+Please note that using this option signals
+.Em shallow readiness :
+.Nm
+being
+.Dq ready
+only means that it is ready to accept commands.
+It
+.Em does not mean
+that all the services it launches at start are themselves ready, or
+even started, or even that the relevant
+.Xr s6-supervise 8
+processes have been started.
+If you need to test for
+.Em deep readiness ,
+meaning that all the services in the supervision tree have been
+started and are ready, you cannot rely on this option.
+.It Fl X Ar consoleholder
+Assume the output console is available on descriptor
+.Ar consoleholder .
+If this option is given, and a s6-svscan-log service exists, the
+.Xr s6-supervise 8
+process for that service will be run with
+.Ar consoleholder
+as its standard error.
+This is mainly useful for a setup done via s6-linux-init[2], where all
+error messages go to the s6-svscan-log catch-all logger service by
+default, except messages from this service itself, which fall back to
+.Ar consoleholder .
+If you're not sure what to use this option for, or how, you don't need it.
+.It Fl c Ar max
+Maintain services for up to max service directories.
+Default is 500.
+Lower limit is 2.
+Upper limit is 90000.
+If you're increasing this value from the default, please note that:
+.Bl -bullet -width x
+.It
+The higher
+.Ar max
+is, the more stack memory
+.Nm
+will use, up to 100 bytes per service.
+.It
+.Nm
+uses 2 file descriptors per logged service.
+.El
+.Pp
+It is the admin's responsibility to make sure that
+.Nm
+has enough available descriptors to function properly and does not
+exceed its stack limit.
+The default of 500 is safe and provides enough room for every
+reasonable system.
+.It Fl t Ar rescan
+perform a scan every
+.Ar rescan
+milliseconds.
+If
+.Ar rescan
+is 0 (the default), automatic scans are never performed after the
+first one and
+.Nm
+will only detect new services when told to via a
+.Ql s6-svscanctl -a
+command.
+Use of this option is discouraged; it should only be given to emulate
+the behaviour of other supervision suites.
+.Po
+.Ql -t5000
+for daemontools' svscan,
+.Ql -t14000
+for runit's runsvdir.
+.Pc
+.El
+.Sh SEE ALSO
+.Xr s6-notifyoncheck 8 ,
+.Xr s6-permafailon 8 ,
+.Xr s6-supervise 8 ,
+.Xr s6-svc 8 ,
+.Xr s6-svdt 8 ,
+.Xr s6-svdt-clear 8 ,
+.Xr s6-svlisten 8 ,
+.Xr s6-svlisten1 8 ,
+.Xr s6-svok 8 ,
+.Xr s6-svscanctl 8 ,
+.Xr s6-svstat 8 ,
+.Xr s6-svwait 8
+.Pp
+[1]
+.Lk https://skarnet.org/software/s6/s6-svscan-1.html
+.Pp
+[2]
+.Lk https://skarnet.org/software/s6-linux-init/
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-svscan.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-svscanctl.8 b/mdoc/man8/s6-svscanctl.8
--- a/mdoc/man8/s6-svscanctl.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-svscanctl.8	2023-04-16 04:52:39.126496466 -0300
@@ -0,0 +1,152 @@
+.Dd September 29, 2021
+.Dt S6-SVSCANCTL 8
+.Os
+.Sh NAME
+.Nm s6-svscanctl
+.Nd send commands to a running
+.Xr s6-svscan 8
+process
+.Sh SYNOPSIS
+.Nm
+.Op Fl zabhitqnN
+.Ar scandir
+.Sh DESCRIPTION
+.Nm
+sends the given series of commands to the
+.Xr s6-svscan 8
+process monitoring the
+.Ar scandir
+directory, then exits 0.
+It exits 111 if it cannot send a command, or
+100 if no
+.Xr s6-svscan 8
+process is running on
+.Ar scandir .
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl a
+Alarm.
+.Xr s6-svscan 8
+will immediately perform a scan of
+.Ar scandir
+to check for services.
+.It Fl z
+Destroy zombies.
+Immediately triggers
+.Xr s6-svscan 8 Ap
+s reaper mechanism.
+.It Fl b
+Abort.
+.Xr s6-svscan 8
+will exec into its finishing procedure.
+It will not kill any of the maintained
+.Xr s6-supervise 8
+processes, unless a
+.Fl t
+or
+.Fl q
+option is also present before the
+.Fl b
+option in the
+.Nm
+invocation.
+.It Fl h
+Reload configuration.
+.Xr s6-svscan 8
+will perform a scan, and destroy inactive services.
+Equivalent to
+.Fl an .
+.Fl i
+Equivalent to
+.Fl t
+below.
+.It Fl t
+Terminate.
+.Xr s6-svscan 8
+will send a
+.Dv SIGTERM
+to all the
+.Xr s6-supervise 8
+processes supervising a service and a
+.Dv SIGHUP
+to all the
+.Xr s6-supervise 8
+processes supervising a logger, then exec into its finish
+procedure.
+This means that services will be brought down but loggers will exit
+naturally on EOF, and
+.Xr s6-svscan 8
+will wait for them to exit before exec'ing into
+.Pa .s6-svscan/finish
+or exiting itself: it's a clean shutdown with no loss of logs.
+.It Fl q
+Quit.
+.Xr s6-svscan 8
+will send all its
+.Xr s6-supervise 8
+processes a
+.Dv SIGTERM ,
+then exec into its finish procedure.
+This is different from
+.Fl t
+in that services
+.Em and
+loggers will be forcibly killed, so the quit procedure may be faster
+but in-flight logs may be lost.
+.It Fl n
+Nuke.
+.Xr s6-svscan 8
+will kill all the
+.Xr s6-supervise 8
+processes it has launched but that did not match a service directory
+last time
+.Ar scandir
+was scanned, i.e. it prunes the supervision tree so that it matches
+exactly what was in
+.Ar scandir
+at the time of the last scan.
+A SIGTERM is sent to the
+.Xr s6-supervise 8
+processes supervising services and a SIGHUP is sent to the
+.Xr s6-supervise 8
+processes supervising loggers.
+.It Fl N
+Really nuke.
+Does the same thing as
+.Fl n ,
+except that SIGTERM is sent to all the relevant
+.Xr s6-supervise 8
+processes, even if they are supervising loggers.
+This is not recommended in a situation where you do not need to tear
+down the supervision tree.
+.El
+.Sh IMPLEMENTATION NOTES
+.Nm
+writes control commands into the
+.Pa scandir/.s6-svscan/control
+FIFO.
+An
+.Xr s6-svscan 8
+process running on
+.Ar scandir
+will be listening to this FIFO, and will read and interpret those
+commands.
+.Sh SEE ALSO
+.Xr s6-notifyoncheck 8 ,
+.Xr s6-permafailon 8 ,
+.Xr s6-supervise 8 ,
+.Xr s6-svc 8 ,
+.Xr s6-svdt 8 ,
+.Xr s6-svdt-clear 8 ,
+.Xr s6-svlisten 8 ,
+.Xr s6-svlisten1 8 ,
+.Xr s6-svok 8 ,
+.Xr s6-svscan 8 ,
+.Xr s6-svstat 8 ,
+.Xr s6-svwait 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-svscanctl.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-svstat.8 b/mdoc/man8/s6-svstat.8
--- a/mdoc/man8/s6-svstat.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-svstat.8	2023-04-16 04:52:39.126496466 -0300
@@ -0,0 +1,278 @@
+.Dd September 29, 2021
+.Dt S6-SVSTAT 8
+.Os
+.Sh NAME
+.Nm s6-svstat
+.Nd print a short, human-readable or programmatically parsable summary of the state of a process monitored by
+.Xr s6-supervise 8
+.Sh SYNOPSIS
+.Nm
+.Op Fl uwNrpest | o No up,wantedup,normallyup,ready,paused,pid,exitcode,signal,signum,updownsince,readysince,updownfor,readyfor
+.Op Fl n
+.Ar servicedir
+.Sh DESCRIPTION
+.Nm
+gives information about the process being monitored at the
+.Ar servicedir
+.Xr s6-service-directory 7 ,
+then exits 0.
+.Pp
+When
+.Nm
+is invoked without options, or with only the
+.Fl n
+option, it prints a human-readable summary of all the available
+information on the service.
+In this case, the
+.Fl n
+option instructs it to print a signal number (instead of a signal
+name) if the supervised process was killed by a signal.
+The summary includes the following data:
+.Bl -bullet -width x
+.It
+whether the process is up or down, and if it's up, the number of
+seconds that it has been up.
+.It
+the process' pid, if it is up, or its last exit code or terminating
+signal, if it is down.
+.It
+what its default state is, if it is different from its current state.
+.It
+the number of seconds since it last changed states.
+.It
+whether the service is ready
+.Po
+cf.
+.Xr s6-notifywhenup 7
+.Pc
+as notified by the daemon itself, and if
+it is, the number of seconds that it has been.
+A service reported as down and ready simply means that it is ready to
+be brought up.
+A service is down and not ready when it is in the cleanup phase,
+i.e. the
+.Pa ./finish
+script is still being executed.
+.El
+.Pp
+When
+.Nm
+is invoked with one or several options other than
+.Fl n ,
+it outputs programmatically parsable information instead.
+The output is a series of space-separated values, one value per
+requested field.
+The valid options are as follows.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl o Ar fields
+List fields to print.
+.Ar fields
+is a list of comma-separated field names.
+The valid field names are the following:
+.Bl -tag -width x
+.It up
+Print
+.Ql true
+if the service is up and
+.Ql false
+if it is down.
+.It wantedup
+Print
+.Ql true
+if
+.Xr s6-supervise 8
+is currently instructed to (re)start the service when it is down, and
+.Ql false
+if
+.Xr s6-supervise 8
+is currently instructed to leave the service alone.
+.It normallyup
+Print
+.Ql true
+if the service is supposed to start when
+.Xr s6-supervise 8
+starts (i.e. no
+.Pa ./down
+file), and
+.Ql false
+if it is not (i.e. there is a
+.Pa ./down
+file).
+.It ready
+Print
+.Ql true
+if the service is ready, and
+.Ql false
+if it is not.
+Note that
+a service can be both down and ready: it simply means that it is ready
+to be started (i.e. no
+.Pa ./finish
+script is currently running).
+To check for service readiness, you should give this option along with
+.Ql up :
+the service is ready iff
+.Ql s6-svstat -o up,ready
+prints
+.Ql true true .
+(The
+.Ql true true
+case will never happen if the service does not support readiness
+notification.)
+.It paused
+Print
+.Ql true
+if the service is paused (i.e. the process is currently stopped) and
+.Ql false
+if it is not.
+It is a rare flag, you shouldn't normally need to use this option.
+.It pid
+Print the pid of the supervised process.
+If the service is currently down,
+.Ql -1
+is printed instead.
+.It exitcode
+Print the exit code of the last execution of
+.Pa ./run .
+If the service is currently up, or the last
+.Pa ./run
+process was killed by a signal,
+.Ql -1
+is printed instead.
+.It signal
+Print the name of the signal the last
+.Pa ./run
+process was killed with.
+If the service is currently up, or the last
+.Pa ./run
+process was not killed by a signal,
+.Ql NA
+is printed instead.
+.It signum
+Print the number of the signal the last
+.Pa ./run
+process was killed with.
+If the service is currently up, or the last
+.Pa ./run
+process was not killed by a signal,
+.Ql -1
+is printed instead.
+.It updownsince
+Print a TAI64N[1] label representing the absolute date when the
+service last changed states.
+.It readysince
+Print a TAI64N[1] label representing the absolute date when the
+service last became ready.
+Note that this can either mean
+.Dq service readiness
+(if the service is currently up and ready), or
+.Dq down readiness ,
+i.e. the last time when the service was down and ready to be started
+(if the service is
+.Em not
+currently up and ready).
+.It updownfor
+Print the number of seconds that have elapsed since the service last
+changed states.
+.It readyfor
+Print the number of seconds that have elapsed since the service last
+became ready (or ready to be started if it's currently not up and
+ready).
+.El
+.It Fl u
+Equivalent to
+.Ql -o up .
+.It Fl w
+Equivalent to
+.Ql -o wantedup .
+.It Fl N
+Equivalent to
+.Ql -o normallyup .
+.It Fl r
+Equivalent to
+.Ql -o ready .
+.It Fl p
+Equivalent to
+.Ql -o pid .
+.It Fl e
+Equivalent to
+.Ql -o exitcode .
+.It Fl s
+Equivalent to
+.Ql -o signal .
+.It Fl t
+Equivalent to
+.Ql -o updownfor .
+.El
+.Sh EXIT STATUS
+.Bl -tag -width x
+.It 0
+Success.
+.It 1
+.Xr s6-supervise 8
+not running on
+.Ar servicedir .
+.It 100
+Wrong usage.
+.It 111
+System call failed.
+.El
+.Sh EXAMPLES
+.Dl s6-svstat -o up,ready
+.Pp
+or its equivalent,
+.Ql s6-svstat -ur ,
+will print
+.Ql true true
+if the service is up and ready,
+.Ql true false
+if the service has been started but has not notified readiness yet,
+.Ql false true
+if it is down and can be started, and
+.Ql false false
+if it is down and there's a
+.Pa ./finish
+script running that needs to exit before the service can be restarted.
+.Pp
+.Dl s6-svstat -o pid,exitcode,signal
+.Pp
+or its equivalent,
+.Ql s6-svstat -pes ,
+will print
+.Ql 42 -1 NA
+if the service has been started and
+.Pa ./run Ap
+s pid is 42; it will print
+.Ql -1 0 NA
+if the service is down and
+.Pa ./run
+last exited 0; it will print
+.Ql -1 -1 SIGTERM
+if the service is down and
+.Pa ./run
+was last killed by a SIGTERM - as can happen, for instance, when you
+down the service via a call to
+.Ql s6-svc -d .
+.Sh SEE ALSO
+.Xr s6-notifyoncheck 8 ,
+.Xr s6-permafailon 8 ,
+.Xr s6-supervise 8 ,
+.Xr s6-svc 8 ,
+.Xr s6-svdt 8 ,
+.Xr s6-svdt-clear 8 ,
+.Xr s6-svlisten 8 ,
+.Xr s6-svlisten1 8 ,
+.Xr s6-svok 8 ,
+.Xr s6-svscan 8 ,
+.Xr s6-svscanctl 8 ,
+.Xr s6-svwait 8
+.Pp
+[1]
+.Lk https://cr.yp.to/libtai/tai64.html
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-svstat.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-svunlink.8 b/mdoc/man8/s6-svunlink.8
--- a/mdoc/man8/s6-svunlink.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-svunlink.8	2023-04-16 04:52:39.126496466 -0300
@@ -0,0 +1,121 @@
+.Dd September 29, 2021
+.Dt S6-SVUNLINK 8
+.Os
+.Sh NAME
+.Nm s6-svunlink
+.Nd integrate service directories into an existing service manager sequence and eliminate race conditions
+.Sh SYNOPSIS
+.Nm
+.Op Fl X
+.Op Fl t Ar timeout
+.Ar scandir
+.Ar name
+.Sh DESCRIPTION
+.Nm
+unlinks an
+.Xr s6-service-directory 7
+from an
+.Xr s6-scan-directory 7 ,
+then notifies
+.Xr s6-svscan 8
+that a service has been unregistered.
+It waits until the
+.Xr s6-supervise 8
+supervisor process managing the service has disappeared, then exits.
+.Bl -bullet -width x
+.It
+.Nm
+expects a running
+.Xr s6-svscan 8
+process on
+.Ar scandir
+and a fully functional supervised service on the
+.Xr s6-service-directory 7
+in
+.Ql Ar scandir Ns / Ns Ar name ,
+which must be a symbolic link to a real directory located somewhere
+else.
+.It
+It deletes the
+.Ql Ar scandir Ns / Ns Ar name
+symlink.
+.It
+It sends a command to
+.Xr s6-svscan 8
+to signal it that a service has disappeared.
+.It
+It waits for the
+.Xr s6-supervise 8
+process managing the service directory to exit.
+.It
+It exits 0.
+.El
+.Pp
+Using
+.Nm
+to stop services is a suboptimal pattern: starting and stopping
+supervisors is a heavier operation than just stopping services.
+The simpler, more efficient pattern is to simply perform
+.Ql s6-svc -dwD Ar scandir Ns / Ns Ar name ,
+which only commands, and waits for, the death of the service, without
+impacting the supervisor.
+Nevertheless, for symmetry with
+.Xr s6-svlink 8 ,
+this program is provided.
+.Pp
+.Nm
+is a destructor; as is, it returns 0 even in situations that are
+nominal failures.
+For instance, it returns 0 even if its timeout expires; the rationale
+is that there is no sensible action for the user to do if this error
+is reported.
+.Nm
+only reports errors when they uncover a deeper problem in the system.
+.Pp
+.Nm
+sends a
+.Ql s6-svscanctl -an
+command to
+.Ar scandir ,
+which means that the system's view of services will be refreshed and
+inactive services will be killed and unsupervised.
+Depending on what links exist in
+.Ar scandir ,
+new services may appear, and other services than
+.Ar name
+may disappear.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl X
+Don't wait.
+.Nm
+will exit right away, without waiting for the supervisor to exit first.
+.It Fl t Ar timeout
+If the supervisor has not exited after
+.Ar timeout
+milliseconds,
+.Nm
+will still exit.
+The default is 0, meaning no time limit.
+.El
+.Sh EXIT STATUS
+.Bl -tag -width x
+.It 0
+Success.
+.It 100
+Wrong usage.
+.It 111
+System call failed.
+.El
+.Sh SEE ALSO
+.Xr s6-scan-directory 7 ,
+.Xr s6-service-directory 7 ,
+.Xr s6-supervise 8 ,
+.Xr s6-svlink 8 ,
+.Xr s6-svscan 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-svunlink.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-svwait.8 b/mdoc/man8/s6-svwait.8
--- a/mdoc/man8/s6-svwait.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-svwait.8	2023-04-16 04:52:39.126496466 -0300
@@ -0,0 +1,171 @@
+.Dd September 29, 2021
+.Dt S6-SVWAIT 8
+.Os
+.Sh NAME
+.Nm s6-svwait
+.Nd monitor one or more
+.Xr s6-service-directory 7 Ns s
+given as its arguments, waiting for a state (ready, up or down) to
+happen
+.Sh SYNOPSIS
+.Nm
+.Op Fl U | u | D | d | r | R
+.Op Fl a | o
+.Op Fl t Ar timeout
+.Ar servicedir...
+.Sh DESCRIPTION
+.Nm
+only waits for notifications; it never polls.
+.Pp
+.Nm
+should be given one or more
+.Em service directories
+as arguments, not an
+.Xr s6-scan-directory 7 .
+If you need to wait for a whole scan directory, give all its contents
+as arguments to
+.Nm s6-svwait .
+.Pp
+.Nm
+will only work on service directories that are already active,
+i.e. have an
+.Xr s6-supervise 8
+process running on them.
+It will not work on a service directory where
+.Xr s6-supervise 8
+has not been started yet.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl u
+Up.
+.Nm
+will wait until the services are up, as reported by
+.Xr s6-supervise 8 .
+This is the default; it is not reliable, but it does not depend on
+specific support in the service programs.
+See
+.Xr s6-notifywhenup 7
+for details.
+.It Fl U
+Really up.
+.Nm
+will wait until the services are up and ready as reported by the
+services themselves.
+This requires specific support in the service programs, and the use of
+the
+.Pa notification-fd
+file in the
+.Xr s6-service-directory 7 .
+See the explanation in
+.Xr s6-notifywhenup 7 .
+.It Fl d
+Down.
+.Nm
+will wait until the services are down.
+.It Fl D
+Really down.
+.Nm
+will wait until the services are down and the cleanup scripts in
+.Sm off
+.Ar servicedir /
+.Pa finish
+.Sm on
+for every
+.Ar servicedir
+have finished executing (or have timed out and been killed).
+.It Fl r
+Restart.
+.Nm
+will wait until the services are down, then until they are up.
+If the
+.Fl o
+option is given, it waits until
+.Em all
+services are down and
+.Em one
+service is up; otherwise it waits until
+.Em all
+the services have restarted.
+.It Fl R
+Restart and ready.
+.Nm
+will wait until the services are down, then until they are up and
+ready.
+If the
+.Fl o
+option is given, it waits until
+.Em all
+services are down and
+.Em one
+service is up and ready; otherwise it waits until
+.Em all
+the services have restarted and are ready.
+.It Fl o
+Or.
+.Nm
+will wait until
+.Em one
+of the given services comes up or down.
+.It Fl a
+And.
+.Nm
+will wait until
+.Em all
+of the given services come up or down.
+This is the default.
+.It Fl t Ar timeout
+If the requested events have not happened after timeout milliseconds,
+.Nm
+will print a message to stderr and exit 99.
+By default,
+.Ar timeout
+is 0, which means no time limit.
+.El
+.Sh IMPLEMENTATION NOTES
+.Nm
+spawns an
+.Xr s6-ftrigrd 8
+child to listen to notifications sent by
+.Xr s6-supervise 8 .
+It also checks
+.Pa supervise/status
+files to get the current service states, so it is immune to race
+conditions.
+.Sh EXIT STATUS
+.Bl -tag -width x
+.It 0
+Success, the wanted state has been reached.
+.It 99
+Timed out.
+.It 100
+Wrong usage.
+.It 102
+The
+.Xr s6-supervise 8
+process monitoring the service died.
+.It 111
+System call failed.
+.It Em n
+Services were expected to come up, but
+.Em n
+of them reported permanent failure.
+.El
+.Sh SEE ALSO
+.Xr s6-notifyoncheck 8 ,
+.Xr s6-permafailon 8 ,
+.Xr s6-supervise 8 ,
+.Xr s6-svc 8 ,
+.Xr s6-svdt 8 ,
+.Xr s6-svdt-clear 8 ,
+.Xr s6-svlisten 8 ,
+.Xr s6-svlisten1 8 ,
+.Xr s6-svok 8 ,
+.Xr s6-svscan 8 ,
+.Xr s6-svscanctl 8 ,
+.Xr s6-svstat 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-svwait.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-tai64n.8 b/mdoc/man8/s6-tai64n.8
--- a/mdoc/man8/s6-tai64n.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-tai64n.8	2023-04-16 04:52:39.126496466 -0300
@@ -0,0 +1,43 @@
+.Dd September 29, 2021
+.Dt S6-TAI64N 8
+.Os
+.Sh NAME
+.Nm s6-tai64n
+.Nd read from stdin and write to stdout, prepending lines with a TAI64N timestamp[1] and a space
+.Sh SYNOPSIS
+.Nm
+.Sh DESCRIPTION
+.Nm
+exits 0 when it sees the end of stdin.
+If there's an unfinished line,
+.Nm
+processes it, adds a newline character to it, and writes it before
+exiting.
+.Pp
+.Nm
+does neither
+.Dq line buffering
+nor
+.Dq block buffering .
+It does optimal buffering, i.e. it flushes its output buffer every
+time it risks blocking on input.
+Every filter should behave this way, whether its output is a tty or
+not: it's simpler and more efficient in every case.
+.Sh SEE ALSO
+.Xr s6-applyuidgid 8 ,
+.Xr s6-envdir 8 ,
+.Xr s6-envuidgid 8 ,
+.Xr s6-fghack 8 ,
+.Xr s6-setsid 8 ,
+.Xr s6-setuidgid 8 ,
+.Xr s6-softlimit 8 ,
+.Xr s6-tai64nlocal 8
+.Pp
+[1]
+.Lk https://skarnet.org/software/skalibs/libstddjb/tai.html#timestamp
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-tai64n.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-tai64nlocal.8 b/mdoc/man8/s6-tai64nlocal.8
--- a/mdoc/man8/s6-tai64nlocal.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-tai64nlocal.8	2023-04-16 04:52:39.127496466 -0300
@@ -0,0 +1,88 @@
+.Dd September 29, 2021
+.Dt S6-TAI64NLOCAL 8
+.Os
+.Sh NAME
+.Nm s6-tai64nlocal
+.Nd read from stdin and write to stdout, replacing every line beginning with a TAI64N timestamp[1] with a human-readable local date and time
+.Sh SYNOPSIS
+.Nm
+.Op Fl g
+.Sh DESCRIPTION
+.Nm
+exits 0 when it sees the end of stdin.
+If there's an unfinished line,
+.Nm
+processes it and writes it before exiting.
+.Pp
+The typical use case of
+.Nm
+is to read files that have been filtered through
+.Xr s6-tai64n 8 ,
+or log files that have been produced by
+.Xr s6-log 8
+with the
+.Fl t
+option.
+For instance, to read the latest httpd logs with human-readable
+timestamps,
+.Ql s6-tai64nlocal < /var/log/httpd/current | less
+is a possible command.
+.Pp
+.Nm
+does neither
+.Dq line buffering
+nor
+.Dq block buffering .
+It does optimal buffering, i.e. it flushes its output buffer every
+time it risks blocking on input.
+.Pp
+If
+.Nm
+does not appear to give the correct local time:
+.Bl -bullet -width x
+.It
+Check the compilation options that were used for the skalibs[2] libraries
+your
+.Nm s6-tai64nlocal
+program was linked against.
+In particular, check whether the
+.Ql --enable-tai-clock
+or
+.Ql --enable-right-tz
+configure options have been given.
+.It
+Compare these flags and their meanings with your current timezone.
+In particular, check
+.Pa /etc/localtime ,
+.Pa /etc/timezone ,
+.Pa /etc/TZ ,
+and the
+.Ev TZ
+environment variable.
+.El
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl g
+Print GMT time instead of local time.
+.El
+.Sh SEE ALSO
+.Xr s6-applyuidgid 8 ,
+.Xr s6-envdir 8 ,
+.Xr s6-envuidgid 8 ,
+.Xr s6-fghack 8 ,
+.Xr s6-setsid 8 ,
+.Xr s6-setuidgid 8 ,
+.Xr s6-softlimit 8 ,
+.Xr s6-tai64n 8
+.Pp
+[1]
+.Lk https://skarnet.org/software/skalibs/libstddjb/tai.html#timestamp
+.Pp
+[2]
+.Lk https://skarnet.org/software/skalibs/
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-tai64nlocal.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6-usertree-maker.8 b/mdoc/man8/s6-usertree-maker.8
--- a/mdoc/man8/s6-usertree-maker.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6-usertree-maker.8	2023-04-16 04:52:39.127496466 -0300
@@ -0,0 +1,494 @@
+.Dd January 15, 2023
+.Dt S6-USERTREE-MAKER 8
+.Os
+.Sh NAME
+.Nm s6-usertree-maker
+.Nd create an
+.Xr s6-service-directory 7
+implementing a service that runs an
+.Xr s6-svscan 8
+process owned by a given user, on an
+.Xr s6-scan-directory 7
+belonging to that user
+.Sh SYNOPSIS
+.Nm
+.Op Fl d Ar userscandir
+.Op Fl p Ar path
+.Op Fl E Ar envdir Op Fl e Ar var Fl e Ar var ...
+.Op Fl r Ar service Ns / Ns Ar logger Ns Op / Ns Ar pipeline
+.Op Fl l Ar loguser
+.Op Fl t Ar stamptype
+.Op Fl n Ar nfiles
+.Op Fl s Ar filesize
+.Op Fl S Ar maxsize
+.Op Fl P Ar prefix
+.Ar user
+.Ar logdir
+.Ar dir
+.Sh DESCRIPTION
+.Nm
+is meant to help admins deploy systems where each user has their own
+supervision subtree, rooted in the main supervision tree owned by
+root.
+.Pp
+Alternatively,
+.Nm
+can create source definition directories for the s6-rc[1] service
+manager.
+.Pp
+.Nm
+creates an
+.Xr s6-service-directory 7
+in
+.Ar dir ,
+that launches a supervision tree as user
+.Ar user
+on
+.Xr s6-scan-directory 7
+.Ar userscandir ,
+with a catch-all logger logging the tree's output via
+.Xr s6-log 8
+to the
+.Ar logdir
+directory.
+.Pp
+.Nm
+makes use of the fact that execline[2] scripts are much easier to
+generate programmatically and to harden than shell scripts, so it is
+only built if s6 is built with execline support - i.e. the
+.Ql --disable-execline
+switch has
+.Em not
+been given to
+.Pa configure .
+.Pp
+For the admin who wants to automate user tree management,
+.Nm
+is a
+.Em building block
+meant to be used in scripts, not a complete turnkey solution.
+For instance,
+.Nm
+does not create
+.Ar userscandir
+for a user: it assumes that that
+.Xr s6-scan-directory 7
+is already in place.
+It does not create
+.Ar logdir
+either:
+.Ar logdir ,
+or at least its parent directory, must already exist before the logger
+is run, else
+.Xr s6-log 8
+will fail repeatedly.
+Make sure that all the data and metadata referenced by the service's
+and the logger's run scripts are actually present and valid before
+starting the service.
+.Pp
+If
+.Nm
+encounters failure (and exits 111), it does not clean up the
+directories it created.
+Make sure to always test
+.Nm Ap
+s return code and clean up after it if needed.
+.Ss Operation of the service
+When the service is started, its
+.Pa run
+script will execute the following operations:
+.Bl -bullet -width x
+.It
+Clear all its environment variables, except
+.Ev PATH .
+This prevents any data leak from the parent supervision tree into the
+user subtree.
+.It
+Fill its environment with data related to
+.Ar user :
+.Bl -bullet -width x
+.It
+.Ev USER
+is set to
+.Ar user .
+.It
+.Ev HOME
+is set to
+.Ar user Ap
+s home directory.
+.It
+.Ev UID
+is set to
+.Ar user Ap
+s uid.
+.It
+.Ev GID
+is set to
+.Ar user Ap
+s primary gid.
+.It
+.Ev GIDLIST
+is set to
+.Ar user Ap
+s supplementary groups list.
+.El
+.It
+If the service has been created with the
+.Fl E
+option to
+.Nm :
+.Bl -bullet -width x
+.It
+Add all the variables defined in
+.Ar envdir
+to its environment.
+.It
+For every variable
+.Ar var
+given via a
+.Fl e
+option, subject
+.Ar var
+to substitution with the
+.Ev USER ,
+.Ev HOME ,
+.Ev UID ,
+.Ev GID
+and
+.Ev GIDLIST
+variables (see below).
+.El
+.It
+Set the
+.Ev PATH
+environment variable to
+.Ar path ,
+subjected to variable substitution.
+.It
+Execute into
+.Xr s6-svscan 8 ,
+running in
+.Ar userscandir
+(which is first subjected to variable substitution).
+.El
+.Pp
+The service is logged: its stderr and stdout are piped to an
+.Xr s6-log 8
+process running as
+.Ar loguser
+and writing to the
+.Ar logdir
+directory.
+This logger is the catch-all logger for the supervision tree owned by
+.Ar user ;
+it is recommended to make
+.Ar loguser
+distinct from
+.Ar user ,
+and to have
+.Ar logdir
+in a place that is
+.Sy not
+under the control of
+.Ar user .
+.Pp
+If
+.Ar user
+wants to keep control of their logs, they can declare a logger for
+each of their services.
+.Ss Variable substitution
+When the service starts, the
+.Ev USER ,
+.Ev HOME ,
+.Ev UID ,
+.Ev GID
+and
+.Ev GIDLIST
+environment variables are deduced from
+.Ar user Ap
+s identity.
+The value of those variables may be used in a few configuration knobs:
+.Bl -bullet -width x
+.It
+The value of
+.Ar userscandir :
+it is likely that the
+.Xr s6-scan-directory 7
+belonging to
+.Ar user
+resides under
+.Ar user Ap
+s home directory.
+Or under
+.Pa /run/user/${UID} ,
+or some similar scheme.
+.It
+The
+.Ev PATH
+environment variable, declared in
+.Ar path :
+it is often useful to prepend the default system
+.Ev PATH
+with a user-specific directory that hosts that user's binaries.
+For instance, you may want the
+.Ev PATH
+to be set as something like
+.Pa ${HOME}/bin:/usr/bin:/bin .
+.It
+Any variable declared in
+.Ar envdir
+and given as an argument to an
+.Fl e
+option to
+.Nm .
+If
+.Ar envdir
+is a template valid for all users, it may contain variables that
+depends on user-specific data: for instance, the
+.Ev XDG_CONFIG_HOME
+variable may be
+set to
+.Pa ${HOME}/.config .
+.El
+.Pp
+When the strings
+.Ql ${USER} ,
+.Ql ${HOME} ,
+.Ql ${UID} ,
+.Ql ${GID} , or
+.Ql ${GIDLIST}
+appear in the value for
+.Ar userscandir ,
+.Ar path ,
+or any of the
+.Ar var
+variables, they are substituted with the corresponding value of the
+.Ev USER ,
+.Ev HOME ,
+.Ev UID ,
+.Ev GID ,
+or
+.Ev GIDLIST
+environment variable instead.
+.Pp
+For instance, if no
+.Fl d
+option is provided, the default value for
+.Ar userscandir
+is
+.Pa ${HOME}/service .
+If the provided
+.Ar user
+is
+.Ql ska
+and ska's home directory is
+.Pa /home/ska ,
+then
+.Xr s6-svscan 8
+will be run on
+.Pa /home/ska/service .
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl d Ar userscandir
+The supervision tree will be run on the
+.Ar userscandir
+directory.
+.Ar userscandir
+is subject to variable substitution (see above).
+Default is
+.Pa ${HOME}/service .
+.It Fl p Ar path
+The supervision tree will be run with a
+.Ev PATH
+environment variable set to
+.Ar path .
+.Ar path
+is subject to variable substitution.
+Default is
+.Pa /usr/bin:/bin ,
+or whatever has been given to the
+.Ql --with-default-path
+option to skalibs'
+.Pa configure
+script.
+.It Fl E Ar envdir
+The supervision tree will be run with the environment variables
+defined in the directory
+.Ar envdir ,
+which will be read via
+.Xr s6-envdir 8
+without options.
+By default, no envdir is defined and the supervision tree will only be
+run with the basic environment variables listed below.
+.It Fl e Ar var
+Perform variable substitution on
+.Ar var .
+This option is repeatable, and only makes sense when the
+.Fl E
+option is also given.
+For every
+.Ar var
+listed via an
+.Fl e
+option, the contents of
+.Ar var
+will be subjected to variable substitution before the supervision tree
+is run.
+This is only useful if
+.Ar var
+is defined in
+.Ar envdir ,
+as a template, that is then instanced for
+.Ar user
+when the service is run.
+By default, only the
+.Ev PATH
+environment variable, customizable via
+.Fl p ,
+is subjected to variable substitution.
+.It Fl r Ar service Ns / Ns Ar logger Ns / Ns Ar pipeline
+Create an s6-rc[1] source definition directory.
+When this option is given,
+.Ar dir
+is not created as an
+.Xr s6-service-directory 7 ,
+but as a directory containing two services:
+.Ar dir Ns / Ns Ar service
+and
+.Ar dir Ns / Ns Ar logger ,
+and
+.Ar dir
+is suitable as a source argument to s6-rc-compile[3].
+The
+.Ql / Ns Ar pipeline
+part can be omitted, but if it is present,
+.Ar pipeline
+is used as a name for a bundle containing both
+.Ar service
+and
+.Ar logger .
+When this option is not given,
+.Ar dir
+is a regular service directory for direct inclusion (or linking) in
+the parent scan directory
+.Po
+and the catch-all logger for the user subtree is declared in
+.Ar dir Ns / Ns log
+.Pc .
+.It Fl l Ar loguser
+Run the catch-all logger of the user subdirectory as user
+.Ar loguser .
+Default is
+.Ql root .
+.It Fl t Ar stamptype
+How logs are timestamped by the catch-all logger.
+.Ql 0
+means no timestamp,
+.Ql 1
+means external TAI64N format[4],
+.Ql 2
+means ISO 8601 format[5], and
+.Ql 3
+means both.
+Default is
+.Ql 1 .
+.It Fl n Ar nfiles
+Maximum number of archive files in
+.Ar logdir .
+Default is
+.Ql 10 .
+.It Fl s Ar filesize
+Maximum size of the
+.Pa current
+file (and archive files) in
+.Ar logdir .
+Default is
+.Ql 1000000 .
+.It Fl S Ar maxsize
+Maximum total size of the archives in the
+.Ar logdir .
+Default is
+.Ql 0
+meaning no limits apart from those enforced by the
+.Fl n
+and
+.Fl s
+options.
+.It Fl P Ar prefix
+When logging to
+.Ar logdir ,
+prefix logged lines with the
+.Ar prefix
+string.
+.El
+.Sh EXIT STATUS
+.Bl -tag -width x
+.It 0
+Success.
+.It 100
+Wrong usage.
+.It 111
+System call failed.
+.El
+.Sh EXAMPLES
+.Dl s6-usertree-maker -d '/run/user/${UID}/service' -p '${HOME}/bin:/usr/bin:/bin' -E /etc/user-env -e XDG_CONFIG_HOME -l catchlog ska /var/log/usertree/ska usertree-ska
+.Pp
+creates a service directory in
+.Ql usertree-ska
+declaring a service that starts a supervision tree on
+.Pa /run/user/1000/service
+if ska has uid 1000, with
+.Pa /home/ska/bin:/usr/bin/bin
+as its
+.Ev PATH
+if ska's home directory is
+.Pa /home/ska ,
+and with all the environment variables declared in
+.Pa /etc/user-env ,
+among which the
+.Ev XDG_CONFIG_HOME
+variable is processed for variable substitution.
+The supervision tree has a catch-all logger running as user catchlog,
+and storing its data in the
+.Pa /var/log/usertree/ska
+directory.
+.Pp
+Note that simple quotes are used here to prevent the shell from interpreting
+.Ql ${UID}
+and
+.Ql ${HOME} .
+.Pp
+.Dl s6-usertree-maker -d '/run/user/${UID}/service' -p '${HOME}/bin:/usr/bin:/bin' -E /etc/user-env -e XDG_CONFIG_HOME -l catchlog -r usertree-ska/usertree-ska-log/usertree-ska-pipeline ska /var/log/usertree/ska usertree
+.Pp
+Same as above, except it does not create a service directory -
+instead, it creates a
+.Ql usertree
+directory containing two subdirectories:
+.Ql usertree-ska ,
+the s6-rc[1] source definition directory for the service, and
+.Ql usertree-ska-log ,
+the source definition directory for its logger.
+It also creates an implicit
+.Ql usertree-ska-pipeline
+bundle containing both the service and the logger.
+.Sh SEE ALSO
+[1]
+.Lk https://skarnet.org/software/s6-rc/
+.Pp
+[2]
+.Lk https://skarnet.org/software/execline/
+.Pp
+[3]
+.Lk https://skarnet.org/software/s6-rc/s6-rc-compile.html
+.Pp
+[4]
+.Lk https://cr.yp.to/libtai/tai64.html
+.Pp
+[5]
+.Lk https://www.iso.org/iso/home/standards/iso8601.htm
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/s6-usertree-maker.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6lockd-helper.8 b/mdoc/man8/s6lockd-helper.8
--- a/mdoc/man8/s6lockd-helper.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6lockd-helper.8	2023-04-16 04:52:39.127496466 -0300
@@ -0,0 +1,54 @@
+.Dd September 29, 2021
+.Dt S6LOCKD-HELPER 8
+.Os
+.Sh NAME
+.Nm s6lockd-helper
+.Nd helper program for the
+.Xr s6lockd 8
+daemon
+.Sh DESCRIPTION
+.Nm
+just acquires a lock and holds it until it is killed or told to exit
+by its parent daemon.
+.Nm
+is not meant to be invoked directly by the user: it will be spawned by
+the
+.Xr s6lockd 8
+program.
+.Pp
+.Nm
+blocks on lock acquisition until it succeeds.
+It then notifies its parent.
+It exits when its parent tells it to (i.e. when the client asks for
+lock release).
+During the lock acquisition phase, it can be killed if its parent
+detects a timeout.
+.Pp
+One
+.Nm
+process per lock is the only way (apart from threads) to implement
+timed lock acquisition.
+This can lead to a lot of
+.Nm
+processes, but this is not a problem:
+.Bl -bullet -width x
+.It
+Processes are not a scarce resource.
+Today's schedulers work in O(1), or in O(a function of the number of
+runnable processes), which means that a sleeping process takes no
+scheduling time at all.
+.It
+.Nm
+is extremely tiny.
+Every instance should use up at most one or two pages of non-sharable
+memory.
+.El
+.Sh SEE ALSO
+.Xr s6-setlock 8 ,
+.Xr s6lockd 8
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/libs6/s6lockd-helper.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/s6lockd.8 b/mdoc/man8/s6lockd.8
--- a/mdoc/man8/s6lockd.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/s6lockd.8	2023-04-16 04:52:39.127496466 -0300
@@ -0,0 +1,79 @@
+.Dd September 29, 2021
+.Dt S6LOCKD 8
+.Os
+.Sh NAME
+.Nm s6lockd
+.Nd
+.Xr s6-s6lock 7
+daemon which manages a set of lock files in a given directory, and
+associated timeouts
+.Sh DESCRIPTION
+.Nm
+does not fork, does not background itself automatically, and does not
+use syslog.
+It is not meant to be run directly by the user: it will be spawned by
+the
+.Xr s6-s6lock 7
+client library.
+.Pp
+There are two ways to use
+.Nm :
+.Bl -enum -width x
+.It
+Use the
+.Fn s6lock_startf
+library call.
+An
+.Nm
+child will then be spawned from your calling process, and
+automatically reaped when you call
+.Fn s6lock_end .
+It requires care with applications that trap SIGCHLD.
+It also requires care with lock file permissions: an
+.Nm
+instance might not be able to open a lock file created by a former
+instance run by another client with different permissions.
+.It
+Use the
+.Fn s6lock_start
+library call, together with an
+.Nm
+.Xr s6-local-service 7 .
+For once,
+.Em this is the recommended setup :
+.Nm
+creates empty lock files, and having all
+.Nm
+instances run under the same user simplifies permissions management
+considerably.
+.El
+.Pp
+When run as a service,
+.Nm
+has no
+.Dq standalone
+mode: it is designed to work with a Unix domain super-server, like
+.Xr s6-ipcserver 8 .
+.Nm
+follows the UCSPI[1] interface; it can be directly executed from the
+super-server.
+.Pp
+Unix does not natively provide a way to stop blocking on a lock
+acquisition after a timeout.
+To emulate such behaviour,
+.Nm
+actually spawns an
+.Xr s6lockd-helper 8
+child per requested lock.
+.Sh SEE ALSO
+.Xr s6-setlock 8 ,
+.Xr s6lockd-helper 8
+.Pp
+[1]
+.Lk https://cr.yp.to/proto/ucspi.txt
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/libs6/s6lockd.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
diff -Naur a/mdoc/man8/ucspilogd.8 b/mdoc/man8/ucspilogd.8
--- a/mdoc/man8/ucspilogd.8	1969-12-31 21:00:00.000000000 -0300
+++ b/mdoc/man8/ucspilogd.8	2023-04-16 04:52:39.127496466 -0300
@@ -0,0 +1,101 @@
+.Dd September 29, 2021
+.Dt UCSPILOGD 8
+.Os
+.Sh NAME
+.Nm ucspilogd
+.Nd convert syslog facility numbers and alert levels into names
+.Sh SYNOPSIS
+.Nm
+.Op Fl d Ar undef
+.Op Ar var ...
+.Sh DESCRIPTION
+.Nm
+reads a stream of syslog-like messages on stdin.
+Those messages can be newline-terminated or null-terminated.
+.Pp
+For every line it reads: if it has been given
+.Ar var
+arguments, it writes the value of every
+.Ar var
+environment variable, followed by a colon and a space.
+.Pp
+If the line begins with a syslog facility number and/or alert level in
+the syslog format, it converts them into a human-readable name in the
+syslogd fashion.
+.Pp
+It then writes the processed line to stdout.
+.Pp
+You can emulate the whole syslogd behaviour by combining the following
+components:
+.Bl -bullet -width x
+.It
+A Unix stream super-server such as
+.Xr s6-ipcserver 8
+listening to the Unix domain socket
+.Pa /dev/log ,
+to connect to the kernel log-reading interface.
+.It
+.Nm
+running under that super-server, to read the logs and perform adequate
+transformations.
+.It
+A logger such as
+.Xr s6-log 8
+to store the logs into the filesystem.
+.It
+A supervision mechanism such as s6, to ensure ease of use and
+reliability of the whole chain.
+.El
+.Pp
+The resulting suite of programs is still smaller, and way more
+reliable, than a standard syslogd.
+.Pp
+In the
+.Pa examples/syslogd-linux
+subdirectory of the s6 package, you will find a suitable ucspilogd
+.Xr s6-service-directory 7 .
+The run scripts are written in the execline[1] language.
+.Pp
+.Sy Using ucspilogd as a klogd replacement
+.Pp
+Certain Unix kernels offer a nice interface to the kernel logs.
+For instance, the Linux kernel provides the
+.Pa /proc/kmsg
+fake file, that can be opened and read like a normal file, excepts
+that it gives the kernel logs when they are available and blocks
+otherwise.
+You can use
+.Nm
+to process data from those interfaces.
+.Pp
+The
+.Pa examples/klogd-linux
+subdirectory of the s6 package is an
+.Xr s6-service-directory 7
+providing such a klogd service for Linux, using the
+.Pa /proc/kmsg
+interface.
+.Sh OPTIONS
+.Bl -tag -width x
+.It Fl d Ar undef
+When a variable
+.Ar var
+given on the command line is actually undefined at
+.Nm
+execution time, print
+.Ar undef
+in place of what would be the variable's value on every line.
+Default is the string
+.Ql <undefined> .
+.El
+.Sh SEE ALSO
+.Xr s6-log 8
+.Pp
+[1]
+.Lk https://skarnet.org/software/execline/
+.Pp
+This man page is ported from the authoritative documentation at:
+.Lk https://skarnet.org/software/s6/ucspilogd.html
+.Sh AUTHORS
+.An Laurent Bercot
+.An Alexis Ao Mt flexibeast@gmail.com Ac (man page port)
